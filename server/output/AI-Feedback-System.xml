This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules/*, dist/*, build/*, *.md, *.log, *.lock, *.json, *.yml, *.yaml, *.xml, *.txt, *.gitignore, *.editorconfig, *.prettierrc, *.eslintrc, *.env, *.env.*, *.config.js, *.config.ts, *.d.ts, *.map, *.min.js, *.min.css, *.ico, *.png, *.jpg, *.jpeg, *.gif, *.svg, *.woff, *.woff2, *.ttf, *.eot, *.otf, *.mp3, *.mp4, *.webm, *.webp, *.zip, *.tar, *.gz, *.rar, *.7z, *.pdf, *.doc, *.docx, *.xls, *.xlsx, *.ppt, *.pptx, *.csv, *.tsv, *.sql, *.bak, *.tmp, *.temp, *.swp, *.swo, *.swn, *.sublime-workspace, *.sublime-project, *.vscode/*, *.idea/*, *.DS_Store, Thumbs.db
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/eslint.config.js
client/index.html
client/package.json
client/public/vite.svg
client/src/App.tsx
client/src/assets/react.svg
client/src/components/AssignmentList.tsx
client/src/components/BackButton.tsx
client/src/components/BasicButton.tsx
client/src/components/BasicHeading.tsx
client/src/components/basicList/BasicList.tsx
client/src/components/basicList/ListButton.tsx
client/src/components/basicList/ListHeader.tsx
client/src/components/basicList/ListItem.tsx
client/src/components/BasicSearchBar.tsx
client/src/components/FeedbackViewer.tsx
client/src/components/Footer.tsx
client/src/components/Header.tsx
client/src/components/SortableHeader.tsx
client/src/components/SortingButton.tsx
client/src/components/Spinner.tsx
client/src/components/Tabs.tsx
client/src/context/GitHubContext.ts
client/src/context/GitHubProvider.tsx
client/src/context/types.ts
client/src/context/useGitHub.ts
client/src/context/UserContext.ts
client/src/context/UserProvider.tsx
client/src/context/useUser.ts
client/src/hooks/useFilteredList.ts
client/src/index.css
client/src/layouts/MainLayout.tsx
client/src/main.tsx
client/src/pages/analyticsPage/AnalyticsPage.tsx
client/src/pages/analyticsPage/averageAssignmentPointsTab/AveragePointsChart.tsx
client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesChart.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/MissingSubmissionsList.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/StudentTable.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/Subtext.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/UploadStudentRosterCSVButton.tsx
client/src/pages/analyticsPage/TabNavigation.tsx
client/src/pages/assignmentPage/AssignmentsPage.tsx
client/src/pages/assignmentPage/GetCSVFileButton.tsx
client/src/pages/loginPage/LoginButton.tsx
client/src/pages/loginPage/LoginPage.tsx
client/src/pages/orgPage/OrgsPage.tsx
client/src/pages/repoDetailPage/CodeTab.tsx
client/src/pages/repoDetailPage/CommitsTab.tsx
client/src/pages/repoDetailPage/DiffTab.tsx
client/src/pages/repoDetailPage/FeedbackActions.tsx
client/src/pages/repoDetailPage/FeedbackCard.tsx
client/src/pages/repoDetailPage/FeedbackTab.tsx
client/src/pages/repoDetailPage/FileFeedbackSection.tsx
client/src/pages/repoDetailPage/FileTree.tsx
client/src/pages/repoDetailPage/MetadataTab.tsx
client/src/pages/repoDetailPage/RepoDetailPage.tsx
client/src/pages/repoDetailPage/RepoInfoCard.tsx
client/src/pages/repoPage/ReposPage.tsx
client/src/pages/SpecificUserSubmissionScreen.tsx
client/src/services/feedbackService.ts
client/src/services/submissionService.ts
client/src/types/OrgReport.ts
client/src/types/StudentInStudentRoster.ts
client/src/types/StudentSubmissionInfo.ts
client/src/utils/feedbackUtils.ts
client/src/utils/generateCSVFromOrg.ts
client/src/utils/parseFileTree.ts
client/src/utils/sortingUtils.ts
client/src/vite-env.d.ts
client/tailwind.config.js
client/tsconfig.app.json
client/tsconfig.json
client/tsconfig.node.json
client/vite.config.ts
docs/ARCHITECTURE.md
docs/EPICS.md
docs/PROJECT_PLAN.md
docs/REQUIREMENTS.md
server/.dockerignore
server/Aievolution.ts
server/AssignmentsService.ts
server/controllers/authController.ts
server/controllers/githubController.ts
server/Dockerfile
server/index.ts
server/middlewares/isAuthenticated.ts
server/package.json
server/repomix.js
server/repomix.ts
server/routes/authRoutes.ts
server/routes/githubRoutes.ts
server/routes/submitRoute.ts
server/routes/uploadCsvRoute.ts
server/services/github/githubService.ts
server/services/github/octokitClient.ts
server/services/UserService.ts
server/tsconfig.json
server/utils/githubUtils.ts
server/utils/json2csv.ts
server/utils/passport.ts
server/utils/supabase.ts
shared/aiInterfaces.ts
shared/githubInterfaces.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)
</file>

<file path="client/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitHub Classroom Analyzer</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="client/package.json">
{
  "name": "afs",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@heroicons/react": "^2.2.0",
    "@tailwindcss/vite": "^4.1.7",
    "axios": "^1.9.0",
    "chart.js": "^4.4.9",
    "papaparse": "^5.5.3",
    "react": "^19.1.0",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^19.1.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.5.3",
    "tailwindcss": "^4.1.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@types/node": "^22.15.18",
    "@types/papaparse": "^5.3.16",
    "@types/react": "^19.1.4",
    "@types/react-dom": "^19.1.5",
    "@vitejs/plugin-react": "^4.4.1",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.30.1",
    "vite": "^6.3.5",
    "vite-tsconfig-paths": "^5.1.4"
  }
}
</file>

<file path="client/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="client/src/App.tsx">
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import MainLayout from "./layouts/MainLayout";
import LoginPage from "./pages/loginPage/LoginPage";
import OrgsPage from "./pages/orgPage/OrgsPage";
import AssignmentsPage from "./pages/assignmentPage/AssignmentsPage";
import { UserProvider } from "./context/UserProvider";
import RepoDetailPage from "./pages/repoDetailPage/RepoDetailPage";
import { GitHubProvider } from "./context/GitHubProvider";
import ReposPage from "./pages/repoPage/ReposPage";
import SpecificUserSubmissionScreen from "./pages/SpecificUserSubmissionScreen";
import AnalyticsPage from './pages/analyticsPage/AnalyticsPage';

function App() {
  return (
    <GitHubProvider>
      <UserProvider>
        <Router>
          <Routes>
            <Route path="/" element={<MainLayout />}>
              <Route index element={<LoginPage />} />
              <Route path="/orgs" element={<OrgsPage />} />
              <Route
                path="/orgs/:orgName/assignments"
                element={<AssignmentsPage />}
              />
              <Route
                path="/orgs/:orgName/assignments/:assignmentName/repos"
                element={<ReposPage />}
              />
              <Route
                path="/orgs/:orgName/assignments/:assignmentName/repos/:repoId"
                element={<RepoDetailPage />}
              />
              <Route
                path="/orgs/:orgName/assignments/:assignmentName/submission"
                element={<SpecificUserSubmissionScreen />}
              />
              <Route 
                path="/orgs/:orgName/analytics"
                element={<AnalyticsPage />}
              />
              </Route>
          </Routes>
        </Router>
      </UserProvider>
    </GitHubProvider>
  );
}

export default App;
</file>

<file path="client/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="client/src/components/AssignmentList.tsx">
import { useEffect, useState } from "react";
import { fetchAssignments } from "../../../server/AssignmentsService";

const AssignmentList = () => {
  const [assignments, setAssignments] = useState<any[]>([]);

  useEffect(() => {
    const load = async () => {
      const data = await fetchAssignments();
      setAssignments(data);
    };
    load();
  }, []);

  return (
    <div>
      <h2>Assignments</h2>
      <ul>
        {assignments.map((a) => (
          <li key={a.id}>
            {a.title} (due: {a.due_date})
          </li>
        ))}
      </ul>
    </div>
  );
};

export default AssignmentList;
</file>

<file path="client/src/components/BackButton.tsx">
import { useNavigate } from "react-router-dom";
import { BiArrowBack } from "react-icons/bi";

type BackButtonProps = {
  to: string;
};

export default function BackButton({ to }: BackButtonProps) {
  const navigate = useNavigate();

  return (
    <button
      onClick={() => navigate(to)}
      className="flex items-center text-gray-600 round"
    >
      <BiArrowBack className="mr-2" size={20} />
    </button>
  );
}
</file>

<file path="client/src/components/BasicButton.tsx">
interface BasicButtonProps {
  text: string;
  onClick: () => void;
}

export default function BasicButton({ text, onClick }: BasicButtonProps) {
  return (
    <button
      onClick={onClick}
      className="flex items-center justify-center border border-[#D9D9D9] px-6 py-3 h-[40px] rounded-full w-[220px] gap-2 bg-[#1D1B20] hover:opacity-90 text-white"
    >
      <span className="text-xs sm:text-sm text-center">{text}</span>
    </button>
  );
}
</file>

<file path="client/src/components/BasicHeading.tsx">
interface BasicHeadingProps {
  heading?: string;
  styling?: string;
}

export default function BasicHeading({
  heading,
  styling = "",
}: BasicHeadingProps) {
  return <h1 className={`text-[29px] font-bold ${styling}`}>{heading}</h1>;
}
</file>

<file path="client/src/components/basicList/BasicList.tsx">
import { useNavigate } from "react-router-dom";
import ListHeader from "./ListHeader";
import ListItem from "./ListItem";
import type { StudentSubmissionInfo } from "../../types/StudentSubmissionInfo";
import type {
  AssignmentInfo,
  OrgInfo,
  RepoInfo,
} from "@shared/githubInterfaces";
import type { SortOption } from "src/utils/sortingUtils";

interface BasicListProps {
  type: "org" | "assignment" | "repo" | "submission";
  items: OrgInfo[] | AssignmentInfo[] | RepoInfo[] | StudentSubmissionInfo[];
  isLoading: boolean;
  orgName?: string;
  assignmentName?: string;
  sortOrder?: SortOption;
  onSortChange?: (option: SortOption) => void;
}

export default function BasicList(props: BasicListProps) {
  const navigate = useNavigate();
  const isEmpty = Array.isArray(props.items) && props.items.length === 0;

  return (
    <div className="flex flex-col">
      <ListHeader
        type={props.type}
        sortOrder={props.sortOrder}
        onSortChange={props.onSortChange}
      />

      {props.isLoading && <div className="text-gray-500 p-4">Loading...</div>}

      {!props.isLoading && isEmpty && (
        <div className="text-gray-500 p-4">No items found.</div>
      )}
      {!props.isLoading &&
        !isEmpty &&
        props.items.map((item, index) => {
          const key = `${props.type}-${index}`;

          switch (props.type) {
            case "org":
              return (
                <ListItem
                  key={key}
                  type="org"
                  data={item as OrgInfo}
                  onClick={() =>
                    navigate(`/orgs/${(item as OrgInfo).name}/assignments`)
                  }
                />
              );

            case "assignment":
              return (
                <ListItem
                  key={key}
                  type="assignment"
                  data={item as AssignmentInfo}
                  onClick={() =>
                    navigate(
                      `/orgs/${props.orgName}/assignments/${encodeURIComponent(
                        (item as AssignmentInfo).name
                      )}/repos`
                    )
                  }
                />
              );

            case "repo":
              return (
                <ListItem
                  key={key}
                  type="repo"
                  data={item as RepoInfo}
                  onClick={() =>
                    navigate(
                      `/orgs/${props.orgName}/assignments/${encodeURIComponent(
                        props.assignmentName!
                      )}/repos/${(item as RepoInfo).id}`,
                      { state: item }
                    )
                  }
                />
              );

            case "submission":
              return (
                <ListItem
                  key={key}
                  type="submission"
                  data={item as StudentSubmissionInfo}
                />
              );
          }
        })}
    </div>
  );
}
</file>

<file path="client/src/components/basicList/ListButton.tsx">
interface ListButtonProps {
  text: string;
}

export default function ListButton({ text }: ListButtonProps) {
  return (
    <button className="h-8 px-4 text-xs sm:text-sm bg-[#1D1B20] text-white rounded-full w-fit min-w-[100px]">
        {text}
    </button>
  )
}
</file>

<file path="client/src/components/basicList/ListHeader.tsx">
import type { SortOption } from "src/utils/sortingUtils";
import SortableHeader from "../../components/SortableHeader";

interface ListHeaderProps {
  type: "repo" | "submission" | "assignment" | "org";
  sortOrder?: SortOption;
  onSortChange?: (option: SortOption) => void;
}

export default function ListHeader({
  type,
  sortOrder,
  onSortChange,
}: ListHeaderProps) {
  if (type === "org") {
    return (
      <div className="grid grid-cols-[40px_1fr_1fr] h-[40px] bg-[#EADDFF] px-4 gap-2 items-center text-sm font-medium border rounded border-b border-l border-r border-[#D9D9D9]">
        <div />
        <SortableHeader
          label="Organization name"
          currentSort={sortOrder}
          ascValue="A–Z"
          descValue="Z–A"
          onChange={onSortChange}
        />
        <p className="text-left">Description</p>
      </div>
    );
  }

  if (type === "assignment") {
    return (
      <div className="grid grid-cols-[40px_1fr_1fr_1fr] h-[40px] bg-[#EADDFF] px-4 gap-2 items-center text-sm font-medium border rounded border-b border-l border-r border-[#D9D9D9]">
        <div />
        <SortableHeader
          label="Assignment name"
          currentSort={sortOrder}
          ascValue="A–Z"
          descValue="Z–A"
          onChange={onSortChange}
        />
        <SortableHeader
          label="Amount of Students"
          currentSort={sortOrder}
          ascValue="Amount of Students"
          descValue="Amount of Students (desc)"
          onChange={onSortChange}
          center
        />
        <SortableHeader
          label="Last updated"
          currentSort={sortOrder}
          ascValue="Oldest"
          descValue="Newest"
          onChange={onSortChange}
        />
      </div>
    );
  }

  if (type === "repo") {
    return (
      <div className="grid grid-cols-[40px_1fr_1fr_1fr] h-[40px] bg-[#EADDFF] px-4 gap-2 items-center text-sm font-medium border rounded border-b border-l border-r border-[#D9D9D9]">
        <div />
        <SortableHeader
          label="Repository name"
          currentSort={sortOrder}
          ascValue="A–Z"
          descValue="Z–A"
          onChange={onSortChange}
        />
        <p className="text-center">Students</p>
        <SortableHeader
          label="Last updated"
          currentSort={sortOrder}
          ascValue="Oldest"
          descValue="Newest"
          onChange={onSortChange}
        />
      </div>
    );
  }

  if (type === "submission") {
    return (
      <div className="grid grid-cols-[40px_1fr_1fr_1fr] h-[40px] bg-[#EADDFF] px-4 gap-2 items-center text-sm font-medium border rounded border-b border-l border-r border-[#D9D9D9]">
        <div />
        <p className="text-center">Student</p>
        <p className="text-center">Submission status</p>
        <p className="text-center">Grade</p>
      </div>
    );
  }
}
</file>

<file path="client/src/components/basicList/ListItem.tsx">
import type { StudentSubmissionInfo } from "../../types/StudentSubmissionInfo";
import type {
  AssignmentInfo,
  OrgInfo,
  RepoInfo,
} from "@shared/githubInterfaces";

type ListItemProps =
  | { type: "org"; data: OrgInfo; onClick?: () => void }
  | { type: "assignment"; data: AssignmentInfo; onClick?: () => void }
  | { type: "repo"; data: RepoInfo; onClick?: () => void }
  | { type: "submission"; data: StudentSubmissionInfo; onClick?: () => void };

export default function ListItem(props: ListItemProps) {
  const commonClass =
    "h-[56px] px-4 gap-2 items-center text-sm hover:bg-gray-100 cursor-pointer border rounded border-[#D9D9D9] overflow-y-auto max-h-[calc(100vh-240px)]";

  let content;
  let className = "";

  switch (props.type) {
    case "org": {
      const org = props.data;
      className = `grid grid-cols-[40px_1fr_1fr] ${commonClass}`;
      content = (
        <>
          <img
            src={org.avatarUrl}
            alt={org.name}
            className="w-6 h-6 rounded-full"
          />
          <p className="text-left">{org.name}</p>
          <p className="text-left">{org.description || "No description"}</p>
        </>
      );
      break;
    }

    case "assignment": {
      const assignment = props.data;
      const assignmentName = assignment.name;
      const amountOfStudents = assignment.amountOfStudents;
      const updatedAt = new Date(assignment.updatedAt).toLocaleString();
      className = `grid grid-cols-[40px_1fr_1fr_1fr] ${commonClass}`;
      content = (
        <>
          <div className="w-6 h-6 rounded-full" />
          <p className="text-left">{assignmentName}</p>
          <p className="text-center">{amountOfStudents}</p>
          <p className="text-left">{updatedAt}</p>
        </>
      );
      break;
    }

    case "repo": {
      const repo = props.data;
      const avatar = repo.collaborators[0]?.avatarUrl || "";
      const students = repo.collaborators[0].name;
      const updatedAt = new Date(repo.updatedAt).toLocaleString();
      className = `grid grid-cols-[40px_1fr_1fr_1fr] ${commonClass}`;
      content = (
        <>
          <img src={avatar} alt="repo" className="w-6 h-6 rounded-full" />
          <p className="text-left">{repo.name}</p>
          <p className="text-center">{students}</p>
          <p className="text-left">{updatedAt}</p>
        </>
      );
      break;
    }

    case "submission": {
      const submission = props.data;
      className = `grid grid-cols-[40px_1fr_1fr_1fr_auto] ${commonClass} text-xs sm:text-sm`;
      content = (
        <>
          <img
            src={submission.studentProfilePicture}
            alt="student"
            className="w-6 h-6 rounded-full"
          />
          <p className="text-center">{submission.studentName}</p>
          <p className="text-center">{submission.submissionStatus}</p>
          <p className="text-center">{submission.currentGrade}</p>
        </>
      );
      break;
    }
  }

  return (
    <div className={className} onClick={props.onClick}>
      {content}
    </div>
  );
}
</file>

<file path="client/src/components/BasicSearchBar.tsx">
import { BiSearch } from "react-icons/bi";
import { RxCross1 } from "react-icons/rx";

interface BasicSearchBarProps {
  value: string;
  onChange: (value: string) => void;
}

export default function BasicSearchBar({
  value,
  onChange,
}: BasicSearchBarProps) {
  return (
    <div className="w-[360px] h-[56px] border border-[#D9D9D9] rounded-full flex items-center px-4">
      <input
        type="text"
        placeholder="Search by repository name or class"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className="flex-grow bg-transparent outline-none text-gray-800 placeholder-gray-500"
      />
      {value ? (
        <button
          onClick={() => onChange("")}
          className="text-gray-500 hover:text-gray-700"
        >
          <RxCross1 size={18} />
        </button>
      ) : (
        <BiSearch className="text-gray-500" size={20} />
      )}
    </div>
  );
}
</file>

<file path="client/src/components/FeedbackViewer.tsx">
import { useEffect, useState } from "react";
import { fetchFeedback } from "../services/feedbackService";

const FeedbackViewer = ({ submissionId }: { submissionId: number }) => {
  const [feedback, setFeedback] = useState<any[]>([]);

  useEffect(() => {
    const load = async () => {
      const data = await fetchFeedback(submissionId);
      setFeedback(data);
    };
    load();
  }, [submissionId]);

  return (
    <div>
      <h3>Feedback</h3>
      {feedback.map((f) => (
        <div key={f.id}>
          <strong>Score:</strong> {f.score}/100
          <p>{f.comments}</p>
        </div>
      ))}
    </div>
  );
};

export default FeedbackViewer;
</file>

<file path="client/src/components/Footer.tsx">
export default function Footer() {
  return (
    <footer className="w-full h-[99px] py-4 border-t border-[#D9D9D9] text-center text-lg text-gray-500">
      Footer
    </footer>
  )
}
</file>

<file path="client/src/components/Header.tsx">
interface HeaderProps {
  loggedIn: boolean;
  onClick: () => void;
}

export default function Header({ onClick, loggedIn }: HeaderProps) {
  const text = loggedIn ? "Logout" : "Login";

  return (
    <header className="top-0 left-0 w-full h-[99px] border-b border-[#D9D9D9] px-8 py-8 flex items-center justify-between">
      <div className="flex-shrink-0">
        {/* the logo needs to be added or deleted fully if it's not needed */}
        <img src="/logo.svg" alt="Logo" className="h-full" />
      </div>
      <div className="flex items-center gap-6">
        <span className="text-lg text-[#1E1E1E]">Languages</span>
        <button
          onClick={onClick}
          className="bg-[#1D1B20] w-[148px] text-white text-lg px-4 py-2 rounded-full hover:opacity-90"
        >
          {text}
        </button>
      </div>
    </header>
  );
}
</file>

<file path="client/src/components/SortableHeader.tsx">
import type { SortOption } from "src/utils/sortingUtils";
import { IoIosArrowUp, IoIosArrowDown } from "react-icons/io";
import { FaMinus } from "react-icons/fa6";

export default function SortableHeader({
  label,
  currentSort,
  ascValue,
  descValue,
  onChange,
  center,
}: {
  label: string;
  currentSort: SortOption | undefined;
  ascValue: SortOption;
  descValue: SortOption;
  onChange?: (option: SortOption) => void;
  center?: boolean;
}) {
  const isAsc = currentSort === ascValue;
  const isDesc = currentSort === descValue;
  const isActive = isAsc || isDesc;

  return (
    <button
      onClick={() => {
        if (!onChange) return;
        onChange(isAsc ? descValue : ascValue);
      }}
      className={`flex items-center gap-1 ${center ? "justify-center" : ""}`}
    >
      {label}
      {isActive ? (
        isAsc ? (
          <IoIosArrowUp />
        ) : (
          <IoIosArrowDown />
        )
      ) : (
        <FaMinus className="text-gray-400" />
      )}
    </button>
  );
}
</file>

<file path="client/src/components/SortingButton.tsx">
import { useState } from "react";
import { BiSolidDownArrow } from "react-icons/bi";

interface FilterButtonProps {
  buttonText: string;
  items: string[];
  onSelect?: (value: string) => void;
}

export default function SortingButton({
  buttonText,
  items,
  onSelect,
}: FilterButtonProps) {
  const [isOpen, setIsOpen] = useState(false);
  const toggleDropdown = () => setIsOpen((prev) => !prev);

  const handleSelect = (item: string) => {
    onSelect?.(item);
    setIsOpen(false);
  };

  return (
    <div className="relative inline-block">
      <button
        onClick={toggleDropdown}
        className="flex items-center justify-between border border-[#D9D9D9] px-4 py-3 rounded-full w-fit min-w-[95px] gap-2 h-[56px]"
      >
        <span className="text-xs sm:text-sm text-[#1E1E1E]">{buttonText}</span>
        <BiSolidDownArrow
          className={`w-3 h-3 transition-transform duration-200 ${
            isOpen ? "" : "rotate-180"
          }`}
        />
      </button>
      {isOpen && (
        <ul className="absolute mt-2 w-full bg-white border border-[#D9D9D9] rounded-md shadow-md z-10">
          {items.map((item, index) => (
            <li
              key={index}
              className="px-4 py-2 hover:bg-gray-100 cursor-pointer text-sm text-[#1E1E1E]"
              onClick={() => handleSelect(item)}
            >
              {item}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
</file>

<file path="client/src/components/Spinner.tsx">
export default function Spinner() {
  return (
    <div className="flex items-center justify-center min-h-[200px]">
      <div className="h-8 w-8 animate-spin rounded-full border-4 border-gray-300 border-t-blue-500" />
    </div>
  );
}
</file>

<file path="client/src/components/Tabs.tsx">
import { useState } from "react";
import type { ReactNode } from "react";

export default function Tabs({
  tabs,
}: {
  tabs: { id: string; label: string; content: ReactNode }[];
}) {
  const [activeTab, setActiveTab] = useState(tabs[0].id);

  return (
    <div className="flex flex-col space-y-4">
      <div className="flex border-b border-gray-200">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id)}
            className={`px-4 py-2 text-sm font-medium ${
              activeTab === tab.id
                ? "border-b-2 border-blue-500 text-blue-600"
                : "text-gray-500 hover:text-gray-700"
            }`}
          >
            {tab.label}
          </button>
        ))}
      </div>
      <div>{tabs.find((tab) => tab.id === activeTab)?.content}</div>
    </div>
  );
}
</file>

<file path="client/src/context/GitHubContext.ts">
import { createContext } from "react";
import type { GitHubContextType } from "./types";

const GitHubContext = createContext<GitHubContextType | null>(null);
export default GitHubContext;
</file>

<file path="client/src/context/GitHubProvider.tsx">
import { useMemo } from "react";
import axios from "axios";
import GitHubContext from "./GitHubContext";
import type { GitHubContextType } from "./types";
import type {
  AssignmentInfo,
  OrgInfo,
  RepoInfo,
  CommitInfo,
  CompareCommitsInfo,
} from "@shared/githubInterfaces";

const baseUrl = import.meta.env.VITE_API_BASE_URL;

export const GitHubProvider = ({ children }: { children: React.ReactNode }) => {
  const getOrganizations = async (): Promise<OrgInfo[]> => {
    const res = await axios.get(`${baseUrl}/api/github/orgs`, {
      withCredentials: true,
    });
    return res.data;
  };

  const getAssignments = async (orgName: string): Promise<AssignmentInfo[]> => {
    const res = await axios.get(
      `${baseUrl}/api/github/orgs/${orgName}/assignments`,
      {
        withCredentials: true,
      }
    );
    return res.data;
  };

  const getRepos = async (
    orgName: string,
    assignmentName = ""
  ): Promise<RepoInfo[]> => {
    const res = await axios.get(
      `${baseUrl}/api/github/orgs/${orgName}/assignments/${assignmentName}/repos`,
      { withCredentials: true }
    );
    return res.data;
  };

  const getAllOrganizationData = async (org: string) => {
    const res = await axios.get(`${baseUrl}/api/github/org-report`, {
      withCredentials: true,
      params: { org },
    });
    return res.data;
  };

  const getCommits = async (
    orgName: string,
    repoName: string
  ): Promise<CommitInfo[]> => {
    const res = await axios.get(
      `${baseUrl}/api/github/repos/${orgName}/${repoName}/commits`,
      { withCredentials: true }
    );
    return res.data;
  };

  const getRepoTree = async (
    orgName: string,
    repoName: string
  ): Promise<string[]> => {
    const res = await axios.get(
      `${baseUrl}/api/github/repos/${orgName}/${repoName}/tree`,
      { withCredentials: true }
    );
    return res.data;
  };

  const getFileContents = async (
    orgName: string,
    repoName: string,
    path: string
  ): Promise<string | null> => {
    const res = await axios.get(
      `${baseUrl}/api/github/repos/${orgName}/${repoName}/contents`,
      {
        withCredentials: true,
        params: { path },
      }
    );
    return res.data;
  };

  const compareCommits = async (
    orgName: string,
    repoName: string,
    base: string,
    head: string
  ): Promise<CompareCommitsInfo> => {
    const res = await axios.get(
      `${baseUrl}/api/github/repos/${orgName}/${repoName}/compare/${base}/${head}`,
      { withCredentials: true }
    );
    return res.data;
  };

  const contextValue: GitHubContextType = useMemo(
    () => ({
      getOrganizations,
      getRepos,
      getAllOrganizationData,
      getAssignments,
      getCommits,
      getRepoTree,
      getFileContents,
      compareCommits,
    }),
    []
  );

  return (
    <GitHubContext.Provider value={contextValue}>
      {children}
    </GitHubContext.Provider>
  );
};
</file>

<file path="client/src/context/types.ts">
import type {
  OrgInfo,
  AssignmentInfo,
  RepoInfo,
  User,
  CommitInfo,
  CompareCommitsInfo,
} from "@shared/githubInterfaces";

export interface GitHubContextType {
  getOrganizations: () => Promise<OrgInfo[]>;
  getAssignments: (orgLogin: string) => Promise<AssignmentInfo[]>;
  getRepos: (org: string, assignmentPrefix?: string) => Promise<RepoInfo[]>;
  getAllOrganizationData: (org: string) => Promise<any>;
  getCommits: (orgName: string, repoName: string) => Promise<CommitInfo[]>;
  getRepoTree: (orgName: string, repoName: string) => Promise<string[]>;
  getFileContents: (
    orgName: string,
    repoName: string,
    path: string
  ) => Promise<string | null>;
  compareCommits: (
    orgName: string,
    repoName: string,
    base: string,
    head: string
  ) => Promise<CompareCommitsInfo>;
}

export interface UserContextType {
  user: User | null;
  isLogin: boolean;
  refreshUser: () => Promise<void>;
  logout: () => Promise<void>;
  login: () => string;
}
</file>

<file path="client/src/context/useGitHub.ts">
import { useContext } from "react";
import GitHubContext from "./GitHubContext";
import type { GitHubContextType } from "./types";

export const useGitHub = (): GitHubContextType => {
  const context = useContext(GitHubContext);

  if (!context) {
    throw new Error("useGitHub must be used within a GitHubProvider");
  }
  return context;
};
</file>

<file path="client/src/context/UserContext.ts">
// Declares the context object only
import { createContext } from "react";
import type { UserContextType } from "../types/UserInfo";

const UserContext = createContext<UserContextType | undefined>(undefined);
export default UserContext;
</file>

<file path="client/src/context/UserProvider.tsx">
// Provides state and logic (data + functions)
import { useEffect, useState, useMemo } from "react";
import axios from "axios";
import UserContext from "./UserContext";
import type { UserContextType } from "./types";
import type { User } from "@shared/githubInterfaces";

const baseUrl = import.meta.env.VITE_API_BASE_URL;

export const UserProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);

  const refreshUser = async () => {
    try {
      const res = await axios.get(`${baseUrl}/api/auth/getCurrentUser`, {
        withCredentials: true,
      });
      setUser(res.data.user || null);
    } catch {
      setUser(null);
    }
  };

  const login = () => {
    return `${baseUrl}/api/auth/login`;
  };

  const logout = async () => {
    await axios.get(`${baseUrl}/api/auth/logout`, { withCredentials: true });
    setUser(null);
  };

  useEffect(() => {
    refreshUser();
  }, []);

  const contextValue: UserContextType = useMemo(
    () => ({
      user,
      isLogin: !!user,
      refreshUser,
      logout,
      login,
    }),
    [user]
  );

  return (
    <UserContext.Provider value={contextValue}>{children}</UserContext.Provider>
  );
};
</file>

<file path="client/src/context/useUser.ts">
// Exports the custom hook for using the context
import { useContext } from "react";
import UserContext from "./UserContext";
import type { UserContextType } from "../types/UserInfo";

export const useUser = (): UserContextType => {
  const context = useContext(UserContext);

  if (!context) {
    throw new Error("useUser must be used within a UserProvider");
  }
  return context;
};
</file>

<file path="client/src/hooks/useFilteredList.ts">
import { useMemo } from "react";

export function useFilteredList<T>(
  list: T[] = [],
  searchTerm: string,
  predicate: (item: T, searchTerm: string) => boolean
): T[] {
  return useMemo(() => {
    return list.filter((item) => predicate(item, searchTerm));
  }, [list, searchTerm, predicate]);
}
</file>

<file path="client/src/index.css">
@import "tailwindcss";
</file>

<file path="client/src/layouts/MainLayout.tsx">
import { Outlet, useNavigate, useLocation } from "react-router-dom";
import { useEffect } from "react";
import Header from "../components/Header";
import Footer from "../components/Footer";
import { useUser } from "../context/useUser";

export default function MainLayout() {
  const { user, isLogin, refreshUser, logout, login } = useUser();

  const navigate = useNavigate();
  const location = useLocation();

  useEffect(() => {
    const checkAndRedirect = async () => {
      await refreshUser?.();
      if (user && location.pathname === "/") {
        navigate("/orgs");
      }
    };
    checkAndRedirect();
  }, [refreshUser, navigate, user, location.pathname]);

  const handleHeaderButtonClick = async () => {
    if (isLogin) {
      await logout?.();
      navigate("/");
    } else {
      const loginUrl = login?.();
      if (loginUrl) {
        window.location.href = loginUrl;
      }
    }
  };

  return (
    <div className="flex flex-col min-h-screen">
      <Header loggedIn={!!isLogin} onClick={handleHeaderButtonClick} />
      <main className="flex-1 flex justify-center items-start">
        <div className="w-full max-w-screen-xl">
          <Outlet />
        </div>
      </main>
      <Footer />
    </div>
  );
}
</file>

<file path="client/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="client/src/pages/analyticsPage/AnalyticsPage.tsx">
import { useParams } from "react-router-dom";
import { useEffect, useState } from "react";
import { useGitHub } from "../../context/useGitHub";
import type { OrgReport } from "src/types/OrgReport";
import BackButton from "../../components/BackButton";
import BasicHeading from "../../components/BasicHeading";
import GetCSVFileButton from "../assignmentPage/GetCSVFileButton";
import AveragePointsChart from "./averageAssignmentPointsTab/AveragePointsChart";
import TabNavigation from "./TabNavigation";
import MissingSubmissionsList from "./missingSubmissionsTab/MissingSubmissionsList";
import CommonIssuesChart from "./commonIssuesTab/CommonIssuesChart";
import Spinner from "../../components/Spinner";

// delete this later
const mockOrgData = {
  org: "Mock University",
  assignments: ["Assignment 1", "Assignment 2", "Assignment 3"],
  submissions: [
    {
      student: "astronautie",
      grades: {
        "Assignment 1": 20,
        "Assignment 2": 10,
        "Assignment 3": null,
      },
    },
    {
      student: "FuzzyKala",
      grades: {
        "Assignment 1": 18,
        "Assignment 2": null, 
        "Assignment 3": null,
      },
    },
    {
      student: "vima20",
      grades: {
        "Assignment 1": 20,
        "Assignment 2": 10,
        "Assignment 3": 30,
      },
    },
    {
      student: "nonRoster",
      grades: {
        "Assignment 1": null,
        "Assignment 2": 15,
        "Assignment 3": 25,
      },
    },
  ],
};

// TODO: get this from github with real values (preferably with the OrgData and not separately)
const maxPointsPerAssignment = {
  "Assignment 1": 20,
  "Assignment 2": 15,
  "Assignment 3": 30,
}

// TODO: get the real issues from the database(?)
const mockCommonIssues = [
  { student: "alice", issues: ["Poor naming", "No comments"] },
  { student: "FuzzyKala", issues: ["Repeated code", "No comments"] },
  { student: "vima20", issues: ["No comments"] },
  { student: "nonRoster", issues: ["Poor naming", "Repeated code"] },
  { student: "astronautie", issues: ["Bad"] },
];

export default function AnalyticsPage() {
  const { orgName } = useParams<{ orgName: string }>();
  const github = useGitHub();
  const [orgData, setOrgData] = useState<OrgReport | null>(null);
  const [loading, setLoading] = useState(true);
  const tabs = ["Average Assignment Points", "Common Issues", "Missing Submissions"];
  const [activeTab, setActiveTab] = useState(tabs[0]);

 useEffect(() => {
    const fetchOrgData = async () => {
      if (!orgName) return;
      try {
        const data = await github.getAllOrganizationData(orgName);
        setOrgData(data);
      } catch (error) {
        console.error("Failed to fetch org data:", error);
      } finally {
        setLoading(false);
      }
    };
    fetchOrgData();
  }, [orgName, github]);
  

  return (
    <div className="flex flex-col space-y-20 p-4 md:p-12"> 
      <div className="flex flex-col space-y-6">
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          <div className="flex space-x-4">
            <BackButton to={`/orgs/${orgName}/assignments`}/>
            <BasicHeading heading={`Analytics for ${orgName}`} /> 
          </div>
          <div className="flex flex-col md:flex-row gap-2">
            <GetCSVFileButton text="Get CSV Report" orgLogin={orgName}/>
          </div>
        </div>
      </div>
        <div className="m-8">
          {loading ? (
            <Spinner />
          ) : !orgData ? (
            <div className="p-4">No organization data found.</div>
          ) : (
            <>
              <TabNavigation tabs={tabs} activeTab={activeTab} setActiveTab={setActiveTab} />
              {activeTab === "Average Assignment Points" && (
                <AveragePointsChart orgData={mockOrgData} maxPointsPerAssignment={maxPointsPerAssignment} />
              )}
              {activeTab === "Common Issues" && (
                <CommonIssuesChart issues={mockCommonIssues} />
              )}
              {activeTab === "Missing Submissions" && (
                <MissingSubmissionsList orgData={mockOrgData} />
              )}
            </>
          )}
        </div>
    </div>
  );
}
</file>

<file path="client/src/pages/analyticsPage/averageAssignmentPointsTab/AveragePointsChart.tsx">
import { Bar } from 'react-chartjs-2';
import type { OrgReport } from 'src/types/OrgReport';
import { Chart as ChartJS, CategoryScale, LinearScale, BarElement, Tooltip, Title, Legend } from 'chart.js';

ChartJS.register(CategoryScale, LinearScale, BarElement, Tooltip, Title, Legend);

type AverageGradeChartProps = {
  orgData: OrgReport;
  maxPointsPerAssignment: { [assignmentName: string]: number };
};

export default function AveragePointsChart({ orgData, maxPointsPerAssignment }: AverageGradeChartProps) {
  const labels = orgData.assignments;

  const averages = orgData.assignments.map((assignment) => {
    const maxPoints = maxPointsPerAssignment[assignment];
    if (!maxPoints || maxPoints === 0) return 0;
    const percentages = orgData.submissions.map((s) => {
      const grade = s.grades[assignment];
      return typeof grade === 'number' ? (grade / maxPoints) * 100 : null;
    }).filter((g): g is number => g !== null);

    const average = percentages.length
      ? percentages.reduce((a, b) => a + b, 0) / percentages.length
      : 0;

    return average.toFixed(2);
  });

  const data = {
    labels,
    datasets: [
      {
        label: 'Average % of Points',
        data: averages,
        backgroundColor: 'rgba(75, 192, 192, 0.6)',
        borderRadius: 4,
      },
    ],
  };

  const options = {
    responsive: true,
    plugins: {
      legend: {
        display: false,
      },
      title: {
        display: true,
        text: 'Average Percentage of Points per Assignment',
      },
    },
    scales: {
      y: {
        beginAtZero: true,
        max: 100, 
        ticks: {
          callback: (value: number | string ) => `${value}%`,
        },
      },
    },
  };

  return (<Bar data={data} options={options} />)
}
</file>

<file path="client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesChart.tsx">
import { Bar } from 'react-chartjs-2';

type CommonIssuesChartProps = {
  issues: {
    student: string;
    issues: string[];
  }[];
};

export default function CommonIssuesChart({ issues }: CommonIssuesChartProps) {
  const allIssues: string[] = issues.flatMap((entry) => entry.issues);

  const issueCounts = allIssues.reduce<Record<string, number>>((acc, issue) => {
    acc[issue] = (acc[issue] || 0) + 1;
    return acc;
  }, {});

  const labels = Object.keys(issueCounts);
  const dataValues = Object.values(issueCounts);

  const data = {
    labels,
    datasets: [
      {
        label: 'Number of Students',
        data: dataValues,
        backgroundColor: 'rgba(255, 99, 132, 0.6)',
        borderRadius: 4,
      },
    ],
  };

  const options = {
    responsive: true,
    plugins: {
      legend: { display: false },
      title: { display: true, text: 'Common Issues Across Submissions' },
    },
    scales: {
      y: {
        beginAtZero: true,
        title: {
          display: true,
          text: 'Number of Occurences',
        },
        ticks: {
          stepSize: 1,
        },
      },
    },
  };

  return <Bar data={data} options={options} />;
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/MissingSubmissionsList.tsx">
import { useEffect, useState } from "react";
import UploadStudentRosterCSVButton from "./UploadStudentRosterCSVButton";
import Subtext from "./Subtext";
import StudentTable from "./StudentTable";
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";
import type { OrgReport } from "src/types/OrgReport";
import { useParams } from "react-router-dom";

type MissingSubmissionsListProps = {
  orgData: OrgReport;
};

// TODO: get already existing roster from db if it exists there once we have access to the db
export default function MissingSubmissionsList({ orgData }: MissingSubmissionsListProps) {
  const [roster, setRoster] = useState<StudentInStudentRoster[]>([]);
  const { orgName } = useParams<{ orgName: string }>();
  
  useEffect(() => {
    const fetchRoster = async () => {
      if (!orgName) return;
      try {
        // TODO: get the roster from the database
        const fetchedRoster = "" // await db.getStudentRoster(orgName); 
        setRoster(fetchedRoster || []);
      } catch (error) {
        console.error("Failed to fetch student roster:", error);
      }
    };

    fetchRoster();
  }, [orgName]);

  return (
    <div>
      {roster.length === 0 ? (
        <div className="flex flex-col gap-y-6 items-center">
            <Subtext text={`Note: GitHub’s API does not currently support fetching student rosters. To view missing submissions, please upload a roster manually. This tool expects student identifiers within a roster to match the beginning of students' email addresses. You can download your class roster from GitHub Classroom under the "Students" section.`} />
            <UploadStudentRosterCSVButton text="Upload Student Roster CSV" onUpload={setRoster}/>
        </div>
      ) : (
        <div className="flex flex-col gap-y-2">
          <div className="flex justify-between items-center">
            <Subtext text="Student Submissions"/>
            <UploadStudentRosterCSVButton text="Update Student Roster CSV" onUpload={setRoster}/>
          </div>
          {roster.length > 0 && (
            <StudentTable roster={roster} orgData={orgData} />
          )}
        </div>
      )}
    </div>
  )
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/StudentTable.tsx">
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";
import type { OrgReport } from "src/types/OrgReport";

type StudentTableProps = {
  roster: StudentInStudentRoster[]; 
  orgData: OrgReport;
};

// TODO: change whether students are shown based on the "Identifier" or the github username or the student's name based on theacher's opinion
export default function StudentTable({ roster, orgData }: StudentTableProps) {
  const submissions = orgData.submissions; 
  const submissionMap = new Map(submissions.map(s => [s.student, s]));
  const assignmentNames = orgData.assignments;

  const studentsInRoster = roster.map((student) => {
    const submission = submissionMap.get(student.github_username);
    const grades = assignmentNames.map((assignment) => {
      const value = submission?.grades?.[assignment];
      if (value === null || value === undefined) return "N/A";
      if (typeof value === "number") return value;
      return "Error";
    });

    const numericGrades = grades.filter(g => typeof g === "number") as number[];
    const totalPoints = numericGrades.length > 0 ? numericGrades.reduce((a, b) => a + b, 0) : "—";
    const submissionCount = numericGrades.length;

    return {
      ...student,
      grades,
      totalPoints,
      submissionCount,
    };
  });

  const sortedStudents = [...studentsInRoster].sort(
   (a, b) => a.submissionCount - b.submissionCount
  );

  return (
    <table className="table-auto border rounded bg-white w-full text-sm text-left mt-4">
      <thead>
        <tr>
          <th className="border px-4 py-2 font-medium">Name</th>
          <th className="border px-4 py-2 font-medium">GitHub Username</th>
          <th className="border px-4 py-2 font-medium">Roster Identifier</th>
          {assignmentNames.map((assignment) => (
            <th key={assignment} className="border px-4 py-2 font-medium">
              {assignment}
            </th>
          ))}
          <th className="border px-4 py-2 font-medium">Total Points</th>
        </tr>
      </thead>
      <tbody>
        {sortedStudents.map((student) => (
          <tr key={student.identifier} 
              className={
                student.submissionCount === 0 ? "bg-red-100" 
                : student.submissionCount < assignmentNames.length ? "bg-yellow-100" 
                : "bg-green-100"
              }>
            <td className="border px-4 py-2">{student.name?.trim() || "—"}</td>
            <td className="border px-4 py-2">{student.github_username?.trim() || "—"}</td>
            <td className="border px-4 py-2">{student.identifier}</td>
            {student.grades.map((grade, idx) => (
              <td key={idx} className="border px-4 py-2 text-center">
                {grade}
              </td>
            ))}
            <td className="border px-4 py-2 text-center">{student.totalPoints}</td>
          </tr>
        ))}
    </tbody>
   </table>
  );
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/Subtext.tsx">
interface SubtextProps {
  text: string;
}

export default function Subtext({ text }: SubtextProps) {
  return (
    <div>
        <p className="text-[16px]">{text}</p>
    </div>
  )
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/UploadStudentRosterCSVButton.tsx">
import { useRef } from "react";
import Papa from "papaparse";
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";
import { useParams } from "react-router-dom";

type UploadStudentRosterCSVButtonProps = {
  text: string,
  onUpload: (students: StudentInStudentRoster[]) => void;
};

// TODO: once we have access to database, save (or update if a new roster is provided) uploaded roster for specific organization there
export default function UploadStudentRosterCSVButton({ text, onUpload }: UploadStudentRosterCSVButtonProps) {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { orgName } = useParams<{ orgName: string }>();

  const handleClick = () => {
    fileInputRef.current?.click();
  };

  const saveRosterToDB = async (roster: StudentInStudentRoster[]) => {
    if (!orgName) return;
    try {
      const response = await fetch(`/api/orgs/${orgName}/roster`, {
        method: "POST", // in backend if a roster already exists for the specific org, update it instead of posting it (use same backend function for both though)
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ roster }),
      });

      if (!response.ok) {
        throw new Error(`Failed to save roster: ${response.statusText}`);
      }
    } catch (error) {
      console.error("Error saving roster to DB:", error);
    }
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    Papa.parse<StudentInStudentRoster>(file, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => {
        const validStudents = results.data.filter((s) => s.identifier);
        onUpload(validStudents);
        (async () => {await saveRosterToDB(validStudents);})();
      },
      error: (err) => {
        console.error("CSV parsing error:", err);
      },
    });
    event.target.value = "";
  };

  return (
    <div>
      <button onClick={handleClick} className="flex items-center justify-between border border-[#D9D9D9] px-6 py-3 h-[40px] rounded-full w-fit min-w-[95px] gap-2 bg-[#1D1B20] hover:opacity-90 text-white">
        {text}
      </button>
      <input
        ref={fileInputRef}
        type="file"
        accept=".csv"
        onChange={handleFileChange}
        className="hidden"
      />
    </div>
  )
}
</file>

<file path="client/src/pages/analyticsPage/TabNavigation.tsx">
type TabNavigationProps = {
  tabs: string[];
  activeTab: string;
  setActiveTab: (tab: string) => void;
};

export default function TabNavigation({ tabs, activeTab, setActiveTab }: TabNavigationProps) {
  return (
    <div className="flex justify-center border-b mb-8 w-fit mx-auto">
      {tabs.map((tab) => (
        <button
          key={tab}
          onClick={() => setActiveTab(tab)}
          className={`py-2 px-4 font-semibold border-b-2 transition-all duration-200 ${
            activeTab === tab
              ? "border-black text-black"
              : "border-transparent text-gray-500 hover:text-gray-700"
          }`}>
          {tab}
        </button>
      ))}
    </div>
  )
}
</file>

<file path="client/src/pages/assignmentPage/AssignmentsPage.tsx">
import BasicHeading from "../../components/BasicHeading";
import BasicList from "../../components/basicList/BasicList";
// import SortingButton from "../../components/SortingButton";
import BasicSearchBar from "../../components/BasicSearchBar";
import { useEffect, useState } from "react";
import { useGitHub } from "../../context/useGitHub";
import { useParams, useNavigate } from "react-router-dom";
import type { AssignmentInfo } from "@shared/githubInterfaces";
import { useFilteredList } from "../../hooks/useFilteredList";
import BackButton from "../../components/BackButton";
import GetCSVFileButton from "./GetCSVFileButton";
import BasicButton from "../../components/BasicButton";
import { sortData } from "../../utils/sortingUtils";
import type { SortOption } from "../../utils/sortingUtils";
import Spinner from "../../components/Spinner";

export default function AssignmentsPage() {
  const { orgName } = useParams<{ orgName: string }>();
  const [assignments, setAssignments] = useState<AssignmentInfo[]>([]);
  const github = useGitHub();
  const navigate = useNavigate();
  const [searchTerm, setSearchTerm] = useState("");
  const [loading, setLoading] = useState(true);
  const [sortOrder, setSortOrder] = useState<SortOption>("Newest");

  const filteredAssignments = useFilteredList(
    assignments,
    searchTerm,
    (a, term) => a.name.toLowerCase().includes(term.toLowerCase())
  );

  const handleAnalyticsClick = () => {
    if (orgName) {
      navigate(`/orgs/${orgName}/analytics`);
    }
  };

  const sortedAssignments = sortData(filteredAssignments, sortOrder);

  useEffect(() => {
    if (orgName) {
      github
        .getAssignments(orgName)
        .then(setAssignments)
        .catch(console.error)
        .finally(() => setLoading(false));
    }
  }, [orgName, github]);

  console.log("assignments:", assignments);
  return (
    <div className="flex flex-col space-y-10 p-4 md:p-12">
      <div className="flex flex-col space-y-6">
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          <div className="flex space-x-4">
            <BackButton to="/orgs" />
            <BasicHeading heading={`Assignments in ${orgName}`} />
          </div>
          <div className="flex space-x-4">
            <BasicSearchBar value={searchTerm} onChange={setSearchTerm} />
          </div>
        </div>

        <div className="flex flex-col md:flex-row md:items-center md:justify-end gap-4">
          <BasicButton text="Go To Analytics Page" onClick={handleAnalyticsClick}/>
          <GetCSVFileButton text="Get CSV Report" orgLogin={orgName} />
        </div>
      </div>

      {loading ? (
        <Spinner />
      ) : (
        <BasicList
          type="assignment"
          items={sortedAssignments}
          orgName={orgName!}
          isLoading={loading}
          sortOrder={sortOrder}
          onSortChange={setSortOrder}
        />
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/assignmentPage/GetCSVFileButton.tsx">
import { generateCSVFromOrg } from "../../utils/generateCSVFromOrg";
import { useGitHub } from "../../context/useGitHub";
import UserContext from "../../context/UserContext"
import { useContext } from "react";
interface GetCSVFileButtonProps {
  text: string;
  orgLogin: string | undefined;
}

export default function GetCSVFileButton({ text, orgLogin }: GetCSVFileButtonProps) {
  const github = useGitHub();
  const { user } = useContext(UserContext);
const username = user?.username || "unknownuser";



  const handleClick = async () => {
   if (!orgLogin) return;
   
    


    try {
      const data = await github.getAllOrganizationData(orgLogin);
      
     
      generateCSVFromOrg(data);

      

      const response = await fetch("http://localhost:5000/api/csv-reports", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ rows: data,
           username: username }), 
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.error || "Tallennus epäonnistui");
      }

      console.log("✅ Data tallennettu Supabaseen");
    } catch (error) {
      console.error("🚫 Virhe tallennuksessa:", error);
    }
  };

  return (
    <button
      onClick={handleClick}
      className="flex items-center justify-between border border-[#D9D9D9] px-6 py-3 h-[40px] rounded-full w-fit min-w-[95px] gap-2 bg-[#1D1B20] hover:opacity-90 text-white"
    >
      <span className="text-xs sm:text-sm">{text}</span>
    </button>
  );
}
</file>

<file path="client/src/pages/loginPage/LoginButton.tsx">
import { FaGithub } from 'react-icons/fa';

interface LoginButtonProps {
  onClick: () => void;
}

export default function LoginButton({ onClick }: LoginButtonProps) {
  return (
    <button onClick={onClick} className="flex items-center bg-[#1D1B20] gap-3 px-16 py-5 hover:opacity-90 text-white text-lg rounded-full">
      <FaGithub className="w-6 h-6" />
      <span>Sign In With GitHub</span>
    </button> 
  )
}
</file>

<file path="client/src/pages/loginPage/LoginPage.tsx">
import BasicHeading from "../../components/BasicHeading";
import { useEffect } from "react";
import LoginButton from "./LoginButton";
import { useNavigate } from "react-router-dom";
import { useUser } from "../../context/useUser";

export default function LoginPage() {
  const { isLogin, login } = useUser();
  const navigate = useNavigate();

  useEffect(() => {
    if (isLogin) navigate("/orgs");
  }, [isLogin, navigate]);

  const handleLogin = () => {
    const loginUrl = login?.();
    if (loginUrl) {
      window.location.href = loginUrl;
    }
  };

  return (
    <div className="flex flex-col gap-20">
      <div className="flex flex-col items-center gap-2 px-4">
        <BasicHeading
          styling="text-center"
          heading="Login to GitHub Classroom Analyzer"
        />
        <p className="text-[20px] text-center">
          Sign in with GitHub to access your classroom repositories and analyze
          student submissions.
        </p>
      </div>
      <div className="flex flex-col items-center gap-10 px-4">
        <LoginButton onClick={handleLogin} />
        <p className="text-[16px] text-center">
          Only GitHub Classroom instructors can access this tool.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/orgPage/OrgsPage.tsx">
import { useEffect, useState } from "react";
import { useGitHub } from "../../context/useGitHub";
import type { OrgInfo } from "@shared/githubInterfaces";
import BasicHeading from "../../components/BasicHeading";
import BasicList from "../../components/basicList/BasicList";
import BasicSearchBar from "../../components/BasicSearchBar";
import { useFilteredList } from "../../hooks/useFilteredList";
import type { SortOption } from "../../utils/sortingUtils";
import { sortData } from "../../utils/sortingUtils";
import Spinner from "../../components/Spinner";

export default function OrgsPage() {
  const [orgs, setOrgs] = useState<OrgInfo[]>([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [loading, setLoading] = useState(true);
  const github = useGitHub();
  const [sortOrder, setSortOrder] = useState<SortOption>("A–Z");

  useEffect(() => {
    github
      .getOrganizations()
      .then(setOrgs)
      .catch(console.error)
      .finally(() => setLoading(false));
  }, [github]);

  const filteredOrgs = useFilteredList(orgs, searchTerm, (org, term) =>
    org.name.toLowerCase().includes(term.toLowerCase())
  );
  const sortedOrgs = sortData(filteredOrgs, sortOrder);
  console.log("orgs:", orgs);

  return (
    <div className="flex flex-col space-y-10 p-4 md:p-12">
      <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        <BasicHeading heading="Your Organizations" />
        <BasicSearchBar value={searchTerm} onChange={setSearchTerm} />
      </div>

      {loading ? (
        <Spinner />
      ) : (
        <BasicList
          type="org"
          items={sortedOrgs}
          isLoading={false}
          sortOrder={sortOrder}
          onSortChange={setSortOrder}
        />
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/CodeTab.tsx">
import Spinner from "../../components/Spinner";
import FileTree from "./FileTree";
import type { FileNode } from "./FileTree";
import { parseFileTree } from "../../utils/parseFileTree";

interface CodeTabProps {
  files: string[];
  selectedFile: string | null;
  content: string | null;
  loading?: boolean;
  onSelectFile: (file: string) => void;
}

export default function CodeTab({
  files,
  selectedFile,
  content,
  loading = false,
  onSelectFile,
}: CodeTabProps) {
  if (!files.length) return <Spinner />;
  const fileTree: FileNode[] = parseFileTree(files);

  return (
    <div className="flex">
      <div className="w-1/3 border-r p-4">
        <h3 className="font-semibold mb-2">Files</h3>
        <div className="bg-gray-100 rounded overflow-auto max-h-96">
          <FileTree
            nodes={fileTree}
            selectedPath={selectedFile}
            onSelect={onSelectFile}
          />
        </div>
      </div>
      <div className="w-2/3 p-4">
        <h3 className="font-semibold mb-2">Code</h3>
        {selectedFile ? (
          loading ? (
            <Spinner />
          ) : content ? (
            <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96">
              <code>{content}</code>
            </pre>
          ) : (
            <div className="text-red-500">Failed to load file content</div>
          )
        ) : (
          <div className="text-gray-500">Select a file to view</div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/CommitsTab.tsx">
import type { CommitInfo } from "@shared/githubInterfaces";
import Spinner from "../../components/Spinner";

interface CommitsTabProps {
  commits: CommitInfo[];
}

export default function CommitsTab({ commits }: CommitsTabProps) {
  if (!commits.length) return <Spinner />;

  return (
    <div className="space-y-2 overflow-auto max-h-96">
      {commits.map((commit) => (
        <div key={commit.sha} className="p-4 border rounded">
          <div className="flex items-center justify-between">
            <div className="w-11/12 font-medium">{commit.commit.message}</div>
            <div className="w-1/12 text-sm text-gray-500">
              {new Date(commit.commit.author.date).toLocaleString()}
            </div>
          </div>
          <div className="text-sm text-gray-600 pt-2">
            {commit.commit.author.name}
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/DiffTab.tsx">
import { useEffect, useState } from "react";
import { useGitHub } from "../../context/useGitHub";
import type {
  RepoInfo,
  CompareCommitsInfo,
  CommitInfo,
} from "@shared/githubInterfaces";
import Spinner from "../../components/Spinner";

interface DiffTabProps {
  repo: RepoInfo;
}

interface FileDiff {
  filename: string;
  status: string;
  patch?: string;
}

export default function DiffTab({ repo }: DiffTabProps) {
  const github = useGitHub();
  const [diff, setDiff] = useState<FileDiff[] | null>(null);

  useEffect(() => {
    if (repo) {
      // Compare last two commits
      github
        ?.getCommits(repo.owner, repo.name)
        .then((commits: CommitInfo[]) => {
          if (commits.length > 1) {
            return github?.compareCommits(
              repo.owner,
              repo.name,
              commits[1].sha,
              commits[0].sha
            );
          }
          return null;
        })
        .then((comparison: CompareCommitsInfo | null) => {
          setDiff(comparison?.files || null);
        });
    }
  }, [repo, github]);

  return (
    <div className="p-4">
      {diff ? (
        <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96">
          {diff.map((file: FileDiff) => (
            <div key={file.filename} className="mb-4">
              <div className="font-mono text-sm">
                {file.filename} ({file.status})
              </div>
              {file.patch && (
                <div className="bg-white p-2 rounded">
                  <code>{file.patch}</code>
                </div>
              )}
            </div>
          ))}
        </pre>
      ) : (
        <Spinner />
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FeedbackActions.tsx">
import BasicButton from "../../components/BasicButton";

interface Props {
  isEditing: boolean;
  onEditToggle: () => void;
  onDownload: () => void;
}

export default function FeedbackActions({
  isEditing,
  onEditToggle,
  onDownload,
}: Props) {
  return (
    <div className="flex justify-end space-x-2">
      <BasicButton onClick={onDownload} text="Download Feedback PDF" />
      <BasicButton
        onClick={onEditToggle}
        text={isEditing ? "Save Changes" : "Edit Feedback & Grade"}
      />
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FeedbackCard.tsx">
import { useState } from "react";
import type { AssignmentFeedback } from "@shared/aiInterfaces";
import FileFeedbackSection from "./FileFeedbackSection";
import { TbTriangleFilled } from "react-icons/tb";

interface FeedbackCardProps {
  isEditing: boolean;
  feedbackData: AssignmentFeedback;
  onFeedbackChange: (newText: string) => void;
  onGradeChange: (newGrade: string) => void;
}

export default function FeedbackCard({
  isEditing,
  feedbackData,
  onFeedbackChange,
  onGradeChange,
}: FeedbackCardProps) {
  const [expanded, setExpanded] = useState(true);
  const [fileExpanded, setFileExpanded] = useState<Record<string, boolean>>({});

  const toggleFile = (fileName: string) => {
    setFileExpanded((prev) => ({
      ...prev,
      [fileName]: !prev[fileName],
    }));
  };

  const totalIssues = feedbackData.feedbackByFile.reduce(
    (acc, file) => acc + file.issues.length,
    0
  );

  return (
    <div className="flex flex-col space-y-2 p-4 border rounded-md">
      <h2 className="text-lg font-semibold text-center">AI Feedback</h2>

      {/* Grade */}
      <div className="flex items-center space-x-4">
        <label className="font-semibold">Grade:</label>
        {isEditing ? (
          <select
            className="border rounded px-2 py-1"
            value={feedbackData.grade}
            onChange={(e) => onGradeChange(e.target.value)}
          >
            {["5", "4", "3", "2", "1"].map((val) => (
              <option key={val} value={val}>
                {val}
              </option>
            ))}
          </select>
        ) : (
          <span>{feedbackData.grade}</span>
        )}
      </div>

      {/* Overall Feedback */}
      <div>
        <label className="font-semibold">Overall Feedback:</label>
        {isEditing ? (
          <textarea
            className="w-full p-2 border rounded mt-1 resize-y min-h-[100px]"
            value={feedbackData.feedback}
            onChange={(e) => onFeedbackChange(e.target.value)}
          />
        ) : (
          <p className="text-sm whitespace-pre-wrap mt-1">
            {feedbackData.feedback}
          </p>
        )}
      </div>

      {/* Collapsible Issues Section */}
      <div className="mt-2 space-y-4">
        <button
          onClick={() => setExpanded((prev) => !prev)}
          className="flex items-center space-x-2 font-semibold focus:outline-none"
        >
          <span
            className={`transform transition-transform duration-200 ${
              expanded ? "rotate-180" : "rotate-90"
            }`}
          >
            <TbTriangleFilled />
          </span>
          <span>Issues ({totalIssues})</span>
        </button>

        {expanded && (
          <div className="max-h-[300px] overflow-y-auto space-y-2 pr-1">
            {feedbackData.feedbackByFile.map((file) => (
              <FileFeedbackSection
                key={file.fileName}
                fileName={file.fileName}
                issues={file.issues}
                expanded={!!fileExpanded[file.fileName]}
                onToggle={() => toggleFile(file.fileName)}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FeedbackTab.tsx">
import Spinner from "../../components/Spinner";
import FeedbackCard from "./FeedbackCard";
import FeedbackActions from "./FeedbackActions";
import type { AssignmentFeedback } from "@shared/aiInterfaces";

interface FeedbackTabProps {
  isEditing: boolean;
  feedbackData: AssignmentFeedback;
  onFeedbackChange: (newText: string) => void;
  onGradeChange: (newGrade: string) => void;
  onToggleEdit: () => void;
  onDownload: () => void;
}

export default function FeedbackTab({
  isEditing,
  feedbackData,
  onFeedbackChange,
  onGradeChange,
  onToggleEdit,
  onDownload,
}: FeedbackTabProps) {
  if (!feedbackData) return <Spinner />;

  return (
    <div className="flex flex-col space-y-6">
      <div className="flex-col space-y-4">
        <FeedbackActions
          isEditing={isEditing}
          onEditToggle={onToggleEdit}
          onDownload={onDownload}
        />
      </div>
      <FeedbackCard
        isEditing={isEditing}
        feedbackData={feedbackData}
        onFeedbackChange={onFeedbackChange}
        onGradeChange={onGradeChange}
      />
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FileFeedbackSection.tsx">
interface Props {
  fileName: string;
  issues: { id: number; line?: number; text: string }[];
  expanded: boolean;
  onToggle: () => void;
}

export default function FileFeedbackSection({
  fileName,
  issues,
  expanded,
  onToggle,
}: Props) {
  return (
    <div className="border p-2 rounded">
      <button
        onClick={onToggle}
        className="flex items-center space-x-2 font-medium w-full text-left"
      >
        <span
          className={`transform transition-transform ${
            expanded ? "rotate-90" : ""
          }`}
        >
          ▶
        </span>
        <span>
          {fileName} ({issues.length} issues)
        </span>
      </button>
      {expanded && (
        <ul className="list-disc list-inside mt-2">
          {issues.map((issue) => (
            <li key={issue.id} className="text-sm">
              {issue.line ? `Line ${issue.line}: ` : ""}
              {issue.text}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FileTree.tsx">
import { useState } from "react";
import { TbTriangleFilled } from "react-icons/tb";

export interface FileNode {
  name: string;
  path: string;
  isDirectory: boolean;
  children?: FileNode[];
}

interface FileTreeProps {
  nodes: FileNode[];
  selectedPath: string | null;
  onSelect: (path: string) => void;
}

export default function FileTree({
  nodes,
  selectedPath,
  onSelect,
}: FileTreeProps) {
  return (
    <div>
      {nodes.map((node) => (
        <TreeNode
          key={node.path}
          node={node}
          selectedPath={selectedPath}
          onSelect={onSelect}
        />
      ))}
    </div>
  );
}

function TreeNode({
  node,
  selectedPath,
  onSelect,
}: {
  node: FileNode;
  selectedPath: string | null;
  onSelect: (path: string) => void;
}) {
  const [open, setOpen] = useState(false);
  const isSelected = selectedPath === node.path;

  const handleClick = () => {
    if (node.isDirectory) setOpen((prev) => !prev);
    else onSelect(node.path);
  };

  return (
    <div className="ml-2">
      <div
        className={`flex items-center cursor-pointer p-1 rounded hover:bg-gray-100 ${
          isSelected ? "bg-blue-50" : ""
        }`}
        onClick={handleClick}
      >
        {node.isDirectory ? (
          <TbTriangleFilled
            size={16}
            className={`transform transition-transform duration-200 ${
              open ? "rotate-180" : "rotate-90"
            }`}
          />
        ) : (
          <span className="w-4" />
        )}
        <span className="ml-1">{node.name}</span>
      </div>
      {open && node.children && (
        <div className="ml-4">
          {node.children.map((child) => (
            <TreeNode
              key={child.path}
              node={child}
              selectedPath={selectedPath}
              onSelect={onSelect}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/MetadataTab.tsx">
import type { RepoInfo } from "@shared/githubInterfaces";
import Spinner from "../../components/Spinner";

interface MetadataTabProps {
  repo: RepoInfo;
}

export default function MetadataTab({ repo }: MetadataTabProps) {
  if (!repo) return <Spinner />;
  return (
    <div className="grid grid-cols-2 gap-4 p-4">
      <div className="bg-gray-100 rounded p-2">
        <h3 className="font-semibold mb-2">Repository Info</h3>
        <dl className="space-y-2">
          <div>
            <dt className="text-gray-600">Created</dt>
            <dd>{new Date(repo.createdAt).toLocaleString()}</dd>
          </div>
          <div>
            <dt className="text-gray-600">Last Updated</dt>
            <dd>{new Date(repo.updatedAt).toLocaleString()}</dd>
          </div>
        </dl>
      </div>
      <div className="bg-gray-100 rounded p-2">
        <h3 className="font-semibold mb-2">Collaborators</h3>
        <div className="space-y-2">
          {repo.collaborators.map((collaborator) => (
            <div key={collaborator.id} className="flex items-center space-x-2">
              <img
                src={collaborator.avatarUrl}
                className="w-6 h-6 rounded-full"
                alt={collaborator.name}
              />
              <span>{collaborator.name}</span>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/RepoDetailPage.tsx">
import { useParams, useLocation } from "react-router-dom";
import { useEffect, useState, useMemo } from "react";
import type { RepoInfo, CommitInfo } from "@shared/githubInterfaces";
import BackButton from "../../components/BackButton";
import BasicHeading from "../../components/BasicHeading";
import { useGitHub } from "../../context/useGitHub";
import Tabs from "../../components/Tabs";
import CodeTab from "./CodeTab";
import CommitsTab from "./CommitsTab";
import MetadataTab from "./MetadataTab";
import DiffTab from "./DiffTab";
import FeedbackTab from "./FeedbackTab";
import Spinner from "../../components/Spinner";

import { getInitialFeedback } from "../../utils/feedbackUtils";

import type { AssignmentFeedback } from "@shared/aiInterfaces";

export default function RepoDetailPage() {
  const location = useLocation();
  const repoFromState = location.state as RepoInfo | undefined;
  const { orgName, assignmentName, repoName } = useParams();
  const github = useGitHub();

  const [repo, setRepo] = useState<RepoInfo | null>(repoFromState ?? null);
  const [loading, setLoading] = useState(true);
  const [isEditing, setIsEditing] = useState(false);

  const [files, setFiles] = useState<string[]>([]);
  const [selectedFile, setSelectedFile] = useState<string | null>(null);
  const [fileContent, setFileContent] = useState<string | null>(null);
  const [fileLoading, setFileLoading] = useState(false);
  const [commits, setCommits] = useState<CommitInfo[]>([]);

  const [feedbackData, setFeedbackData] =
    useState<AssignmentFeedback>(getInitialFeedback);

  const handleClick = (action: string) => {
    if (action === "Edit Feedback") {
      setIsEditing((prev) => !prev);
    } else {
      console.log(`Clicked ${action}`);
    }
  };

  const handleFeedbackTextChange = (newText: string) => {
    setFeedbackData((prev) => ({ ...prev, feedback: newText }));
  };

  useEffect(() => {
    if (!repoFromState && github && orgName && assignmentName && repoName) {
      setLoading(true);
      github
        .getRepos(orgName, assignmentName)
        .then((repos) => {
          const found = repos.find((r) => r.name === repoName);
          setRepo(found || null);
        })
        .finally(() => setLoading(false));
    } else {
      setLoading(false);
    }
  }, [orgName, assignmentName, repoName, github, repoFromState]);

  // Fetch initial data
  useEffect(() => {
    if (repo) {
      // Load commits
      github?.getCommits(repo.owner, repo.name).then(setCommits);

      // Load file tree
      github?.getRepoTree(repo.owner, repo.name).then(setFiles);
    }
  }, [repo, github]);

  useEffect(() => {
    if (!selectedFile || !repo || !github) return;

    setFileLoading(true);
    setFileContent(null);

    github
      .getFileContents(repo.owner, repo.name, selectedFile)
      .then((content) => {
        setFileContent(content);
      })
      .catch((error) => {
        console.error("Error fetching file content:", error);
        setFileContent("Error loading file content");
      })
      .finally(() => {
        setFileLoading(false);
      });
  }, [selectedFile, repo, github]);

  useEffect(() => {
    console.log("repo:", repo);
  }, [repo]);

  const tabs = useMemo(
    () => [
      {
        id: "code",
        label: "Code",
        content: (
          <CodeTab
            files={files}
            selectedFile={selectedFile}
            content={fileContent}
            loading={fileLoading}
            onSelectFile={setSelectedFile}
          />
        ),
      },
      {
        id: "commits",
        label: "Commits",
        content: <CommitsTab commits={commits} />,
      },
      {
        id: "diff",
        label: "Diff",
        content: repo ? <DiffTab repo={repo} /> : <div>No repo found</div>,
      },
      {
        id: "metadata",
        label: "Metadata",
        content: repo ? <MetadataTab repo={repo} /> : <div>No repo found</div>,
      },
      {
        id: "feedback",
        label: "Feedback",
        content: (
          <FeedbackTab
            isEditing={isEditing}
            feedbackData={feedbackData}
            onFeedbackChange={handleFeedbackTextChange}
            onGradeChange={(newGrade) =>
              setFeedbackData((prev) => ({ ...prev, grade: newGrade }))
            }
            onToggleEdit={() => setIsEditing((prev) => !prev)}
            onDownload={() => handleClick("Download Feedback PDF")}
          />
        ),
      },
    ],
    [
      files,
      selectedFile,
      fileContent,
      fileLoading,
      commits,
      repo,
      isEditing,
      feedbackData,
    ]
  );

  if (loading) return <Spinner />;

  if (!repo)
    return <div className="p-4 text-red-600">Repository not found.</div>;

  return (
    <div className="flex flex-col space-y-10 p-4 md:p-12">
      <div className="flex flex-col space-y-6">
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          <div className="flex space-x-4">
            <BackButton
              to={`/orgs/${orgName}/assignments/${assignmentName}/repos`}
            />
            <BasicHeading heading={repo.name} />
          </div>
        </div>
        <Tabs tabs={tabs} />
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/RepoInfoCard.tsx">
import type { RepoInfo } from "@shared/githubInterfaces";

interface RepoInfoCardProps {
  title?: string;
  repo: RepoInfo;
}

export default function RepoInfoCard({ title, repo }: RepoInfoCardProps) {
  return (
    <div className={`rounded shadow p-4 bg-white border`}>
      {title && (
        <h2 className="text-lg font-semibold text-gray-800 mb-3">{title}</h2>
      )}
      <div className="text-gray-700 text-sm">
        <ul className="space-y-1 text-sm">
          <li>
            <div className="flex items-center space-x-3">
              <img
                src={repo.collaborators[0].avatarUrl}
                alt={repo.avatarUrl}
                className="w-6 h-6 rounded-full"
              />
              <strong>{repo.collaborators[0].name}</strong>
            </div>
          </li>
          <li>
            <strong>Created:</strong>{" "}
            {new Date(repo.createdAt).toLocaleString()}
          </li>
          <li>
            <strong>Updated:</strong>{" "}
            {new Date(repo.updatedAt).toLocaleString()}
          </li>
          <li>
            <strong>URL:</strong>{" "}
            <a
              href={repo.url}
              target="_blank"
              rel="noopener noreferrer"
              className="text-blue-600 underline"
            >
              {repo?.url}
            </a>
          </li>
        </ul>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoPage/ReposPage.tsx">
import BasicHeading from "../../components/BasicHeading";
import BasicList from "../../components/basicList/BasicList";
import BasicSearchBar from "../../components/BasicSearchBar";
import type { RepoInfo } from "@shared/githubInterfaces";
import { useEffect, useState } from "react";
import { useGitHub } from "../../context/useGitHub";
import { useParams } from "react-router-dom";
import { useFilteredList } from "../../hooks/useFilteredList";
import BackButton from "../../components/BackButton";
import BasicButton from "../../components/BasicButton";
import { sortData } from "../../utils/sortingUtils";
import type { SortOption } from "../../utils/sortingUtils";
import Spinner from "../../components/Spinner";

export default function ReposPage() {
  const { orgName } = useParams<{ orgName: string }>();
  const { assignmentName } = useParams<{ assignmentName: string }>();
  const github = useGitHub();
  const [repos, setRepos] = useState<RepoInfo[]>([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [loading, setLoading] = useState(true);
  const [sortOrder, setSortOrder] = useState<SortOption>("Newest");

  const filteredRepos = useFilteredList(repos ?? [], searchTerm, (repo, term) =>
    repo.name.toLowerCase().includes(term.toLowerCase())
  );

  const sortedRepos = sortData(filteredRepos, sortOrder);

  useEffect(() => {
    if (orgName) {
      github
        .getRepos(orgName, assignmentName)
        .then(setRepos)
        .catch(console.error)
        .finally(() => setLoading(false));
    }
  }, [orgName, assignmentName, github]);

  const handleClick = (action: string) => {
    console.log(`Clicked ${action}`);
  };

  console.log("repos", repos);
  return (
    <div className="flex flex-col space-y-10 p-4 md:p-12">
      <div className="flex flex-col space-y-6">
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          <div className="flex space-x-4">
            <BackButton to={`/orgs/${orgName}/assignments`} />
            <BasicHeading heading={`Repositories in ${assignmentName}`} />
          </div>
          <div className="flex space-x-4">
            <BasicSearchBar value={searchTerm} onChange={setSearchTerm} />
          </div>
        </div>
        <div className="flex flex-col md:flex-row md:items-center md:justify-end gap-4">
          <BasicButton
            onClick={() => handleClick("Run Analysis")}
            text="Run Analysis"
          />
          <BasicButton
            onClick={() => handleClick("View Summary")}
            text="View Summary"
          />
        </div>
      </div>

      {loading ? (
        <Spinner />
      ) : (
        <BasicList
          type="repo"
          items={sortedRepos}
          orgName={orgName!}
          assignmentName={assignmentName!}
          isLoading={loading}
          sortOrder={sortOrder}
          onSortChange={setSortOrder}
        />
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/SpecificUserSubmissionScreen.tsx">
import { useEffect, useState } from "react";
import { useParams, useNavigate } from "react-router-dom";

interface SubmissionData {
  name: string;
  feedback: string;
  date: string;
  fileName: string;
  grade: string;
}

export default function SpecificUserSubmissionScreen() {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const [data, setData] = useState<SubmissionData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Edit-tilat
  const [isEditing, setIsEditing] = useState(false);
  const [editedFeedback, setEditedFeedback] = useState("");

  useEffect(() => {
    setLoading(true);
    setError(null);
    setTimeout(() => {
      if (!id) {
        setError("ID puuttuu");
        setLoading(false);
        return;
      }
      setData({
        name: `Matti Meikäläinen`,
        feedback: "",
        date:
          new Date().toLocaleDateString("fi-FI") +
          " " +
          new Date().toLocaleTimeString("fi-FI", {
            hour: "2-digit",
            minute: "2-digit",
          }),
        fileName: `tehtava${id}.zip`,
        grade: "3/5",
      });
      setLoading(false);
    }, 800);
  }, [id]);

  if (loading) {
    return <div className="text-center mt-10">Ladataan...</div>;
  }
  if (error) {
    return <div className="text-center mt-10 text-red-600">{error}</div>;
  }
  if (!data) {
    return null;
  }

  // Edit-painikkeen toiminta
  const handleEditClick = () => {
    setIsEditing(true);
    setEditedFeedback(data.feedback);
  };

  const handleSave = () => {
    setData({ ...data, feedback: editedFeedback });
    setIsEditing(false);
  };

  const handleCancel = () => {
    setIsEditing(false);
    setEditedFeedback("");
  };

  // Download-painikkeen toiminta (simuloitu PDF)
  const handleDownload = () => {
    const element = document.createElement("a");
    const file = new Blob([data.feedback], { type: "application/pdf" });
    element.href = URL.createObjectURL(file);
    element.download = data.fileName.replace(/\.zip$/, ".pdf");
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  };

  // Edit Grade -painikkeen toiminta
  const handleEditGrade = () => {
    const uusiArvosana = window.prompt(
      "Syötä uusi arvosana (esim. 4/5):",
      data.grade
    );
    if (uusiArvosana && uusiArvosana.trim() !== "") {
      setData({ ...data, grade: uusiArvosana });
    }
  };

  // Delete-painikkeen toiminta
  const handleDelete = () => {
    if (
      window.confirm(
        "Haluatko varmasti poistaa koko palautuksen? Tätä toimintoa ei voi perua."
      )
    ) {
      navigate(-1);
    }
  };

  return (
    <div className="min-h-screen bg-[#F5F5F5] flex justify-center items-center">
      <div className="max-w-[820px] w-full bg-white rounded-[16px] shadow-lg p-0 sm:p-[60px] py-[48px] border border-[#E0E0E0]">
        <div className="relative w-full h-full flex flex-col items-start">
          <div
            className="w-full h-full bg-white rounded-none shadow-none px-0 py-0 relative border-none"
            style={{ boxShadow: "none" }}
          >
            {/* Ylärivi: tekstit vasemmalle, painikkeet oikealle */}
            <div className="flex flex-row justify-between items-start w-full gap-4 mt-2 mb-2">
              <div className="flex flex-row items-start gap-4">
                <button
                  onClick={() => navigate(-1)}
                  className="p-0 rounded-full text-[32px] font-extrabold text-[#1E1E1E] leading-none border-none bg-transparent hover:bg-gray-100 mt-1"
                  aria-label="Takaisin"
                  style={{ fontFamily: "inherit", border: "none" }}
                >
                  &#8592;
                </button>
                <div>
                  <h1
                    className="text-[20px] font-extrabold text-[#1E1E1E] mb-1"
                    style={{ fontFamily: "inherit" }}
                  >
                    Matti Meikäläinen
                  </h1>
                  <div className="text-[#1E1E1E] text-[13px] flex flex-col gap-0.5">
                    <span>Submission time: {data.date}</span>
                    <span>Grade: {data.grade}</span>
                  </div>
                </div>
              </div>
              <div className="flex flex-col gap-4 items-end pr-8">
                <button
                  className="bg-[#1E1E1E] text-white px-6 py-1.5 rounded-full font-medium text-[13px] w-[180px] text-right"
                  style={{ boxShadow: "none", letterSpacing: 0 }}
                  onClick={handleDownload}
                >
                  Download Feedback PDF
                </button>
                <button
                  className="bg-[#1E1E1E] text-white px-6 py-1.5 rounded-full font-medium text-[13px] w-[180px] text-right"
                  style={{ boxShadow: "none", letterSpacing: 0 }}
                  onClick={handleEditGrade}
                >
                  Edit Grade
                </button>
                <button
                  className="bg-[#1E1E1E] text-white px-6 py-1.5 rounded-full font-medium text-[13px] w-[180px] text-right"
                  style={{ boxShadow: "none", letterSpacing: 0 }}
                  onClick={handleEditClick}
                  disabled={isEditing}
                >
                  Edit Feedback
                </button>
              </div>
            </div>
            {/* AI Feedback -laatikko */}
            <div className="pt-6 pb-4">
              <div className="text-[15px] font-semibold text-[#1E1E1E] mb-2">
                AI Feedback:
              </div>
              <div
                className="w-full bg-[#C7C7C7] rounded-[8px] min-h-[120px] flex items-center justify-center text-[#1E1E1E] text-[15px] p-6 border-none"
                style={{ height: 120 }}
              >
                {isEditing ? (
                  <div className="w-full">
                    <textarea
                      className="w-full border rounded p-4 min-h-[80px] bg-white text-[#1E1E1E] text-[15px]"
                      value={editedFeedback}
                      onChange={(e) => setEditedFeedback(e.target.value)}
                    />
                    <div className="mt-2 flex gap-2">
                      <button
                        className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 text-[13px]"
                        onClick={handleSave}
                      >
                        Tallenna
                      </button>
                      <button
                        className="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 text-[13px]"
                        onClick={handleCancel}
                      >
                        Peruuta
                      </button>
                    </div>
                  </div>
                ) : data.feedback ? (
                  data.feedback
                ) : (
                  <span className="text-[#757575]">
                    Highlighted issues, what went well etc etc
                  </span>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/services/feedbackService.ts">
import { supabase } from "../../../server/utils/supabase";

export async function saveFeedback(submissionId: string, aiComment: string, score: number) {
  const { data, error } = await supabase.from("feedback").insert([
    {
      submission_id: submissionId,
      ai_comment: aiComment,
      score,
    },
  ]);

  if (error) throw error;
  return data?.[0];
}
</file>

<file path="client/src/services/submissionService.ts">
import { supabase } from "../../../server/utils/supabase";

export async function saveSubmission(
  assignmentId: string,
  studentGithub: string,
  repoUrl: string
) {
  const { data, error } = await supabase.from("submissions").insert([
    {
      assignment_id: assignmentId,
      student_github: studentGithub,
      repo_url: repoUrl,
    },
  ]);

  if (error) throw error;
  return data?.[0];
}
</file>

<file path="client/src/types/OrgReport.ts">
export type OrgReport = {
  org: string;
  assignments: string[];
  submissions: {
    student: string; // student github username
    grades: Record<string, number | string | null>; 
  }[];
};
</file>

<file path="client/src/types/StudentInStudentRoster.ts">
export type StudentInStudentRoster = {
  identifier: string;
  github_username: string;
  github_id: string;
  name: string;
};
</file>

<file path="client/src/types/StudentSubmissionInfo.ts">
export interface StudentSubmissionInfo {
  id: string;
  studentProfilePicture: string;
  studentName: string;
  submissionStatus: string;
  currentGrade: string;
  submissionTime: string;
}
</file>

<file path="client/src/utils/feedbackUtils.ts">
import type { AssignmentFeedback } from "@shared/aiInterfaces";

function generateSummaryFeedback(
  feedbackByFile: AssignmentFeedback["feedbackByFile"]
): string {
  const summary =
    "Overall, good structure and code readability. Minor issues found.";
  const issues: string[] = [];

  let count = 1;
  for (const file of feedbackByFile) {
    for (const issue of file.issues) {
      issues.push(
        `Issue ${count}: ${issue.text}${
          issue.line ? ` (line ${issue.line}, in ${file.fileName})` : ""
        }`
      );
      count++;
    }
  }

  return [summary, ...issues].join("\n");
}

const feedbackByFile: AssignmentFeedback["feedbackByFile"] = [
  {
    fileName: "App.tsx",
    issues: [
      { id: 1, line: 5, text: "It would be better to use justify-end." },
      { id: 2, line: 34, text: "I couldn't find the import component." },
    ],
  },
  {
    fileName: "Home.tsx",
    issues: [
      {
        id: 1,
        line: 5,
        text: "I couldn't find any useContent component in the App.tsx - compulsory requirement.",
      },
    ],
  },
];

const defaultFeedback: AssignmentFeedback = {
  repoName: "week-2-assignment-tangerinekey380",
  assignmentTitle: "React Todo App",
  grade: "4",
  date: "2025-05-20T15:23:00Z",
  feedbackByFile,
  feedback: generateSummaryFeedback(feedbackByFile),
};

export function getInitialFeedback(): AssignmentFeedback {
  return defaultFeedback;
}
</file>

<file path="client/src/utils/generateCSVFromOrg.ts">
/* 
FORMAT OF CSV DOCUMENT:

Overview of Student Grades and Submissions

Name          Assignment 1      Assignment 2     Assignment 3     Grade Average 
Alice Park        5                 N/A               2              2.33
Micheal Devon     4                 3                 5               4
Willie Wonka      Error             N/A               5              1.66

// maybe later something about students who have done nothing?
*/

import type { OrgReport } from "src/types/OrgReport";

function downloadCSV(csvContent: string, filename: string = "report.csv") {
  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.setAttribute("href", url);
  link.setAttribute("download", filename);
  link.style.visibility = "hidden";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

export function generateCSVFromOrg(orgData: OrgReport) {
  // get all assignments under the organization
  const assignmentNames = orgData.assignments;
  const headerRow = ["Username", ...assignmentNames, "Grade Average"]; 

  const csvLines = [
    ["Overview of Student Grades and Submissions"], // title row
    headerRow, // header row
  ];

  for (const submission of orgData.submissions) {
    const { student, grades } = submission;
    const row: (string | number)[] = [student];

    let sum = 0;
    let count = 0;

    for (const assignment of assignmentNames) {
      const grade = grades[assignment];
      if (typeof grade === "number") {
        row.push(grade);
        sum += grade;
        count++;
      } else if (grade === "Error") {
        row.push("Error");
      } else {
        row.push("N/A");
      }
    }

    const average = count > 0 ? (sum / count).toFixed(2) : "N/A";
    row.push(average);
    csvLines.push(row.map(String));
  } 

  const csvContent = csvLines.map((row) => row.join(";")).join("\n");
  downloadCSV(csvContent, `${orgData.org}_assignments_overview.csv`);
}
</file>

<file path="client/src/utils/parseFileTree.ts">
import type { FileNode } from "../pages/repoDetailPage/FileTree";

// Internal type for building tree using object map
interface InternalNode extends Omit<FileNode, "children"> {
  children?: Record<string, InternalNode>;
}

export function parseFileTree(paths: string[]): FileNode[] {
  const root: Record<string, InternalNode> = {};

  paths.forEach((path) => {
    const parts = path.split("/");
    let current = root;
    let currentPath = "";

    parts.forEach((part, index) => {
      currentPath = currentPath ? `${currentPath}/${part}` : part;

      if (!current[part]) {
        current[part] = {
          name: part,
          path: currentPath,
          isDirectory: index < parts.length - 1,
          children: index < parts.length - 1 ? {} : undefined,
        };
      }

      if (index < parts.length - 1) {
        current = current[part].children!;
      }
    });
  });

  // Convert InternalNode -> FileNode (with children as array)
  const convert = (nodes: Record<string, InternalNode>): FileNode[] =>
    Object.values(nodes).map((node) => ({
      name: node.name,
      path: node.path,
      isDirectory: node.isDirectory,
      children: node.children ? convert(node.children) : undefined,
    }));

  return convert(root);
}
</file>

<file path="client/src/utils/sortingUtils.ts">
export type SortOption =
  | "Newest"
  | "Oldest"
  | "A–Z"
  | "Z–A"
  | "Amount of Students"
  | "Amount of Students (desc)";

interface WithUpdatedAt {
  updatedAt: string;
}

interface WithAmountOfStudents {
  amountOfStudents: number;
}

function hasUpdatedAt(obj: unknown): obj is WithUpdatedAt {
  return typeof obj === "object" && obj !== null && "updatedAt" in obj;
}

function hasAmountOfStudents(obj: unknown): obj is WithAmountOfStudents {
  return typeof obj === "object" && obj !== null && "amountOfStudents" in obj;
}

export function sortData<T extends { name: string }>(
  data: T[],
  sortOrder: SortOption
): T[] {
  const sorted = [...data];

  switch (sortOrder) {
    case "A–Z":
      return sorted.sort((a, b) => a.name.localeCompare(b.name));

    case "Z–A":
      return sorted.sort((a, b) => b.name.localeCompare(a.name));

    case "Newest":
      return sorted.sort((a, b) =>
        hasUpdatedAt(a) && hasUpdatedAt(b)
          ? new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
          : 0
      );

    case "Oldest":
      return sorted.sort((a, b) =>
        hasUpdatedAt(a) && hasUpdatedAt(b)
          ? new Date(a.updatedAt).getTime() - new Date(b.updatedAt).getTime()
          : 0
      );

    case "Amount of Students":
      return sorted.sort((a, b) =>
        hasAmountOfStudents(a) && hasAmountOfStudents(b)
          ? a.amountOfStudents - b.amountOfStudents
          : 0
      );

    case "Amount of Students (desc)":
      return sorted.sort((a, b) =>
        hasAmountOfStudents(a) && hasAmountOfStudents(b)
          ? b.amountOfStudents - a.amountOfStudents
          : 0
      );

    default:
      return sorted;
  }
}
</file>

<file path="client/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="client/tailwind.config.js">
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}", // adjust this if your files are in different folders
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
</file>

<file path="client/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@shared/*": ["../shared/*"]
    },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "types": ["react", "react-dom"],

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src", "../server/routes/testroutes.ts", "../server/AssignmentsService.ts", "../server/services/UserService.ts"]
}
</file>

<file path="client/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="client/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,
    "types": ["node"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="client/vite.config.ts">
import { defineConfig } from "vite";
import tailwindcss from "@tailwindcss/vite";
import react from "@vitejs/plugin-react";
import path from "path";

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      "@shared": path.resolve(__dirname, "../shared"),
    },
  },
  server: {
    proxy: {
      "/api": {
        target: "http://localhost:5000", // backend server
        changeOrigin: true,
        secure: false,
      },
    },
  },
});
</file>

<file path="docs/ARCHITECTURE.md">
# System Architecture

## Overview

This system is designed as a full-stack web application that automates feedback for programming assignments submitted via GitHub Classroom. It consists of three core layers—Frontend, Backend, and External Integrations—each playing a distinct role in delivering real-time, AI-assisted insights to both students and teachers.

The Frontend, built with React, provides a user-friendly interface for authentication, repository selection, and feedback visualization. It communicates with the Backend via RESTful APIs.

The Backend, powered by Node.js and Express, handles user authentication through GitHub OAuth, fetches repository data via the GitHub API, and manages prompt generation and communication with AI services like OpenAI or DeepSeek. It also formats and returns feedback, summaries, and CSV exports to the frontend.

The system leverages external APIs—GitHub API for accessing student submissions and AI APIs for analyzing code and generating feedback—without requiring a dedicated database for the MVP.

Components are containerized using Docker to ensure portability and consistent development environments.

## Components

- **Frontend (React):**
  Built with React and Vite, the frontend provides the user interface for teachers. It includes components for login, repository selection, feedback display, and summary reports. Styled with Tailwind CSS, it communicates with the backend via a structured API service layer using axios.

- **Backend (Node.js/Express):** Handles authentication, repository reading, AI communication.
  Acts as the main server layer. It handles GitHub OAuth authentication, fetches repositories, processes requests, and orchestrates interactions between GitHub and AI services. Follows a modular structure with routes, controllers, and services.

- **AI Integration (OpenAI):** Generates feedback from student code.
  Uses AI APIs to analyze student code, generate insightful feedback, and suggest improvements. Prompts are crafted dynamically based on submission context and user roles (teacher).

- **GitHub API:** Used to access student repositories and commit history.
  Integrates GitHub REST APIs to authenticate users, list repositories, and fetch student assignment code and metadata (e.g., commits, diffs). It serves as the bridge between GitHub Classroom and the feedback system.

<!-- - **(Optional) Database:** If used, describe its purpose. -->

## Data Flow

1. Teacher logs in via GitHub OAuth.
2. Repositories are listed via GitHub API.
3. Code is fetched and passed to the AI with a prompt.
4. AI response is returned and shown in UI.
5. Feedback summary and CSV report are generated.

## Architecture Diagram

[![System Architecture](https://mermaid.ink/img/pako:eNp1VE1vm0AQ_SurPeRSPgw2YHOoZGMntdRKkZ320NLDGsaAArtoWdo4lv97Z4FEwXI5oBnevLdvZoAzTUQKNKSmacY8EfxYZGHMCSnZSbQqJCnLJMS8g4-l-JvkTCrytMaapj1kktU5uZeCK-Dpr5i-hTH9rVX6a-kg8n1LIlHVggNXzRh2EX5kGTT2Ds-EK3SK6PJxS_Yg_xQJkK_sBHIo0Sd9MLJiyXPvY4hGSittY_NSS2gacuOklfYRoX8pyhLkFahtPBTqS3sgy1bl5BPZQS3wxtJ3O0PpTPcjsVlFHoCDZEpcVXi6py25B0gP6JRseFZwGNf42s3-B0HHQqr_taz9MuTKwXsXj4Qi3fZa4DzksSiBmOTmkiL3uuzWDCM9hrSrMhO9zgasU1WOvHVLI6ZJdpv9E9GrM83POP0eWjl96g6p26dTcoeD0zd_AGY94PVp1NOWg0rkjkSjaZdi0R1C_bOkLHCyKBzTXKm6CW0bjTdWVqi8PVjo3gZu48ugYjpieB8YdcnUUcjKEjVwVnQsrWJrDjVoJouUhkq2YNAKZMV0Ss9aL6YqhwqXGmKYMvmsKRfk1Iz_FKJ6o0nRZjkNj6xsMGvrlClYF_jZser9qcTJgoxEyxUNF50EDc_0hYZOEFj-wvGnwcRZOO5kMTfoiYb-xPLnwSxw557rLDDyLgZ97U6dWPPAMyikBb6W3_qvv_sJXP4Bq800Cg?type=png)](https://mermaid.live/edit#pako:eNp1VE1vm0AQ_SurPeRSPgw2YHOoZGMntdRKkZ320NLDGsaAArtoWdo4lv97Z4FEwXI5oBnevLdvZoAzTUQKNKSmacY8EfxYZGHMCSnZSbQqJCnLJMS8g4-l-JvkTCrytMaapj1kktU5uZeCK-Dpr5i-hTH9rVX6a-kg8n1LIlHVggNXzRh2EX5kGTT2Ds-EK3SK6PJxS_Yg_xQJkK_sBHIo0Sd9MLJiyXPvY4hGSittY_NSS2gacuOklfYRoX8pyhLkFahtPBTqS3sgy1bl5BPZQS3wxtJ3O0PpTPcjsVlFHoCDZEpcVXi6py25B0gP6JRseFZwGNf42s3-B0HHQqr_taz9MuTKwXsXj4Qi3fZa4DzksSiBmOTmkiL3uuzWDCM9hrSrMhO9zgasU1WOvHVLI6ZJdpv9E9GrM83POP0eWjl96g6p26dTcoeD0zd_AGY94PVp1NOWg0rkjkSjaZdi0R1C_bOkLHCyKBzTXKm6CW0bjTdWVqi8PVjo3gZu48ugYjpieB8YdcnUUcjKEjVwVnQsrWJrDjVoJouUhkq2YNAKZMV0Ss9aL6YqhwqXGmKYMvmsKRfk1Iz_FKJ6o0nRZjkNj6xsMGvrlClYF_jZser9qcTJgoxEyxUNF50EDc_0hYZOEFj-wvGnwcRZOO5kMTfoiYb-xPLnwSxw557rLDDyLgZ97U6dWPPAMyikBb6W3_qvv_sJXP4Bq800Cg)
</file>

<file path="docs/EPICS.md">
# Epic Stories

Organize your features and user stories into broader epics.

## Epics and Related Stories

### 1. GitHub Integration

#### Goal: Enable secure and seamless access to student repositories using GitHub's API.

##### User stories:

- As a teacher, I want to authenticate with GitHub using OAuth so I can securely access student repositories.
- As a teacher, I want to view a list of student repositories so I can select which ones to analyze.
- As a teacher, I want to fetch code and metadata (e.g., last commit, repo owner) for each repository.

##### Suggestions:

- Support GitHub Classroom filtering/tagging to improve repo discovery.
- Cache repository metadata to reduce API usage and improve performance.

### 2. AI Feedback Engine

#### Goal: Provide automated, context-aware feedback on student code using LLMs.

##### User stories:

- As a teacher, I want to automatically generate prompts from student code so I can get feedback from the AI without manual formatting.
- As a system, I need to send these prompts to an AI engine (OpenAI or DeepSeek) and receive relevant, structured feedback.
- As a user, I want error handling and retry mechanisms in case of AI API failures.

##### Suggestions:

- Store past AI responses temporarily (in memory or local cache) to reduce duplicate requests during session.
- Define prompt templates that adapt to different code types or assignment goals.
- Consider feedback format standardization (e.g., issue type, severity, suggestion) for easier UI rendering and reporting.

### 3. Feedback UI

#### Goal: Display AI feedback clearly and helpfully for each student’s submission.

##### User stories:

- As a teacher, I want to view AI-generated feedback per student with syntax-highlighted code.
- As a teacher, I want common issues or coding patterns visually highlighted.
- As a user, I want the ability to toggle views between individual feedback and group insights.

##### Suggestions:

- Add collapsible sections and tags (e.g., logic, naming, performance) for better navigation.
- Consider future read-only student access UI for feedback transparency and self-learning.

### 4. Reporting Tools

#### Goal: Aggregate and export meaningful summaries of student feedback and performance.

##### User stories:

- As a teacher, I want to generate group-level summaries to identify widespread challenges.
- As a teacher, I want to export all feedback and points as a CSV file for grading or archival purposes.
- As a teacher, I want to see submission trends over time to evaluate class progress.

##### Suggestions:

- Include analytics like “top 5 common issues” or “average feedback score” per assignment.
- Allow optional filters (by student, assignment, or issue type) when generating reports.

### 5. Project Infrastructure

#### Goal: Support scalable development and deployment through reliable tooling.

##### User stories:

- As a developer, I want Docker containers for both frontend and backend to ensure consistency across environments.
- As a team, I want a basic CI/CD pipeline to run tests and deploy the app automatically (optional in MVP).
- As a developer, I want a documented deployment plan (e.g., Vercel for frontend, Render/Fly.io/Heroku for backend, optional in MVP).

##### Suggestions:

- Add environment variable management and secrets handling early on (e.g., .env, GitHub secrets).
- Plan for rate limits and retries when integrating with GitHub or AI APIs.
</file>

<file path="docs/PROJECT_PLAN.md">
# Project Plan

## Team Members and Roles

- [Helmi Griffiths](https://github.com/HelmiGr) - Full Stack developer
- [Sam Chou](https://github.com/FuzzyKala) - Full Stack developer
- [Ville Matilainen](https://github.com/vima20) - Full Stack developer

## Working Methods

- Daily check-ins on working day[11 AM]
- GitHub [Project board](https://github.com/orgs/Summer-project-25-AI-Feedback-system/projects/1) to manage tasks
- Time tracking in [Time Sheet](https://unioulu-my.sharepoint.com/:x:/r/personal/t3chsa01_students_oamk_fi/_layouts/15/Doc.aspx?sourcedoc=%7B7D663633-A44C-426A-B63D-24642BF47BFC%7D&file=worked_hours.xlsx&action=default&mobileredirect=true)

## Sprint Goals

### Sprint 1 (Setup & Planning)

- Set up development environment
- Create architecture and wireframes
- Agree on tech stack and workflow

### Sprint 2 (GitHub API & Prompting)

- Implement OAuth login
- Read student repositories
- Design and test initial AI prompts

### Sprint 3 (AI Feedback & UI Integration)

- Send code to AI and receive response
- Display feedback in frontend
- Refine prompt structure

### Sprint 4 (Reporting & Finalization)

- Generate summary reports
- Implement CSV export
- Final documentation and testing

## Risks and Mitigation

- AI API cost → Limit test requests
- Prompt quality → Peer review
- Time management → Weekly deadlines
</file>

<file path="docs/REQUIREMENTS.md">
# Functional Requirements

## User Roles

- **Teacher**: Authenticates via GitHub, views student submissions, reviews AI-generated feedback, generates summary reports, and exports data as CSV.
- **Student** (optional): May access personal feedback in future versions.

## MVP Requirements

- GitHub OAuth login for authentication
- List and fetch student repositories from GitHub Classroom
- Analyze code submissions using AI (OpenAI/DeepSeek)
- Display per-student feedback in the web UI
- Generate aggregated summary reports (e.g., most common issues, success rates)
- Export detailed feedback and grading data as a CSV file

## User Stories

- As a teacher, I want to authenticate via GitHub so I can access my students’ repositories.
- As a teacher, I want to view AI-generated feedback for each student submission to save review time.
- As a teacher, I want to download a CSV file with feedback and points to simplify grading.
- As a teacher, I want to see common errors and patterns across submissions to guide class instruction.

## Non-Functional Requirements

- The system must work reliably on modern browsers (Chrome, Firefox, Edge).
- API keys and secrets must be securely stored on the server and never exposed to the frontend.
- The response time from the AI feedback engine should be under 5 seconds to ensure a smooth user experience.
- The system should be containerized (via Docker) to support easy deployment and consistent development environments.
</file>

<file path="server/.dockerignore">
# Ignore node_modules (since we install dependencies in Docker)
node_modules/

# Ignore logs and temp files
*.log
*.tmp
*.swp

# Ignore environment files (make sure not to include .env files in your image)
.env
.env.* 

# Ignore Git-related files and directories
.git/
.gitignore

# Ignore Docker files (you don't want to copy the Dockerfile itself)
Dockerfile
.dockerignore

# Ignore package manager logs (npm-debug.log, yarn-error.log)
npm-debug.log*
yarn-error.log*

# Ignore build and dist directories (as the image should be built within Docker)
dist/
build/

# Ignore any IDE specific files (like VS Code, JetBrains, etc.)
.vscode/
.idea/

# Ignore other temporary files
*.bak
*.orig

.env*
.flaskenv*
!.env.project
!.env.vault
</file>

<file path="server/Aievolution.ts">
import * as fs from 'fs/promises';
import axios from 'axios';
import * as dotenv from 'dotenv';
import * as nodemailer from 'nodemailer';
import path from 'path';

// Load environment variables from .env file
dotenv.config();

// OpenAI API response types
interface OpenAIResponse {
  choices: Array<{
    message: {
      content: string;
    };
  }>;
}

// Create email transporter
const createTransporter = () => {
  if (!process.env.GMAIL_USER || !process.env.GMAIL_APP_PASSWORD) {
    throw new Error('Gmail-tunnukset puuttuvat .env-tiedostosta');
  }

  return nodemailer.createTransport({
    service: 'gmail',
    auth: {
      user: process.env.GMAIL_USER,
      pass: process.env.GMAIL_APP_PASSWORD
    }
  });
};

// Wait for specified time
const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// Get all XML files from output directory
async function getXmlFiles(dir: string): Promise<string[]> {
  try {
    const files = await fs.readdir(dir);
    return files.filter(f => f.endsWith('.xml')).map(f => `${dir}/${f}`);
  } catch (error) {
    console.error('Error reading directory:', error);
    return [];
  }
}

// Split large XML file into smaller chunks
function splitXmlIntoChunks(xmlContent: string, maxChunkSize: number = 15000): string[] {
  const chunks: string[] = [];
  let currentChunk = '';
  
  // Split XML line by line
  const lines = xmlContent.split('\n');
  
  for (const line of lines) {
    // If current chunk + new line is too large, save chunk and start new one
    if ((currentChunk + line).length > maxChunkSize) {
      if (currentChunk) {
        chunks.push(currentChunk);
        currentChunk = '';
      }
      // If single line is too long, split it into smaller parts
      if (line.length > maxChunkSize) {
        const subChunks = line.match(new RegExp(`.{1,${maxChunkSize}}`, 'g')) || [];
        chunks.push(...subChunks);
      } else {
        currentChunk = line;
      }
    } else {
      currentChunk += (currentChunk ? '\n' : '') + line;
    }
  }
  
  if (currentChunk) {
    chunks.push(currentChunk);
  }
  
  return chunks;
}

// Send XML to OpenAI LLM for evaluation
async function evaluateWithOpenAI(xmlContent: string): Promise<string> {
  const apiKey = process.env.OPENAI_API_KEY?.trim();
  if (!apiKey) {
    throw new Error('OpenAI API key not found in .env file');
  }

  const endpoint = 'https://api.openai.com/v1/chat/completions';

  // Calculate estimated token count (about 4 characters per token)
  const estimatedTokens = Math.ceil(xmlContent.length / 4);
  
  // Leave room for prompt and response (about 1000 tokens)
  const maxContentTokens = 3000;
  
  // Truncate content if it's too long
  const truncatedContent = estimatedTokens > maxContentTokens 
    ? xmlContent.substring(0, maxContentTokens * 4) + "\n... (content truncated)"
    : xmlContent;
    
  const prompt = `
You are a information technlogy teacher evaluating a student's project or code. Your goal is to provide constructive, concise, and actionable feedback that helps the student learn and improve. Analyze the following and rate it according to the following criteria:

1. Syntax and Validity (0-10): Is the code syntactically correct and does it run/compile without errors?

2. Structure and Organization (0-20): Is the code logically organized and are functions, classes, modules, and other language features used appropriately?

3. Clarity and Readability (0-20): Are the names of variables, functions, and classes descriptive? Is the code well-formed and easy to read?

4. Language-specific features (0-20): Does the code use features and best practices of the programming language in question (e.g., idiomatic constructs, error handling, etc.)?

5. Best practices (0-30): Does the code follow general and language-specific best practices (e.g., modularity, avoiding code duplication, proper error handling)?

Instructions:
- Analyze the code based on the criteria above.
- Provide a brief summary of the overall quality of the code, including strengths and areas for improvement.
- Give rates for each criteria and a total rating (0-5, where 0 is incomplete and 5 is excellent) based on the criteria.
- Keep the feedback clear, supportive, and instructive, student-friendly, and respectful.
- If the code seems unfinished or the context is unclear, note this and suggest possible improvements.
- If the code breaks in the middle of a function, note possible problems, but avoid speculative assumptions.

Student Code:
${truncatedContent}
`;

  let retries = 3;
  while (retries > 0) {
    try {
      console.log('Sending request to OpenAI API...');
      const response = await axios.post(endpoint, {
        model: 'gpt-3.5-turbo',
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 1000,
        temperature: 0.1
      }, {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        }
      });

      if (response.data?.choices?.[0]?.message?.content) {
        return response.data.choices[0].message.content;
      }
      throw new Error('Invalid response from OpenAI API');
    } catch (error) {
      console.error('Error calling OpenAI API:', error);
      if (axios.isAxiosError(error)) {
        console.error('API Error details:', error.response?.data);
        if (error.response?.status === 401) {
          throw new Error('Invalid OpenAI API key. Please check your .env file.');
        }
        if (error.response?.status === 429) {
          console.log('Rate limit reached, waiting 20 seconds...');
          await sleep(20000);
          retries--;
          continue;
        }
      }
      if (retries === 1) throw error;
      retries--;
      await sleep(20000);
    }
  }

  throw new Error('Failed to get response from OpenAI API after all retries');
}

// Muokataan sähköpostin lähetysfunktio Gmailille
async function sendEmailFeedback(feedbackPath: string, studentEmail: string) {
  try {
    console.log('Yritetään lähettää sähköpostia...');
    
    if (!process.env.GMAIL_USER || !process.env.GMAIL_APP_PASSWORD) {
      throw new Error('Gmail-tunnukset puuttuvat .env-tiedostosta');
    }

    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.GMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD
      },
      tls: {
        rejectUnauthorized: false
      }
    });

    // Tarkista yhteys
    await transporter.verify();

    const mailOptions = {
      from: process.env.GMAIL_USER,
      to: studentEmail,
      subject: 'Koodin arviointi',
      text: 'Koodin arviointi on liitteenä tässä sähköpostissa.',
      attachments: [
        {
          filename: 'koodin_arviointi.txt',
          path: feedbackPath
        }
      ]
    };

    const info = await transporter.sendMail(mailOptions);
    console.log('Sähköposti lähetetty onnistuneesti:', info.response);
    return info;
  } catch (error) {
    console.error('Virhe sähköpostin lähetyksessä:', error);
    if (error instanceof Error) {
      console.error('Virheen tiedot:', error.message);
    }
    throw error;
  }
}

async function main() {
  try {
    // Check if output directory exists
    await fs.access('output').catch(async () => {
      console.log('Creating output directory...');
      await fs.mkdir('output', { recursive: true });
    });

    const xmlFiles = await getXmlFiles('output');
    
    if (xmlFiles.length === 0) {
      console.log('No XML files found in output directory');
      return;
    }

    console.log(`Found ${xmlFiles.length} XML files to evaluate`);

    for (const file of xmlFiles) {
      try {
        const xml = await fs.readFile(file, 'utf-8');
        console.log(`Evaluating ${file}...`);
        const feedback = await evaluateWithOpenAI(xml);
        const resultFile = file.replace('.xml', '.feedback.txt');
        await fs.writeFile(resultFile, feedback, 'utf-8');
        console.log(`Feedback saved to ${resultFile}`);

        // Lisää sähköpostin lähetys
        const studentEmail = 'opiskelija@example.com'; // Vaihda opiskelijan sähköpostiin
        await sendEmailFeedback(resultFile, studentEmail);
      } catch (e) {
        console.error(`Error evaluating ${file}:`, e);
      }
    }
  } catch (error) {
    console.error('Error in main function:', error);
  }
}

// Run main program
main().catch(console.error);
</file>

<file path="server/AssignmentsService.ts">
import { supabase } from "./utils/supabase";

export async function saveAssignment(name: string, githubUrl: string) {
  const { data, error } = await supabase
    .from("assignments")
    .insert([{ name, github_url: githubUrl }]);

  if (error) {
    console.error("Supabase error:", error);
    throw error;
  }
}
</file>

<file path="server/controllers/authController.ts">
import { Request, Response } from "express";
import dotenv from "dotenv";
dotenv.config();

export const githubCallback = (req: Request, res: Response) => {
  // console.log("Authenticated user:", req.user);
  res.redirect(`${process.env.FRONTEND_ORIGIN}/orgs`);
};

export const getCurrentUser = (req: Request, res: Response) => {
  res.json({ user: req.user });
};

export const logout = (req: Request, res: Response) => {
  req.logout((err) => {
    if (err) {
      return res.status(500).json({ error: "Logout failed" });
    }
    req.session.destroy(() => {
      res.clearCookie("connect.sid");
      res.status(200).json({ message: "Logged out successfully" });
    });
  });
};
</file>

<file path="server/controllers/githubController.ts">
import { Request, Response } from "express";
import { extractAssignmentName } from "../utils/githubUtils";
import {
  getOrganizations,
  getAssignments,
  getStudentReposForAssignment,
  getCommits,
  getRepoTree,
  getFileContents,
  compareCommits,
} from "../services/github/githubService";

export async function handleGetOrganizations(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const orgs = await getOrganizations();
    res.json(orgs);
  } catch (error) {
    console.error("Failed to fetch organizations:", error);
    res.status(500).json({ error: "Failed to fetch organizations" });
  }
}

export async function handleGetAssignments(
  req: Request,
  res: Response
): Promise<void> {
  const orgName = req.params.orgName;

  if (!orgName) {
    res.status(400).json({ error: "Organization login not provided" });
    return;
  }

  try {
    const assignments = await getAssignments(orgName);
    res.json(assignments);
  } catch (error: any) {
    console.error("Failed to fetch assignments:", error);
    res.status(500).json({ error: "Failed to fetch assignments" });
  }
}

export async function handleGetStudentReposForAssignment(
  req: Request,
  res: Response
): Promise<void> {
  const orgName = req.params.orgName;
  const assignmentName = req.params.assignmentName;

  if (!orgName) {
    res.status(400).json({ error: "Missing organization or assignment name" });
    return;
  }

  try {
    const repos = await getStudentReposForAssignment(orgName, assignmentName);
    res.json(repos);
  } catch (error) {
    console.error("Failed to fetch student repos:", error);
    res.status(500).json({ error: "Failed to fetch student repos" });
  }
}

export async function handleGetCommits(
  req: Request,
  res: Response
): Promise<void> {
  const { orgName, repoName } = req.params;

  try {
    const commits = await getCommits(orgName, repoName);
    res.json(commits);
  } catch (error) {
    console.error("Failed to fetch commits:", error);
    res.status(500).json({ error: "Failed to fetch commits" });
  }
}

export async function handleGetRepoTree(
  req: Request,
  res: Response
): Promise<void> {
  const { orgName, repoName } = req.params;

  if (!orgName || !repoName) {
    res
      .status(400)
      .json({ error: "Organization and repository names are required" });
    return;
  }

  try {
    const tree = await getRepoTree(orgName as string, repoName as string);
    res.json(tree);
  } catch (error) {
    console.error("Failed to fetch repository tree:", error);
    res.status(500).json({ error: "Failed to fetch repository tree" });
  }
}

export async function handleGetFileContents(
  req: Request,
  res: Response
): Promise<void> {
  const { orgName, repoName } = req.params;
  const path = req.query.path as string;

  if (!orgName || !repoName || !path) {
    res.status(400).json({
      error: "Organization, repository and path are required",
    });
    return;
  }

  try {
    const contents = await getFileContents(orgName, repoName, path);
    if (contents === null) {
      res.status(404).json({ error: "File not found" });
      return;
    }
    res.json(contents);
  } catch (error) {
    console.error("Failed to fetch file contents:", error);
    res.status(500).json({ error: "Failed to fetch file contents" });
  }
}

export async function handleCompareCommits(
  req: Request,
  res: Response
): Promise<void> {
  const orgName = req.params.orgName;
  const repoName = req.params.repoName;
  const base = req.params.base;
  const head = req.params.head;

  if (!orgName || !repoName || !base || !head) {
    res.status(400).json({
      error: "Organization, repository, base and head commits are required",
    });
    return;
  }

  try {
    const comparison = await compareCommits(orgName, repoName, base, head);
    res.json(comparison);
  } catch (error) {
    console.error("Failed to compare commits:", error);
    res.status(500).json({ error: "Failed to compare commits" });
  }
}

export async function handleGetAllOrganizationData(
  req: Request,
  res: Response
): Promise<void> {
  const org = req.query.org as string;
  if (!org) {
    res.status(400).json({ error: "Missing organization parameter" });
    return;
  }
  try {
    const repos = await getStudentReposForAssignment(org);
    const assignmentSet = new Set<string>();
    const studentMap = new Map<string, Record<string, null>>();
    for (const repo of repos) {
      const assignment = extractAssignmentName(repo.name);
      assignmentSet.add(assignment);
      const student = repo.collaborators?.[0]?.name || "Unknown Student";
      // TODO: get grade here later from the db (as given by the AI)
      if (!studentMap.has(student)) {
        studentMap.set(student, {});
      }
      studentMap.get(student)![assignment] = null;
    }
    const responseData = {
      org,
      assignments: Array.from(assignmentSet),
      submissions: Array.from(studentMap.entries()).map(
        ([student, grades]) => ({
          student,
          grades, // all values null for now
        })
      ),
    };
    res.json(responseData);
  } catch (error) {
    console.error("Failed to get all data:", error);
    res.status(500).json({ error: "Failed to generate all data" });
  }
}
</file>

<file path="server/Dockerfile">
# 1. Base image
FROM node:22-alpine
LABEL org.opencontainers.image.source="https://github.com/Summer-project-25-AI-Feedback-system/AFS"

# 2. Set working directory
WORKDIR /app

# 3. Copy package files and install deps
COPY package*.json ./
RUN npm install

# 4. Copy the rest of the server files
COPY . .

# 5. Build TypeScript
RUN npm run build

# 6. Expose the port (match .env)
EXPOSE 5000

# 7. Start the server
CMD ["node", "dist/index.js"]
</file>

<file path="server/index.ts">
import express from "express";
import session from "express-session";
import passport from "./utils/passport";
import cors from "cors";
import dotenv from "dotenv";
import authRoutes from "./routes/authRoutes";
import githubRoutes from "./routes/githubRoutes";
import submitRoute from"./routes/submitRoute";
import uploadCsvRoute from "./routes/uploadCsvRoute";

dotenv.config();

const app = express();
const PORT = process.env.PORT || 5000;

app.use(
  cors({
    origin: process.env.FRONTEND_ORIGIN,
    credentials: true,
  })
);

app.use(express.json());
app.use(express.urlencoded({ extended: false }));

// Set up session
app.use(
  session({
    secret: process.env.SESSION_SECRET || "secret",
    resave: false,
    saveUninitialized: true,
    cookie: {
      httpOnly: true,
      secure: false, // Set to true only in production (HTTPS)
      sameSite: "lax", // or "none" if secure: true for cross-origin
    },
  })
);

// Initialize passport
app.use(passport.initialize());
app.use(passport.session());

// test message
app.get("/api/message", (req, res) => {
  res.json({ message: "Test message from backend!" });
});

// Routes
app.use("/api/auth", authRoutes);
app.use("/api/github", githubRoutes);
app.use("/submit", submitRoute);
app.use("/api", uploadCsvRoute);

// Error handling
app.use(
  (
    err: any,
    req: express.Request,
    res: express.Response,
    next: express.NextFunction
  ) => {
    console.error(err.stack);
    res.status(500).json({ error: "Something went wrong!" });
  }
);

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
</file>

<file path="server/middlewares/isAuthenticated.ts">
import { Request, Response, NextFunction } from "express";

export const isAuthenticated = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  if (req.isAuthenticated && req.isAuthenticated()) {
    return next();
  }
  res.status(401).json({ error: "Unauthorized" });
};
</file>

<file path="server/package.json">
{
  "name": "ai-feedback-backend",
  "version": "1.0.0",
  "main": "dist/index.ts",
  "scripts": {
    "build": "tsc",
    "start": "dotenv -e .env.production -- ts-node-dev --respawn index.ts",
    "dev": "dotenv -e .env -- ts-node-dev --respawn index.ts"
  },
  "dependencies": {
    "@octokit/rest": "^21.1.1",
    "@supabase/supabase-js": "^2.49.8",
    "@types/react": "^19.1.4",
    "axios": "^1.6.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^5.1.0",
    "express-session": "^1.18.1",
    "json2csv": "^6.0.0-alpha.2",
    "nodemailer": "^6.10.1",
    "passport": "^0.7.0",
    "passport-github2": "^0.1.12",
    "react": "^19.1.0"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/json2csv": "^5.0.7",
    "@types/node": "^22.15.12",
    "@types/nodemailer": "^6.4.14",
    "@types/passport": "^1.0.17",
    "@types/passport-github2": "^1.2.9",
    "dotenv-cli": "^8.0.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.8.3",
    "vite-tsconfig-paths": "^5.1.4"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}
</file>

<file path="server/repomix.js">
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var child_process_1 = require("child_process");
var util_1 = require("util");
var fs = require("fs/promises");
var path = require("path");
// Muunna exec-funktio Promise-pohjaiseksi
var execPromise = (0, util_1.promisify)(child_process_1.exec);
// Kovakoodattu GitHub-osoite
var GITHUB_URL = 'https://github.com/Summer-project-25-AI-Feedback-system/AI-Feedback-System.git';
/**
 * Poistaa GitHub-repositorion nimen URL:sta
 * @param url GitHub-repositorion URL
 * @returns Repositorion nimi
 */
function getRepoNameFromUrl(url) {
    // Poista mahdollinen .git-pääte
    var cleanUrl = url.replace(/\.git$/, '');
    // Hae viimeinen osa URL:sta (repositorion nimi)
    var repoName = cleanUrl.split('/').pop() || 'unknown-repo';
    return repoName;
}
var RepomixFetcher = /** @class */ (function () {
    function RepomixFetcher(outputDir) {
        if (outputDir === void 0) { outputDir = 'output'; }
        this.outputDir = path.resolve(outputDir);
        this.tempDir = path.join(process.cwd(), "repomix-temp-".concat(Date.now()));
    }
    RepomixFetcher.prototype.ensureDirectories = function () {
        return __awaiter(this, void 0, void 0, function () {
            var error_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 5, , 6]);
                        return [4 /*yield*/, fs.access(this.outputDir, fs.constants.W_OK).catch(function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, fs.mkdir(this.outputDir, { recursive: true })];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); })];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, fs.rm(this.tempDir, { recursive: true, force: true }).catch(function () { })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, fs.mkdir(this.tempDir, { recursive: true })];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, fs.access(this.tempDir, fs.constants.W_OK)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        error_1 = _a.sent();
                        throw new Error("Failed to set up directories: ".concat(error_1 instanceof Error ? error_1.message : error_1));
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    RepomixFetcher.prototype.fetchRepositoryAsXml = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var outputFileName, actualOutputFile, tempOutputFile, command, execOptions, _a, stdout, stderr, error_2, _b;
            var _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, this.ensureDirectories()];
                    case 1:
                        _e.sent();
                        outputFileName = (_c = options.outputFile) !== null && _c !== void 0 ? _c : 'repomix-output.xml';
                        actualOutputFile = path.join(this.outputDir, outputFileName).replace(/\\/g, '/');
                        tempOutputFile = path.join(this.tempDir, outputFileName).replace(/\\/g, '/');
                        command = "repomix --remote ".concat(options.remoteUrl, " --style ").concat((_d = options.style) !== null && _d !== void 0 ? _d : 'xml', " --output \"").concat(outputFileName, "\"");
                        if (options.ignore)
                            command += " --ignore \"".concat(options.ignore, "\"");
                        if (options.include)
                            command += " --include \"".concat(options.include, "\"");
                        if (options.verbose)
                            command += " --verbose";
                        execOptions = {
                            env: __assign(__assign({}, process.env), { PYTHONIOENCODING: 'utf-8', TMPDIR: this.tempDir, TEMP: this.tempDir, TMP: this.tempDir }),
                            cwd: this.tempDir,
                        };
                        _e.label = 2;
                    case 2:
                        _e.trys.push([2, 7, 14, 16]);
                        return [4 /*yield*/, execPromise(command, execOptions)];
                    case 3:
                        _a = _e.sent(), stdout = _a.stdout, stderr = _a.stderr;
                        if (stderr)
                            console.warn("Repomix stderr: ".concat(stderr));
                        if (stdout)
                            console.log("Repomix stdout: ".concat(stdout));
                        return [4 /*yield*/, fs.access(tempOutputFile, fs.constants.R_OK)];
                    case 4:
                        _e.sent();
                        return [4 /*yield*/, fs.rename(tempOutputFile, actualOutputFile)];
                    case 5:
                        _e.sent();
                        return [4 /*yield*/, fs.readFile(actualOutputFile, 'utf-8')];
                    case 6: return [2 /*return*/, _e.sent()];
                    case 7:
                        error_2 = _e.sent();
                        _e.label = 8;
                    case 8:
                        _e.trys.push([8, 12, , 13]);
                        return [4 /*yield*/, fs.access(tempOutputFile, fs.constants.R_OK)];
                    case 9:
                        _e.sent();
                        return [4 /*yield*/, fs.rename(tempOutputFile, actualOutputFile)];
                    case 10:
                        _e.sent();
                        return [4 /*yield*/, fs.readFile(actualOutputFile, 'utf-8')];
                    case 11: return [2 /*return*/, _e.sent()];
                    case 12:
                        _b = _e.sent();
                        return [3 /*break*/, 13];
                    case 13: throw new Error("Failed to fetch repository with Repomix: ".concat(error_2.message));
                    case 14: return [4 /*yield*/, fs.rm(this.tempDir, { recursive: true, force: true }).catch(function () { })];
                    case 15:
                        _e.sent();
                        return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    return RepomixFetcher;
}());
exports.default = RepomixFetcher;
</file>

<file path="server/repomix.ts">
import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';

// Convert exec function to Promise-based
const execPromise = promisify(exec);

/**
 * Extracts repository name from GitHub URL
 * @param url GitHub repository URL
 * @returns Repository name
 */
function getRepoNameFromUrl(url: string): string {
  return url.replace(/\.git$/, '').split('/').pop() || 'unknown-repo';
}

/**
 * Repomix command options
 */
interface RepomixOptions {
  remoteUrl: string;        // GitHub repository URL
  outputFile?: string;      // Output file name (default: repomix-output.xml)
  style?: 'xml' | 'markdown' | 'plain';  // Output format
  ignore?: string;          // Files/directories to ignore (comma-separated)
  include?: string;         // Files/directories to include (comma-separated)
  verbose?: boolean;        // Detailed output
}

/**
 * Repomix command line tool handling
 */
export class RepomixFetcher {
  constructor(private outputDir: string = 'output') {}

  private async ensureDir(dir: string) {
    await fs.mkdir(dir, { recursive: true }).catch(() => {});
  }

  /**
   * Fetches GitHub repository content in XML format
   */
  async fetchRepositoryAsXml(options: RepomixOptions): Promise<string> {
    await this.ensureDir(this.outputDir);

    const outputFileName = options.outputFile ?? 'repomix-output.xml';
    const outputFile = path.join(this.outputDir, outputFileName);

    let command = `repomix --remote ${options.remoteUrl} --style ${options.style ?? 'xml'} --output "${outputFileName}"`;
    if (options.ignore) command += ` --ignore "${options.ignore}"`;
    if (options.include) command += ` --include "${options.include}"`;
    if (options.verbose) command += ` --verbose`;

    await execPromise(command, {
      env: { ...process.env, PYTHONIOENCODING: 'utf-8' },
      cwd: this.outputDir,
    });

    return await fs.readFile(outputFile, 'utf-8');
  }
}

/**
 * Main program
 */
async function main() {
  const args = process.argv.slice(2);
  if (args.length === 0) {
    console.error('Usage: npm start <github-url>');
    process.exit(1);
  }

  const githubUrl = args[0];
  const repoName = getRepoNameFromUrl(githubUrl);
  const fetcher = new RepomixFetcher();

  const xml = await fetcher.fetchRepositoryAsXml({
    remoteUrl: githubUrl,
    style: 'xml',
    outputFile: `${repoName}.xml`,
    ignore: 'node_modules/*,dist/*,build/*,*.md,*.log,*.lock,*.json,*.yml,*.yaml,*.xml,*.txt,*.gitignore,*.editorconfig,*.prettierrc,*.eslintrc,*.env,*.env.*,*.config.js,*.config.ts,*.d.ts,*.map,*.min.js,*.min.css,*.ico,*.png,*.jpg,*.jpeg,*.gif,*.svg,*.woff,*.woff2,*.ttf,*.eot,*.otf,*.mp3,*.mp4,*.webm,*.webp,*.zip,*.tar,*.gz,*.rar,*.7z,*.pdf,*.doc,*.docx,*.xls,*.xlsx,*.ppt,*.pptx,*.csv,*.tsv,*.sql,*.bak,*.tmp,*.temp,*.swp,*.swo,*.swn,*.sublime-workspace,*.sublime-project,*.vscode/*,*.idea/*,*.DS_Store,Thumbs.db',
    verbose: true
  });

  console.log('Repository fetched as XML.');
  console.log(`XML file saved to: output/${repoName}.xml`);
}

// Execute main program
main();
</file>

<file path="server/routes/authRoutes.ts">
import { Router } from "express";
import passport from "../utils/passport";
import dotenv from "dotenv";
import {
  githubCallback,
  getCurrentUser,
  logout,
} from "../controllers/authController";
import { upsertUser } from "../services/UserService"; 

import { isAuthenticated } from "../middlewares/isAuthenticated";

dotenv.config();
const router = Router();

router.get(
  "/login",
  passport.authenticate("github", { scope: ["user:email"] })
);

router.get(
  "/callback",
  passport.authenticate("github", { failureRedirect: "/login" }),
  async (req, res) => {
    try {
      const user = req.user as {
        id: string;
        username: string;
        emails?: { value: string }[];
        profileUrl?: string;
      };

      const githubId = user.id;
      const username = user.username;
      const email = user.emails?.[0]?.value || ""; // fallback jos ei ole emailia
      const githubUrl = user.profileUrl || "";

      await upsertUser(githubId, username, email, githubUrl);

      res.redirect("http://localhost:5173/"); // tai frontend URL
    } catch (error) {
      console.error("Tallennus epäonnistui:", error);
      res.status(500).json({ error: "Käyttäjän tallennus epäonnistui" });
    }
  }
);
router.get("/getCurrentUser", isAuthenticated, getCurrentUser);
router.get("/logout", isAuthenticated, logout);

export default router;
</file>

<file path="server/routes/githubRoutes.ts">
import { Router } from "express";
import {
  handleGetOrganizations,
  handleGetAssignments,
  handleGetStudentReposForAssignment,
  handleGetFileContents,
  handleGetRepoTree,
  handleGetAllOrganizationData,
  handleGetCommits,
  handleCompareCommits,
} from "../controllers/githubController";
import { isAuthenticated } from "../middlewares/isAuthenticated";

const router = Router();

router.use(isAuthenticated);

router.get("/orgs", handleGetOrganizations);
router.get("/orgs/:orgName/assignments", handleGetAssignments);
router.get(
  "/orgs/:orgName/assignments/:assignmentName/repos",
  handleGetStudentReposForAssignment
);

// Repository routes
router.get("/repos/:orgName/:repoName/commits", handleGetCommits);
router.get("/repos/:orgName/:repoName/tree", handleGetRepoTree);
router.get("/repos/:orgName/:repoName/contents", handleGetFileContents);
router.get(
  "/repos/:orgName/:repoName/compare/:base/:head",
  handleCompareCommits
);

// Reporting route
router.get("/org-report", handleGetAllOrganizationData);

export default router;
</file>

<file path="server/routes/submitRoute.ts">
import { Router, Request, Response } from "express";
import { upsertUser } from "../services/UserService";

const router = Router();

router.post("/", async (req: Request, res: Response) => {
  const { id, username, email, github_url } = req.body;

  try {
    const user = await upsertUser(id, username, email, github_url); // korjattu järjestys
    res.status(200).json({ message: "User upserted", user });
  } catch (err) {
    console.error("Virhe käyttäjän tallennuksessa:", err);
    res.status(500).json({ error: err instanceof Error ? err.message : "Käyttäjän tallennus epäonnistui" });
  }
}); 

export default router;
</file>

<file path="server/routes/uploadCsvRoute.ts">
import { Router, Request, Response } from "express";
import { createClient } from "@supabase/supabase-js";
import { Parser } from "json2csv";
import dotenv from "dotenv";



dotenv.config({ path: "../.env" }); 

const router = Router();


if (!process.env.SUPABASE_URL || !process.env.SUPABASE_KEY) {
  throw new Error("Supabase URL or Key is missing in environment variables.");
}

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_KEY
);
router.post("/csv-reports", async (req: Request, res: Response): Promise<void> => {
  console.log("🔄 /csv-reports POST received");
  console.log("Body:", req.body); 

  try {
    const { rows, username } = req.body;
    
    console.log("Backend sai username:", username);

    const actualUsername = username || "unknownuser";

    if (!rows || !Array.isArray(rows.submissions)) {
      res.status(400).json({ error: "Invalid input data" });
      return;
    }

    
    const parser = new Parser();
    const csv = parser.parse(rows.submissions);
    const orgName = rows.org || "unknownorg";
    
   
   const repoName =
  Array.isArray(rows.assignments) && rows.assignments.length > 0
    ? rows.assignments[0]
    : "unknownrepo";

      const fileName = `${actualUsername}_${orgName}_${repoName}.csv`;
      const csvBuffer = new Uint8Array(Buffer.from(csv)); 

    const { error } = await supabase.storage
      .from("csv-reports")
      .upload(fileName, csvBuffer, {
        contentType: "text/csv",
        upsert: false,
      });

    if (error) throw error;

    console.log(`✅ CSV uploaded as ${fileName}`);
    res.status(200).json({ message: "CSV uploaded successfully", fileName });
  } catch (err: any) {
    console.error("❌ Error uploading CSV:", err.message);
    res.status(500).json({ error: "CSV upload failed", details: err.message });
  }
});

export default router;
</file>

<file path="server/services/github/githubService.ts">
import { promises } from "dns";
import { octokit } from "./octokitClient";
import {
  OrgInfo,
  AssignmentInfo,
  RepoInfo,
  CommitInfo,
  CompareCommitsInfo,
} from "@shared/githubInterfaces";

export async function getOrganizations(): Promise<OrgInfo[]> {
  const response = await octokit.rest.orgs.listForAuthenticatedUser();
  return response.data.map(
    (org): OrgInfo => ({
      name: org.login,
      description: org.description,
      avatarUrl: org.avatar_url,
    })
  );
}

export async function getAssignments(org: string): Promise<AssignmentInfo[]> {
  const repos = await octokit.rest.repos.listForOrg({
    org: org,
    type: "all",
    per_page: 100,
  });

  const assignmentMap = new Map<string, AssignmentInfo>();

  repos.data.forEach((repo) => {
    const baseName = repo.name.replace(/-[a-z0-9]+$/i, "");
    const updatedAt = repo.updated_at;

    const assignment = assignmentMap.get(baseName);

    if (!assignment) {
      assignmentMap.set(baseName, {
        name: baseName,
        amountOfStudents: 1,
        updatedAt: updatedAt ?? "",
      });
    } else {
      assignment.amountOfStudents++;
      if (
        updatedAt &&
        (!assignment.updatedAt ||
          new Date(updatedAt) > new Date(assignment.updatedAt))
      ) {
        assignment.updatedAt = updatedAt;
      }
    }
  });

  return Array.from(assignmentMap.values());
}

export async function getStudentReposForAssignment(
  org: string,
  assignmentPrefix?: string
): Promise<RepoInfo[]> {
  console.log(
    `Searching for repositories ${
      assignmentPrefix ? `with prefix '${assignmentPrefix}' ` : ""
    }under organization ${org}...`
  );
  const repositories: any[] = [];
  const iterator = await buildSearchQuery(org, assignmentPrefix);

  for await (const { data: reposPage } of iterator) {
    const relevantRepos = reposPage.filter(
      (repo) =>
        !assignmentPrefix ||
        repo.name.toLowerCase().includes(assignmentPrefix.toLowerCase())
    );

    const detailPromises = relevantRepos.map((repo) =>
      extractRepositoryDetails(org, repo)
    );

    const detailResults = await Promise.allSettled(detailPromises);

    detailResults.forEach((result) => {
      if (result.status === "fulfilled") {
        repositories.push(result.value);
      } else {
        console.warn("Repo detail fetch failed:", result.reason);
      }
    });
  }
  console.log(`Found ${repositories.length} matching repositories.`);
  return repositories;
}

async function buildSearchQuery(org: string, assignmentPrefix?: string) {
  const query =
    `fork:true org:${org}` +
    (assignmentPrefix ? ` ${assignmentPrefix} in:name` : "");

  return octokit.paginate.iterator(octokit.rest.search.repos, {
    q: query,
    per_page: 100,
  });
}

async function extractRepositoryDetails(org: string, repo: any) {
  const lastCommit = await octokit.rest.repos.getCommit({
    owner: org,
    repo: repo.name,
    ref: repo.default_branch,
  });

  return {
    id: repo.node_id,
    name: repo.name,
    owner: repo.owner?.login || "unknown",
    avatarUrl: repo.owner?.avatar_url ?? "",
    url: repo.html_url,
    description: repo.description ?? undefined,
    defaultBranch: repo.default_branch,
    createdAt: repo.created_at,
    updatedAt: repo.updated_at,
    lastPush: repo.pushed_at,
    lastCommitMessage: lastCommit.data.commit.message,
    lastCommitDate: lastCommit.data.commit.committer?.date,
    collaborators: await getRepoCollaborators(org, repo.name),
  };
}

async function getRepoCollaborators(org: string, repo: string) {
  try {
    const response = await octokit.rest.repos.listCollaborators({
      owner: org,
      repo,
      affiliation: "direct",
    });

    return response.data.map((user) => ({
      id: user.id,
      name: user.login,
      avatarUrl: user.avatar_url,
      htmlUrl: user.html_url,
      permissions: {
        admin: user.permissions?.admin ?? false,
        maintain: user.permissions?.maintain ?? false,
        push: user.permissions?.push ?? false,
        triage: user.permissions?.triage ?? false,
        pull: user.permissions?.pull ?? false,
      },
    }));
  } catch (error: any) {
    console.error(`Error fetching collaborators for ${repo}:`, error.message);
    return [];
  }
}

// export async function getFileContents(
//   owner: string,
//   repo: string,
//   filePaths: string[]
// ): Promise<Record<string, string | null>> {
//   const contents: Record<string, string | null> = {};
//   console.log(`\nFetching files from repository ${owner}/${repo}:`);

//   for (const filePath of filePaths) {
//     try {
//       const response = await octokit.rest.repos.getContent({
//         owner,
//         repo,
//         path: filePath,
//       });

//       if (
//         response.data &&
//         !Array.isArray(response.data) &&
//         response.data.type === "file" &&
//         response.data.content
//       ) {
//         const content = Buffer.from(response.data.content, "base64").toString(
//           "utf-8"
//         );
//         contents[filePath] = content;
//         console.log(` - ${filePath}: Downloaded (${content.length} bytes)`);
//       } else {
//         console.log(
//           ` - ${filePath}: Path found, but it's not a file or content is missing.`
//         );
//         contents[filePath] = null;
//       }
//     } catch (error: any) {
//       if (error.status === 404) {
//         console.log(` - ${filePath}: Not found.`);
//       } else {
//         console.error(
//           ` - Error fetching file ${filePath} from ${owner}/${repo}: ${error.status} ${error.message}`
//         );
//       }
//       contents[filePath] = null;
//     }
//   }

//   return contents;
// }

export async function getCommits(
  orgName: string,
  repoName: string
): Promise<CommitInfo[]> {
  const response = await octokit.rest.repos.listCommits({
    owner: orgName,
    repo: repoName,
    per_page: 100,
  });

  return response.data.map((commit) => ({
    sha: commit.sha,
    html_url: commit.html_url,
    commit: {
      message: commit.commit.message,
      author: {
        name: commit.commit.author?.name ?? "",
        email: commit.commit.author?.email ?? "",
        date: commit.commit.author?.date ?? "",
      },
    },
    author: commit.author
      ? {
          login: commit.author.login,
          avatar_url: commit.author.avatar_url,
          html_url: commit.author.html_url,
        }
      : null,
  }));
}
export async function getRepoTree(
  orgName: string,
  repoName: string
): Promise<string[]> {
  const { data: refData } = await octokit.rest.git.getRef({
    owner: orgName,
    repo: repoName,
    ref: "heads/main",
  });

  const { data: treeData } = await octokit.rest.git.getTree({
    owner: orgName,
    repo: repoName,
    tree_sha: refData.object.sha,
    recursive: "true",
  });

  return treeData.tree
    .filter((item) => item.type === "blob" && item.path)
    .map((item) => item.path!);
}

export async function getFileContents(
  orgName: string,
  repoName: string,
  path: string
): Promise<string | null> {
  try {
    const response = await octokit.rest.repos.getContent({
      owner: orgName,
      repo: repoName,
      path,
    });

    if ("content" in response.data) {
      return Buffer.from(response.data.content, "base64").toString("utf-8");
    }
    return null;
  } catch (error) {
    console.error(`Error fetching file ${path}:`, error);
    return null;
  }
}

export async function compareCommits(
  orgName: string,
  repoName: string,
  base: string,
  head: string
): Promise<CompareCommitsInfo> {
  const response = await octokit.rest.repos.compareCommits({
    owner: orgName,
    repo: repoName,
    base,
    head,
  });

  return {
    status: response.data.status ?? "",
    ahead_by: response.data.ahead_by ?? 0,
    behind_by: response.data.behind_by ?? 0,
    total_commits: response.data.total_commits ?? 0,
    commits: response.data.commits.map((commit) => ({
      sha: commit.sha,
      html_url: commit.html_url,
      commit: {
        message: commit.commit.message,
        author: {
          name: commit.commit.author?.name ?? "",
          email: commit.commit.author?.email ?? "",
          date: commit.commit.author?.date ?? "",
        },
      },
      author: commit.author
        ? {
            login: commit.author.login,
            avatar_url: commit.author.avatar_url,
            html_url: commit.author.html_url,
          }
        : null,
    })),
    files:
      response.data.files?.map((file) => ({
        filename: file.filename,
        status: file.status,
        additions: file.additions,
        deletions: file.deletions,
        changes: file.changes,
      })) ?? [],
  };
}
export async function getRepos(org: string): Promise<any[]> {
  const repos = await octokit.rest.repos.listForOrg({
    org,
    type: "all",
    per_page: 100,
  });

  return repos.data;
}
</file>

<file path="server/services/github/octokitClient.ts">
import { Octokit } from "@octokit/rest";
import dotenv from "dotenv";

dotenv.config();

export const octokit = new Octokit({
  auth: process.env.GITHUB_PAT,
});
</file>

<file path="server/services/UserService.ts">
import { supabase } from "../utils/supabase";

export async function upsertUser(
  githubId: string,
  username: string,
  email: string,
  githubUrl: string
) {
  try {
    const result = await supabase
      .from("users")
      .upsert(
        {
          github_id: githubId,
          username: username,
          github_url: githubUrl,
          email: email,
        },
        { onConflict: "github_id" }
      )
      .select()
      .single();

    // console.log("Supabase upsert result:", result);

    if (result.error) {
      console.error("Supabase error:", result.error);
      throw result.error;
    }

    return result.data;
  } catch (err) {
    console.error("Virhe käyttäjän tallennuksessa (catch):", err);
    throw err;
  }
}
</file>

<file path="server/tsconfig.json">
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "target": "ES2020", // Modern JS features
    "module": "CommonJS",
    "moduleResolution": "node", // Node-style resolution
    "rootDir": "../", // Source root
    "outDir": "./dist", // Output folder
    "esModuleInterop": true, // Support commonjs modules
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@shared/*": ["../shared/*"]
    }
  },
  "include": ["./", "Aievolution.ts"], // Include all files in this folder
  "exclude": ["node_modules", "dist"] // Avoid compiling node_modules and output
}
</file>

<file path="server/utils/githubUtils.ts">
export function extractAssignmentName(repoName: string): string {
  // Example: "assignment1-alice" => "assignment1"
  // TODO: modify or change this later if we need something different
  return repoName.replace(/-[a-zA-Z0-9]+$/, "");
}
</file>

<file path="server/utils/json2csv.ts">
declare module "json2csv" {
  export class Parser<T> {
    constructor(opts?: any);
    parse(input: T[]): string;
  }
}
</file>

<file path="server/utils/passport.ts">
import passport from "passport";
import { Strategy as GitHubStrategy, Profile } from "passport-github2";
import dotenv from "dotenv";

dotenv.config();

// GitHub OAuth configuration
passport.use(
  new GitHubStrategy(
    {
      clientID: process.env.GITHUB_CLIENT_ID as string,
      clientSecret: process.env.GITHUB_CLIENT_SECRET as string,
      callbackURL: process.env.GITHUB_CALLBACK_URL as string,
    },
    (
      accessToken: string,
      refreshToken: string,
      profile: Profile,
      done: (error: any, user?: Express.User | false | null) => void
    ) => {
      // console.log("Access Token:", accessToken);
      // console.log("GitHub Profile:", profile);
      return done(null, profile);
    }
  )
);

// Serialize user to store user in session
passport.serializeUser((user, done) => {
  done(null, user);
});

// Deserialize user from session
passport.deserializeUser((user, done) => {
  done(null, user as Express.User);
});

export default passport;
</file>

<file path="server/utils/supabase.ts">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.SUPABASE_URL!;
const supabaseKey = process.env.SUPABASE_KEY!;

export const supabase = createClient(supabaseUrl, supabaseKey);
</file>

<file path="shared/aiInterfaces.ts">
export interface AssignmentFeedback {
  // studentName: string;
  repoName: string;
  assignmentTitle: string;
  grade: string;
  date: string; // ISO format
  feedback: string;
  feedbackByFile: FileFeedback[];
}

interface FileFeedback {
  fileName: string;
  issues: FeedbackIssue[];
}

interface FeedbackIssue {
  id: number;
  line?: number;
  text: string;
}
</file>

<file path="shared/githubInterfaces.ts">
export interface OrgInfo {
  name: string;
  description: string | null;
  avatarUrl: string;
}

export interface AssignmentInfo {
  name: string;
  amountOfStudents: number;
  updatedAt: string;
}

export interface RepoInfo {
  id: string;
  name: string;
  owner: string;
  avatarUrl: string;
  url: string;
  description?: string;
  defaultBranch: string;
  createdAt: string;
  updatedAt: string;
  lastPush: string;
  lastCommitMessage: string;
  lastCommitDate: string;
  collaborators: Collaborator[];
}

export interface Collaborator {
  id: number;
  name: string;
  avatarUrl: string;
  htmlUrl: string;
  permissions: {
    admin: boolean;
    maintain: boolean;
    push: boolean;
    triage: boolean;
    pull: boolean;
  };
}

export interface User {
  id: string;
  username: string;
  displayName?: string;
  profileUrl?: string;
  photos?: { value: string }[];
}

export interface CommitAuthor {
  name: string;
  email: string;
  date: string;
}

export interface Commit {
  message: string;
  author: CommitAuthor;
}

export interface CommitInfo {
  sha: string;
  html_url: string;
  commit: Commit;
  author: {
    login: string;
    avatar_url: string;
    html_url: string;
  } | null;
}

export interface CompareCommitsInfo {
  status: string;
  ahead_by: number;
  behind_by: number;
  total_commits: number;
  commits: CommitInfo[];
  files: {
    filename: string;
    status: string;
    additions: number;
    deletions: number;
    changes: number;
  }[];
}
</file>

</files>
