This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules/*, dist/*, build/*, *.md, *.log, *.lock, *.json, *.yml, *.yaml, *.xml, *.txt, *.gitignore, *.editorconfig, *.prettierrc, *.eslintrc, *.env, *.env.*, *.config.js, *.config.ts, *.d.ts, *.map, *.min.js, *.min.css, *.ico, *.png, *.jpg, *.jpeg, *.gif, *.svg, *.woff, *.woff2, *.ttf, *.eot, *.otf, *.mp3, *.mp4, *.webm, *.webp, *.zip, *.tar, *.gz, *.rar, *.7z, *.pdf, *.doc, *.docx, *.xls, *.xlsx, *.ppt, *.pptx, *.csv, *.tsv, *.sql, *.bak, *.tmp, *.temp, *.swp, *.swo, *.swn, *.sublime-workspace, *.sublime-project, *.vscode/*, *.idea/*, *.DS_Store, Thumbs.db
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/eslint.config.js
client/index.html
client/package.json
client/public/vite.svg
client/src/App.tsx
client/src/assets/react.svg
client/src/components/AssignmentList.tsx
client/src/components/BackButton.tsx
client/src/components/BasicButton.tsx
client/src/components/BasicHeading.tsx
client/src/components/basicList/BasicList.tsx
client/src/components/basicList/ListButton.tsx
client/src/components/basicList/ListHeader.tsx
client/src/components/basicList/ListItem.tsx
client/src/components/BasicSearchBar.tsx
client/src/components/FeedbackViewer.tsx
client/src/components/Footer.tsx
client/src/components/GetCSVFileButton.tsx
client/src/components/Header.tsx
client/src/components/SortableHeader.tsx
client/src/components/SortingButton.tsx
client/src/components/Spinner.tsx
client/src/components/Tabs.tsx
client/src/context/GitHubContext.ts
client/src/context/GitHubProvider.tsx
client/src/context/types.ts
client/src/context/useGitHub.ts
client/src/context/UserContext.ts
client/src/context/UserProvider.tsx
client/src/context/useUser.ts
client/src/hooks/useFilteredList.ts
client/src/index.css
client/src/layouts/MainLayout.tsx
client/src/main.tsx
client/src/pages/analyticsPage/AnalyticsPage.tsx
client/src/pages/analyticsPage/averageAssignmentPointsTab/AveragePointsChart.tsx
client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesCard.tsx
client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesChart.tsx
client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesCollapsible.tsx
client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesTab.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/MissingSubmissionsTab.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTable.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTableHeader.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTableRow.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTableWithTabs.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/Subtext.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/UploadStudentRosterCSVButton.tsx
client/src/pages/assignmentPage/AssignmentsPage.tsx
client/src/pages/assignmentPage/sidebar/ProgressBar.tsx
client/src/pages/assignmentPage/sidebar/Sidebar.tsx
client/src/pages/assignmentPage/sidebar/SidebarButton.tsx
client/src/pages/assignmentPage/sidebar/SidebarCard.tsx
client/src/pages/assignmentPage/sidebar/SidebarPagination.tsx
client/src/pages/loginPage/LoginButton.tsx
client/src/pages/loginPage/LoginPage.tsx
client/src/pages/orgPage/OrgsPage.tsx
client/src/pages/repoDetailPage/CodeTab.tsx
client/src/pages/repoDetailPage/CommitsTab.tsx
client/src/pages/repoDetailPage/DiffTab.tsx
client/src/pages/repoDetailPage/FeedbackActions.tsx
client/src/pages/repoDetailPage/FeedbackCard.tsx
client/src/pages/repoDetailPage/FeedbackTab.tsx
client/src/pages/repoDetailPage/FileFeedbackSection.tsx
client/src/pages/repoDetailPage/FileTree.tsx
client/src/pages/repoDetailPage/MetadataTab.tsx
client/src/pages/repoDetailPage/RepoDetailPage.tsx
client/src/pages/repoDetailPage/RepoInfoCard.tsx
client/src/pages/repoPage/ReposPage.tsx
client/src/pages/SpecificUserSubmissionScreen.tsx
client/src/services/feedbackService.ts
client/src/services/submissionService.ts
client/src/types/AssignmentFeedback.ts
client/src/types/OrgReport.ts
client/src/types/StudentInfo.ts
client/src/types/StudentInStudentRoster.ts
client/src/types/StudentSubmissionInfo.ts
client/src/utils/feedbackUtils.ts
client/src/utils/generateCSVFromOrg.ts
client/src/utils/parseFileTree.ts
client/src/utils/sortingUtils.ts
client/src/vite-env.d.ts
client/tailwind.config.js
client/tsconfig.app.json
client/tsconfig.json
client/tsconfig.node.json
client/vite.config.ts
docs/ARCHITECTURE.md
docs/EPICS.md
docs/PROJECT_PLAN.md
docs/REQUIREMENTS.md
server/.dockerignore
server/Aievolution.ts
server/AssignmentsService.ts
server/controllers/aiController.ts
server/controllers/authController.ts
server/controllers/githubController.ts
server/Dockerfile
server/index.ts
server/middlewares/isAuthenticated.ts
server/output/AI-Feedback-System.xml
server/output/ASSIGNMENT_EVALUATION.md
server/package.json
server/repomix.js
server/repomix.ts
server/routes/aiRoutes.ts
server/routes/authRoutes.ts
server/routes/githubRoutes.ts
server/routes/submitRoute.ts
server/routes/uploadCsvRoute.ts
server/services/ai/aiService.ts
server/services/github/githubService.ts
server/services/github/octokitClient.ts
server/services/UserService.ts
server/tsconfig.json
server/utils/githubUtils.ts
server/utils/json2csv.ts
server/utils/passport.ts
server/utils/supabase.ts
shared/aiInterfaces.ts
shared/githubInterfaces.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)
</file>

<file path="client/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitHub Classroom Analyzer</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="client/package.json">
{
  "name": "afs",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@heroicons/react": "^2.2.0",
    "@tailwindcss/vite": "^4.1.7",
    "axios": "^1.9.0",
    "chart.js": "^4.4.9",
    "papaparse": "^5.5.3",
    "react": "^19.1.0",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^19.1.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.5.3",
    "tailwindcss": "^4.1.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@types/node": "^22.15.18",
    "@types/papaparse": "^5.3.16",
    "@types/react": "^19.1.4",
    "@types/react-dom": "^19.1.5",
    "@vitejs/plugin-react": "^4.4.1",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.30.1",
    "vite": "^6.3.5",
    "vite-tsconfig-paths": "^5.1.4"
  }
}
</file>

<file path="client/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="client/src/App.tsx">
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import MainLayout from "./layouts/MainLayout";
import LoginPage from "./pages/loginPage/LoginPage";
import OrgsPage from "./pages/orgPage/OrgsPage";
import AssignmentsPage from "./pages/assignmentPage/AssignmentsPage";
import { UserProvider } from "./context/UserProvider";
import RepoDetailPage from "./pages/repoDetailPage/RepoDetailPage";
import { GitHubProvider } from "./context/GitHubProvider";
import ReposPage from "./pages/repoPage/ReposPage";
import SpecificUserSubmissionScreen from "./pages/SpecificUserSubmissionScreen";
import AnalyticsPage from './pages/analyticsPage/AnalyticsPage';

function App() {
  return (
    <GitHubProvider>
      <UserProvider>
        <Router>
          <Routes>
            <Route path="/" element={<MainLayout />}>
              <Route index element={<LoginPage />} />
              <Route path="/orgs" element={<OrgsPage />} />
              <Route
                path="/orgs/:orgName/assignments"
                element={<AssignmentsPage />}
              />
              <Route
                path="/orgs/:orgName/assignments/:assignmentName/repos"
                element={<ReposPage />}
              />
              <Route
                path="/orgs/:orgName/assignments/:assignmentName/repos/:repoId"
                element={<RepoDetailPage />}
              />
              <Route
                path="/orgs/:orgName/assignments/:assignmentName/submission"
                element={<SpecificUserSubmissionScreen />}
              />
              <Route 
                path="/orgs/:orgName/analytics"
                element={<AnalyticsPage />}
              />
              </Route>
          </Routes>
        </Router>
      </UserProvider>
    </GitHubProvider>
  );
}

export default App;
</file>

<file path="client/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="client/src/components/AssignmentList.tsx">
import { useEffect, useState } from "react";
import { fetchAssignments } from "../../../server/AssignmentsService";

const AssignmentList = () => {
  const [assignments, setAssignments] = useState<any[]>([]);

  useEffect(() => {
    const load = async () => {
      const data = await fetchAssignments();
      setAssignments(data);
    };
    load();
  }, []);

  return (
    <div>
      <h2>Assignments</h2>
      <ul>
        {assignments.map((a) => (
          <li key={a.id}>
            {a.title} (due: {a.due_date})
          </li>
        ))}
      </ul>
    </div>
  );
};

export default AssignmentList;
</file>

<file path="client/src/components/BackButton.tsx">
import { useNavigate } from "react-router-dom";
import { BiArrowBack } from "react-icons/bi";

type BackButtonProps = {
  to: string;
};

export default function BackButton({ to }: BackButtonProps) {
  const navigate = useNavigate();

  return (
    <button
      onClick={() => navigate(to)}
      className="flex items-center text-gray-600 round"
    >
      <BiArrowBack className="mr-2" size={20} />
    </button>
  );
}
</file>

<file path="client/src/components/BasicButton.tsx">
interface BasicButtonProps {
  text: string;
  onClick: () => void;
}

export default function BasicButton({ text, onClick }: BasicButtonProps) {
  return (
    <button
      onClick={onClick}
      className="flex items-center justify-center border border-[#D9D9D9] px-6 py-3 h-[40px] rounded-full w-[220px] gap-2 bg-[#1D1B20] hover:opacity-90 text-white"
    >
      <span className="text-xs sm:text-sm text-center">{text}</span>
    </button>
  );
}
</file>

<file path="client/src/components/BasicHeading.tsx">
interface BasicHeadingProps {
  heading?: string;
  styling?: string;
}

export default function BasicHeading({
  heading,
  styling = "",
}: BasicHeadingProps) {
  return <h1 className={`text-[29px] font-bold ${styling}`}>{heading}</h1>;
}
</file>

<file path="client/src/components/basicList/BasicList.tsx">
import { useNavigate } from "react-router-dom";
import ListHeader from "./ListHeader";
import ListItem from "./ListItem";
import type { StudentSubmissionInfo } from "../../types/StudentSubmissionInfo";
import type {
  AssignmentInfo,
  OrgInfo,
  RepoInfo,
} from "@shared/githubInterfaces";
import type { SortOption } from "src/utils/sortingUtils";

interface BasicListProps {
  type: "org" | "assignment" | "repo" | "submission";
  items: OrgInfo[] | AssignmentInfo[] | RepoInfo[] | StudentSubmissionInfo[];
  isLoading: boolean;
  orgName?: string;
  assignmentName?: string;
  sortOrder?: SortOption;
  onSortChange?: (option: SortOption) => void;
}

export default function BasicList(props: BasicListProps) {
  const navigate = useNavigate();
  const isEmpty = Array.isArray(props.items) && props.items.length === 0;

  return (
    <div className="flex flex-col">
      <ListHeader
        type={props.type}
        sortOrder={props.sortOrder}
        onSortChange={props.onSortChange}
      />

      {props.isLoading && <div className="text-gray-500 p-4">Loading...</div>}

      {!props.isLoading && isEmpty && (
        <div className="text-gray-500 p-4">No items found.</div>
      )}
      {!props.isLoading &&
        !isEmpty &&
        props.items.map((item, index) => {
          const key = `${props.type}-${index}`;

          switch (props.type) {
            case "org":
              return (
                <ListItem
                  key={key}
                  type="org"
                  data={item as OrgInfo}
                  onClick={() =>
                    navigate(`/orgs/${(item as OrgInfo).name}/assignments`)
                  }
                />
              );

            case "assignment":
              return (
                <ListItem
                  key={key}
                  type="assignment"
                  data={item as AssignmentInfo}
                  onClick={() =>
                    navigate(
                      `/orgs/${props.orgName}/assignments/${encodeURIComponent(
                        (item as AssignmentInfo).name
                      )}/repos`
                    )
                  }
                />
              );

            case "repo":
              return (
                <ListItem
                  key={key}
                  type="repo"
                  data={item as RepoInfo}
                  onClick={() =>
                    navigate(
                      `/orgs/${props.orgName}/assignments/${encodeURIComponent(
                        props.assignmentName!
                      )}/repos/${(item as RepoInfo).id}`,
                      { state: item }
                    )
                  }
                />
              );

            case "submission":
              return (
                <ListItem
                  key={key}
                  type="submission"
                  data={item as StudentSubmissionInfo}
                />
              );
          }
        })}
    </div>
  );
}
</file>

<file path="client/src/components/basicList/ListButton.tsx">
interface ListButtonProps {
  text: string;
}

export default function ListButton({ text }: ListButtonProps) {
  return (
    <button className="h-8 px-4 text-xs sm:text-sm bg-[#1D1B20] text-white rounded-full w-fit min-w-[100px]">
        {text}
    </button>
  )
}
</file>

<file path="client/src/components/basicList/ListHeader.tsx">
import type { SortOption } from "src/utils/sortingUtils";
import SortableHeader from "../../components/SortableHeader";

interface ListHeaderProps {
  type: "repo" | "submission" | "assignment" | "org";
  sortOrder?: SortOption;
  onSortChange?: (option: SortOption) => void;
}

export default function ListHeader({
  type,
  sortOrder,
  onSortChange,
}: ListHeaderProps) {
  if (type === "org") {
    return (
      <div className="grid grid-cols-[40px_1fr_1fr] h-[40px] bg-[#EADDFF] px-4 gap-2 items-center text-sm font-medium border rounded border-b border-l border-r border-[#D9D9D9]">
        <div />
        <SortableHeader
          label="Organization name"
          currentSort={sortOrder}
          ascValue="Aâ€“Z"
          descValue="Zâ€“A"
          onChange={onSortChange}
        />
        <p className="text-left">Description</p>
      </div>
    );
  }

  if (type === "assignment") {
    return (
      <div className="grid grid-cols-[40px_1fr_1fr_1fr] h-[40px] bg-[#EADDFF] px-4 gap-2 items-center text-sm font-medium border rounded border-b border-l border-r border-[#D9D9D9]">
        <div />
        <SortableHeader
          label="Assignment name"
          currentSort={sortOrder}
          ascValue="Aâ€“Z"
          descValue="Zâ€“A"
          onChange={onSortChange}
        />
        <SortableHeader
          label="Amount of Students"
          currentSort={sortOrder}
          ascValue="Amount of Students"
          descValue="Amount of Students (desc)"
          onChange={onSortChange}
          center
        />
        <SortableHeader
          label="Last updated"
          currentSort={sortOrder}
          ascValue="Oldest"
          descValue="Newest"
          onChange={onSortChange}
        />
      </div>
    );
  }

  if (type === "repo") {
    return (
      <div className="grid grid-cols-[40px_1fr_1fr_1fr] h-[40px] bg-[#EADDFF] px-4 gap-2 items-center text-sm font-medium border rounded border-b border-l border-r border-[#D9D9D9]">
        <div />
        <SortableHeader
          label="Repository name"
          currentSort={sortOrder}
          ascValue="Aâ€“Z"
          descValue="Zâ€“A"
          onChange={onSortChange}
        />
        <p className="text-center">Students</p>
        <SortableHeader
          label="Last updated"
          currentSort={sortOrder}
          ascValue="Oldest"
          descValue="Newest"
          onChange={onSortChange}
        />
      </div>
    );
  }

  if (type === "submission") {
    return (
      <div className="grid grid-cols-[40px_1fr_1fr_1fr] h-[40px] bg-[#EADDFF] px-4 gap-2 items-center text-sm font-medium border rounded border-b border-l border-r border-[#D9D9D9]">
        <div />
        <p className="text-center">Student</p>
        <p className="text-center">Submission status</p>
        <p className="text-center">Grade</p>
      </div>
    );
  }
}
</file>

<file path="client/src/components/basicList/ListItem.tsx">
import type { StudentSubmissionInfo } from "../../types/StudentSubmissionInfo";
import type {
  AssignmentInfo,
  OrgInfo,
  RepoInfo,
} from "@shared/githubInterfaces";

type ListItemProps =
  | { type: "org"; data: OrgInfo; onClick?: () => void }
  | { type: "assignment"; data: AssignmentInfo; onClick?: () => void }
  | { type: "repo"; data: RepoInfo; onClick?: () => void }
  | { type: "submission"; data: StudentSubmissionInfo; onClick?: () => void };

export default function ListItem(props: ListItemProps) {
  const commonClass =
    "h-[56px] px-4 gap-2 items-center text-sm hover:bg-gray-100 cursor-pointer border rounded border-[#D9D9D9] overflow-y-auto max-h-[calc(100vh-240px)]";

  let content;
  let className = "";

  switch (props.type) {
    case "org": {
      const org = props.data;
      className = `grid grid-cols-[40px_1fr_1fr] ${commonClass}`;
      content = (
        <>
          <img
            src={org.avatarUrl}
            alt={org.name}
            className="w-6 h-6 rounded-full"
          />
          <p className="text-left">{org.name}</p>
          <p className="text-left">{org.description || "No description"}</p>
        </>
      );
      break;
    }

    case "assignment": {
      const assignment = props.data;
      const assignmentName = assignment.name;
      const amountOfStudents = assignment.amountOfStudents;
      const updatedAt = new Date(assignment.updatedAt).toLocaleString();
      className = `grid grid-cols-[40px_1fr_1fr_1fr] ${commonClass}`;
      content = (
        <>
          <div className="w-6 h-6 rounded-full" />
          <p className="text-left">{assignmentName}</p>
          <p className="text-center">{amountOfStudents}</p>
          <p className="text-left">{updatedAt}</p>
        </>
      );
      break;
    }

    case "repo": {
      const repo = props.data;
      const avatar = repo.collaborators[0]?.avatarUrl || "";
      const students = repo.collaborators[0].name;
      const updatedAt = new Date(repo.updatedAt).toLocaleString();
      className = `grid grid-cols-[40px_1fr_1fr_1fr] ${commonClass}`;
      content = (
        <>
          <img src={avatar} alt="repo" className="w-6 h-6 rounded-full" />
          <p className="text-left">{repo.name}</p>
          <p className="text-center">{students}</p>
          <p className="text-left">{updatedAt}</p>
        </>
      );
      break;
    }

    case "submission": {
      const submission = props.data;
      className = `grid grid-cols-[40px_1fr_1fr_1fr_auto] ${commonClass} text-xs sm:text-sm`;
      content = (
        <>
          <img
            src={submission.studentProfilePicture}
            alt="student"
            className="w-6 h-6 rounded-full"
          />
          <p className="text-center">{submission.studentName}</p>
          <p className="text-center">{submission.submissionStatus}</p>
          <p className="text-center">{submission.currentGrade}</p>
        </>
      );
      break;
    }
  }

  return (
    <div className={className} onClick={props.onClick}>
      {content}
    </div>
  );
}
</file>

<file path="client/src/components/BasicSearchBar.tsx">
import { BiSearch } from "react-icons/bi";
import { RxCross1 } from "react-icons/rx";

interface BasicSearchBarProps {
  value: string;
  onChange: (value: string) => void;
}

export default function BasicSearchBar({
  value,
  onChange,
}: BasicSearchBarProps) {
  return (
    <div className="w-[360px] h-[56px] border border-[#D9D9D9] rounded-full flex items-center px-4">
      <input
        type="text"
        placeholder="Search by repository name or class"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className="flex-grow bg-transparent outline-none text-gray-800 placeholder-gray-500"
      />
      {value ? (
        <button
          onClick={() => onChange("")}
          className="text-gray-500 hover:text-gray-700"
        >
          <RxCross1 size={18} />
        </button>
      ) : (
        <BiSearch className="text-gray-500" size={20} />
      )}
    </div>
  );
}
</file>

<file path="client/src/components/FeedbackViewer.tsx">
import { useEffect, useState } from "react";
import { fetchFeedback } from "../services/feedbackService";

const FeedbackViewer = ({ submissionId }: { submissionId: number }) => {
  const [feedback, setFeedback] = useState<any[]>([]);

  useEffect(() => {
    const load = async () => {
      const data = await fetchFeedback(submissionId);
      setFeedback(data);
    };
    load();
  }, [submissionId]);

  return (
    <div>
      <h3>Feedback</h3>
      {feedback.map((f) => (
        <div key={f.id}>
          <strong>Score:</strong> {f.score}/100
          <p>{f.comments}</p>
        </div>
      ))}
    </div>
  );
};

export default FeedbackViewer;
</file>

<file path="client/src/components/Footer.tsx">
export default function Footer() {
  return (
    <footer className="w-full h-[99px] py-4 border-t border-[#D9D9D9] text-center text-lg text-gray-500">
      Footer
    </footer>
  )
}
</file>

<file path="client/src/components/GetCSVFileButton.tsx">
import { generateCSVFromOrg } from "../utils/generateCSVFromOrg";
import { useGitHub } from "../context/useGitHub";
import UserContext from "../context/UserContext"
import { useContext } from "react";
import { useNavigate } from "react-router-dom";
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";


interface GetCSVFileButtonProps {
  text: string;
  orgName: string | undefined;
  roster?: StudentInStudentRoster[];
  assignmentFilter?: string[];
}

// delete this later
const mockOrgData = {
  org: "Mock University",
  assignments: ["intro-to-data", "java-assignment", "css-intro-assignment"],
  submissions: [
    {
      student: "astronautie",
      grades: {
        "intro-to-data": 20,
        "java-assignment": 10,
        "css-intro-assignment": null,
      },
    },
    {
      student: "FuzzyKala",
      grades: {
        "intro-to-data": 18,
        "java-assignment": null, 
        "css-intro-assignment": null,
      },
    },
    {
      student: "vima20",
      grades: {
        "intro-to-data": 20,
        "java-assignment": 10,
        "css-intro-assignment": 30,
      },
    },
    {
      student: "nonRoster",
      grades: {
        "intro-to-data": null,
        "java-assignment": 15,
        "css-intro-assignment": 25,
      },
    },
  ],
};

export default function GetCSVFileButton({ text, orgName, roster, assignmentFilter }: GetCSVFileButtonProps) {
  const github = useGitHub();
  const navigate = useNavigate();
  const { user } = useContext(UserContext);
  const username = user?.username || "unknownuser";

  const handleClick = async () => {
    if (!orgName) return;
    if (!roster || roster.length === 0) {
      navigate(`/orgs/${orgName}/analytics?tab=missing-submissions`); 
      alert("A roster is required to generate the CSV report. Please upload a roster first.");
      return;
    }
    try {
      // const data = await github.getAllOrganizationData(orgName);
      const data = mockOrgData
      const filteredData = assignmentFilter ? {
        ...data,
        assignments: assignmentFilter,
        submissions: data.submissions.map((s: any) => ({ // change the type of s later
          ...s,
          grades: Object.fromEntries(
            Object.entries(s.grades || {}).filter(([k]) =>
              assignmentFilter.includes(k)
            )
          ),
        })),
      } : data;
      generateCSVFromOrg(filteredData, roster); 
      const response = await fetch("http://localhost:5000/api/csv-reports", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ rows: data,
           username: username }), 
      });
      const result = await response.json();
      if (!response.ok) {
        throw new Error(result.error || "Tallennus epÃ¤onnistui");
      }
      console.log("âœ… Data tallennettu Supabaseen"); 
    } catch (error) {
      console.error("ðŸš« Virhe tallennuksessa:", error);
    }
  };

  return (
    <button
      onClick={handleClick}
      className="flex items-center justify-between border border-[#D9D9D9] px-6 py-3 h-[40px] rounded-full w-fit min-w-[95px] gap-2 bg-[#1D1B20] hover:opacity-90 text-white"
    >
      <span className="text-xs sm:text-sm">{text}</span>
    </button>
  );
}
</file>

<file path="client/src/components/Header.tsx">
interface HeaderProps {
  loggedIn: boolean;
  onClick: () => void;
}

export default function Header({ onClick, loggedIn }: HeaderProps) {
  const text = loggedIn ? "Logout" : "Login";

  return (
    <header className="top-0 left-0 w-full h-[99px] border-b border-[#D9D9D9] px-8 py-8 flex items-center justify-between">
      <div className="flex-shrink-0">
        {/* the logo needs to be added or deleted fully if it's not needed */}
        <img src="/logo.svg" alt="Logo" className="h-full" />
      </div>
      <div className="flex items-center gap-6">
        <span className="text-lg text-[#1E1E1E]">Languages</span>
        <button
          onClick={onClick}
          className="bg-[#1D1B20] w-[148px] text-white text-lg px-4 py-2 rounded-full hover:opacity-90"
        >
          {text}
        </button>
      </div>
    </header>
  );
}
</file>

<file path="client/src/components/SortableHeader.tsx">
import type { SortOption } from "src/utils/sortingUtils";
import { IoIosArrowUp, IoIosArrowDown } from "react-icons/io";
import { FaMinus } from "react-icons/fa6";

export default function SortableHeader({
  label,
  currentSort,
  ascValue,
  descValue,
  onChange,
  center,
}: {
  label: string;
  currentSort: SortOption | undefined;
  ascValue: SortOption;
  descValue: SortOption;
  onChange?: (option: SortOption) => void;
  center?: boolean;
}) {
  const isAsc = currentSort === ascValue;
  const isDesc = currentSort === descValue;
  const isActive = isAsc || isDesc;

  return (
    <button
      onClick={() => {
        if (!onChange) return;
        onChange(isAsc ? descValue : ascValue);
      }}
      className={`flex items-center gap-1 ${center ? "justify-center" : ""}`}
    >
      {label}
      {isActive ? (
        isAsc ? (
          <IoIosArrowUp />
        ) : (
          <IoIosArrowDown />
        )
      ) : (
        <FaMinus className="text-gray-400" />
      )}
    </button>
  );
}
</file>

<file path="client/src/components/SortingButton.tsx">
import { useState } from "react";
import { BiSolidDownArrow } from "react-icons/bi";

interface FilterButtonProps {
  buttonText: string;
  items: string[];
  onSelect?: (value: string) => void;
}

export default function SortingButton({
  buttonText,
  items,
  onSelect,
}: FilterButtonProps) {
  const [isOpen, setIsOpen] = useState(false);
  const toggleDropdown = () => setIsOpen((prev) => !prev);

  const handleSelect = (item: string) => {
    onSelect?.(item);
    setIsOpen(false);
  };

  return (
    <div className="relative inline-block">
      <button
        onClick={toggleDropdown}
        className="flex items-center justify-between border border-[#D9D9D9] px-4 py-3 rounded-full w-fit min-w-[95px] gap-2 h-[56px]"
      >
        <span className="text-xs sm:text-sm text-[#1E1E1E]">{buttonText}</span>
        <BiSolidDownArrow
          className={`w-3 h-3 transition-transform duration-200 ${
            isOpen ? "" : "rotate-180"
          }`}
        />
      </button>
      {isOpen && (
        <ul className="absolute mt-2 w-full bg-white border border-[#D9D9D9] rounded-md shadow-md z-10">
          {items.map((item, index) => (
            <li
              key={index}
              className="px-4 py-2 hover:bg-gray-100 cursor-pointer text-sm text-[#1E1E1E]"
              onClick={() => handleSelect(item)}
            >
              {item}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
</file>

<file path="client/src/components/Spinner.tsx">
export default function Spinner() {
  return (
    <div className="flex items-center justify-center min-h-[200px]">
      <div className="h-8 w-8 animate-spin rounded-full border-4 border-gray-300 border-t-blue-500" />
    </div>
  );
}
</file>

<file path="client/src/components/Tabs.tsx">
import { useState, useEffect } from "react";
import type { ReactNode } from "react";

type Tab = {
  id: string;
  label: string;
  content: ReactNode;
}

type TabsProps = {
  tabs: Tab[];
  activeTab?: string;
  onTabChange?: (tabId: string) => void;
}

export default function Tabs({ tabs, activeTab: controlledTab, onTabChange } : TabsProps) {
  const [activeTab, setActiveTab] = useState(tabs[0].id);

 useEffect(() => {
    if (controlledTab && tabs.some((tab) => tab.id === controlledTab)) {
      setActiveTab(controlledTab);
    }
  }, [controlledTab, tabs]);

  const handleTabClick = (tabId: string) => {
    setActiveTab(tabId);
    onTabChange?.(tabId); 
  };

  return (
    <div className="flex flex-col space-y-4">
      <div className="flex border-b border-gray-200">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            onClick={() => handleTabClick(tab.id)}
            className={`px-4 py-2 text-sm font-medium ${
              activeTab === tab.id
                ? "border-b-2 border-blue-500 text-blue-600"
                : "text-gray-500 hover:text-gray-700"
            }`}
          >
            {tab.label}
          </button>
        ))}
      </div>
      <div>{tabs.find((tab) => tab.id === activeTab)?.content}</div>
    </div>
  );
}
</file>

<file path="client/src/context/GitHubContext.ts">
import { createContext } from "react";
import type { GitHubContextType } from "./types";

const GitHubContext = createContext<GitHubContextType | null>(null);
export default GitHubContext;
</file>

<file path="client/src/context/GitHubProvider.tsx">
import { useMemo } from "react";
import axios from "axios";
import GitHubContext from "./GitHubContext";
import type { GitHubContextType } from "./types";
import type {
  AssignmentInfo,
  OrgInfo,
  RepoInfo,
  CommitInfo,
  CompareCommitsInfo,
} from "@shared/githubInterfaces";

const baseUrl = import.meta.env.VITE_API_BASE_URL;

export const GitHubProvider = ({ children }: { children: React.ReactNode }) => {
  const getOrganizations = async (): Promise<OrgInfo[]> => {
    const res = await axios.get(`${baseUrl}/api/github/orgs`, {
      withCredentials: true,
    });
    return res.data;
  };

  const getAssignments = async (orgName: string): Promise<AssignmentInfo[]> => {
    const res = await axios.get(
      `${baseUrl}/api/github/orgs/${orgName}/assignments`,
      {
        withCredentials: true,
      }
    );
    return res.data;
  };

  const getRepos = async (
    orgName: string,
    assignmentName = ""
  ): Promise<RepoInfo[]> => {
    const res = await axios.get(
      `${baseUrl}/api/github/orgs/${orgName}/assignments/${assignmentName}/repos`,
      { withCredentials: true }
    );
    return res.data;
  };

  const getAllOrganizationData = async (org: string) => {
    const res = await axios.get(`${baseUrl}/api/github/org-report`, {
      withCredentials: true,
      params: { org },
    });
    return res.data;
  };

  const getCommits = async (
    orgName: string,
    repoName: string
  ): Promise<CommitInfo[]> => {
    const res = await axios.get(
      `${baseUrl}/api/github/repos/${orgName}/${repoName}/commits`,
      { withCredentials: true }
    );
    return res.data;
  };

  const getRepoTree = async (
    orgName: string,
    repoName: string
  ): Promise<string[]> => {
    const res = await axios.get(
      `${baseUrl}/api/github/repos/${orgName}/${repoName}/tree`,
      { withCredentials: true }
    );
    return res.data;
  };

  const getFileContents = async (
    orgName: string,
    repoName: string,
    path: string
  ): Promise<string | null> => {
    const res = await axios.get(
      `${baseUrl}/api/github/repos/${orgName}/${repoName}/contents`,
      {
        withCredentials: true,
        params: { path },
      }
    );
    return res.data;
  };

  const compareCommits = async (
    orgName: string,
    repoName: string,
    base: string,
    head: string
  ): Promise<CompareCommitsInfo> => {
    const res = await axios.get(
      `${baseUrl}/api/github/repos/${orgName}/${repoName}/compare/${base}/${head}`,
      { withCredentials: true }
    );
    return res.data;
  };

  const contextValue: GitHubContextType = useMemo(
    () => ({
      getOrganizations,
      getRepos,
      getAllOrganizationData,
      getAssignments,
      getCommits,
      getRepoTree,
      getFileContents,
      compareCommits,
    }),
    []
  );

  return (
    <GitHubContext.Provider value={contextValue}>
      {children}
    </GitHubContext.Provider>
  );
};
</file>

<file path="client/src/context/types.ts">
import type {
  OrgInfo,
  AssignmentInfo,
  RepoInfo,
  User,
  CommitInfo,
  CompareCommitsInfo,
} from "@shared/githubInterfaces";

export interface GitHubContextType {
  getOrganizations: () => Promise<OrgInfo[]>;
  getAssignments: (orgLogin: string) => Promise<AssignmentInfo[]>;
  getRepos: (org: string, assignmentPrefix?: string) => Promise<RepoInfo[]>;
  getAllOrganizationData: (org: string) => Promise<any>;
  getCommits: (orgName: string, repoName: string) => Promise<CommitInfo[]>;
  getRepoTree: (orgName: string, repoName: string) => Promise<string[]>;
  getFileContents: (
    orgName: string,
    repoName: string,
    path: string
  ) => Promise<string | null>;
  compareCommits: (
    orgName: string,
    repoName: string,
    base: string,
    head: string
  ) => Promise<CompareCommitsInfo>;
}

export interface UserContextType {
  user: User | null;
  isLogin: boolean;
  refreshUser: () => Promise<void>;
  logout: () => Promise<void>;
  login: () => string;
}
</file>

<file path="client/src/context/useGitHub.ts">
import { useContext } from "react";
import GitHubContext from "./GitHubContext";
import type { GitHubContextType } from "./types";

export const useGitHub = (): GitHubContextType => {
  const context = useContext(GitHubContext);

  if (!context) {
    throw new Error("useGitHub must be used within a GitHubProvider");
  }
  return context;
};
</file>

<file path="client/src/context/UserContext.ts">
// Declares the context object only
import { createContext } from "react";
import type { UserContextType } from "../types/UserInfo";

const UserContext = createContext<UserContextType | undefined>(undefined);
export default UserContext;
</file>

<file path="client/src/context/UserProvider.tsx">
// Provides state and logic (data + functions)
import { useEffect, useState, useMemo } from "react";
import axios from "axios";
import UserContext from "./UserContext";
import type { UserContextType } from "./types";
import type { User } from "@shared/githubInterfaces";

const baseUrl = import.meta.env.VITE_API_BASE_URL;

export const UserProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);

  const refreshUser = async () => {
    try {
      const res = await axios.get(`${baseUrl}/api/auth/getCurrentUser`, {
        withCredentials: true,
      });
      setUser(res.data.user || null);
    } catch {
      setUser(null);
    }
  };

  const login = () => {
    return `${baseUrl}/api/auth/login`;
  };

  const logout = async () => {
    await axios.get(`${baseUrl}/api/auth/logout`, { withCredentials: true });
    setUser(null);
  };

  useEffect(() => {
    refreshUser();
  }, []);

  const contextValue: UserContextType = useMemo(
    () => ({
      user,
      isLogin: !!user,
      refreshUser,
      logout,
      login,
    }),
    [user]
  );

  return (
    <UserContext.Provider value={contextValue}>{children}</UserContext.Provider>
  );
};
</file>

<file path="client/src/context/useUser.ts">
// Exports the custom hook for using the context
import { useContext } from "react";
import UserContext from "./UserContext";
import type { UserContextType } from "../types/UserInfo";

export const useUser = (): UserContextType => {
  const context = useContext(UserContext);

  if (!context) {
    throw new Error("useUser must be used within a UserProvider");
  }
  return context;
};
</file>

<file path="client/src/hooks/useFilteredList.ts">
import { useMemo } from "react";

export function useFilteredList<T>(
  list: T[] = [],
  searchTerm: string,
  predicate: (item: T, searchTerm: string) => boolean
): T[] {
  return useMemo(() => {
    return list.filter((item) => predicate(item, searchTerm));
  }, [list, searchTerm, predicate]);
}
</file>

<file path="client/src/index.css">
@import "tailwindcss";
</file>

<file path="client/src/layouts/MainLayout.tsx">
import { Outlet, useNavigate, useLocation } from "react-router-dom";
import { useEffect } from "react";
import Header from "../components/Header";
import Footer from "../components/Footer";
import { useUser } from "../context/useUser";

export default function MainLayout() {
  const { user, isLogin, refreshUser, logout, login } = useUser();

  const navigate = useNavigate();
  const location = useLocation();

  useEffect(() => {
    const checkAndRedirect = async () => {
      await refreshUser?.();
      if (user && location.pathname === "/") {
        navigate("/orgs");
      }
    };
    checkAndRedirect();
  }, [refreshUser, navigate, user, location.pathname]);

  const handleHeaderButtonClick = async () => {
    if (isLogin) {
      await logout?.();
      navigate("/");
    } else {
      const loginUrl = login?.();
      if (loginUrl) {
        window.location.href = loginUrl;
      }
    }
  };

  return (
    <div className="flex flex-col min-h-screen">
      <Header loggedIn={!!isLogin} onClick={handleHeaderButtonClick} />
      <main className="flex-1 flex justify-center items-start">
          <div className="w-full max-w-screen-xl">
            <Outlet />
          </div>
      </main>
      <Footer />
    </div>
  );
}
</file>

<file path="client/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="client/src/pages/analyticsPage/AnalyticsPage.tsx">
import { useParams, useSearchParams } from "react-router-dom";
import { useEffect, useState, useMemo } from "react";
import { useGitHub } from "../../context/useGitHub";
import type { OrgReport } from "src/types/OrgReport";
import BackButton from "../../components/BackButton";
import BasicHeading from "../../components/BasicHeading";
import AveragePointsChart from "./averageAssignmentPointsTab/AveragePointsChart";
import MissingSubmissionsList from "./missingSubmissionsTab/MissingSubmissionsTab";
import Spinner from "../../components/Spinner";
import CommonIssuesTab from "./commonIssuesTab/CommonIssuesTab";
import Tabs from "../../components/Tabs";

// delete this later
const mockOrgData = {
  org: "Mock University",
  assignments: ["intro-to-data", "java-assignment", "css-intro-assignment"],
  submissions: [
    {
      student: "astronautie",
      grades: {
        "intro-to-data": 20,
        "java-assignment": 10,
        "css-intro-assignment": null,
      },
    },
    {
      student: "FuzzyKala",
      grades: {
        "intro-to-data": 18,
        "java-assignment": null, 
        "css-intro-assignment": null,
      },
    },
    {
      student: "vima20",
      grades: {
        "intro-to-data": 20,
        "java-assignment": 10,
        "css-intro-assignment": 30,
      },
    },
    {
      student: "nonRoster",
      grades: {
        "intro-to-data": null,
        "java-assignment": 15,
        "css-intro-assignment": 25,
      },
    },
  ],
};

// TODO: get this from github with real values (preferably with the OrgData and not separately)
const maxPointsPerAssignment = {
  "intro-to-data": 20,
  "java-assignment": 15,
  "css-intro-assignment": 30,
}

// TODO: get the real issues from the database(?)
const mockAssignmentData = [
  {
    assignmentName: "Assignment 1",
    issues: ["Repeating code", "Another issue", "Another issue", "Poor Naming", "Poor Naming", "Poor Naming", "Poor Naming"],
  },
  {
    assignmentName: "Assignment 2",
    issues: ["Bad logic", "Poor Naming", "Poor Naming", "Poor Naming", "Repeating Code", "No imports", "No imports"],
  },
  {
    assignmentName: "Assignment 3",
    issues: ["Bad logic", "Poor naming", "Bad logic", "Poor naming", "Poor naming", "Repeating code"],
  },
  {
    assignmentName: "Assignment 4",
    issues: ["Bad logic", "Poor naming", "Poor naming"],
  },
];

export default function AnalyticsPage() {
  const { orgName } = useParams<{ orgName: string }>();
  const github = useGitHub();
  const [orgData, setOrgData] = useState<OrgReport | null>(null);
  const [loading, setLoading] = useState(true);
  const [searchParams, setSearchParams] = useSearchParams();

  const activeTab = searchParams.get("tab") || "average-points";

  useEffect(() => {
    const fetchOrgData = async () => {
      if (!orgName) return;
      try {
        const data = await github.getAllOrganizationData(orgName);
        setOrgData(data);
      } catch (error) {
        console.error("Failed to fetch org data:", error);
      } finally {
        setLoading(false);
      }
    };
    fetchOrgData();
  }, [orgName, github]);

  function onTabChange(tabId: string) {
    const assignment = searchParams.get("assignment");
    const params = new URLSearchParams();
    params.set("tab", tabId);
    if (tabId === "missing-submissions" && assignment) {
      params.set("assignment", assignment);
    }
    setSearchParams(params);
  }

  const tabs = useMemo(
    () => [
      {
        id: "average-points",
        label: "Average Assignment Points",
        content: (
          <AveragePointsChart
            orgData={mockOrgData}
            maxPointsPerAssignment={maxPointsPerAssignment}
          />
        ),
      },
      {
        id: "common-issues",
        label: "Common Issues",
        content: (
          <CommonIssuesTab assignmentFeedbacks={mockAssignmentData} />
        ),
      },
      {
        id: "missing-submissions",
        label: "Missing Submissions",
        content: <MissingSubmissionsList orgData={mockOrgData} />,
      },
    ],[]
  );

  return (
    <div className="flex flex-col space-y-10 p-4 md:p-12"> 
      <div className="flex flex-col space-y-6">
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4"> 
          <div className="flex space-x-4">
            <BackButton to={`/orgs/${orgName}/assignments`}/>
            <BasicHeading heading={`Analytics for ${orgName}`} /> 
          </div>
        </div>
        <div>
          {loading ? (
            <Spinner />
          ) : !orgData ? (
            <div className="p-4">No organization data found.</div>
          ) : (
            <Tabs tabs={tabs} activeTab={activeTab} onTabChange={onTabChange} />
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/analyticsPage/averageAssignmentPointsTab/AveragePointsChart.tsx">
import { Bar } from 'react-chartjs-2';
import type { OrgReport } from 'src/types/OrgReport';
import { Chart as ChartJS, CategoryScale, LinearScale, BarElement, Tooltip, Title, Legend } from 'chart.js';

ChartJS.register(CategoryScale, LinearScale, BarElement, Tooltip, Title, Legend);

type AverageGradeChartProps = {
  orgData: OrgReport;
  maxPointsPerAssignment: { [assignmentName: string]: number };
};

export default function AveragePointsChart({ orgData, maxPointsPerAssignment }: AverageGradeChartProps) {
  const labels = orgData.assignments;

  const averages = orgData.assignments.map((assignment) => {
    const maxPoints = maxPointsPerAssignment[assignment];
    if (!maxPoints || maxPoints === 0) return 0;
    const percentages = orgData.submissions.map((s) => {
      const grade = s.grades[assignment];
      return typeof grade === 'number' ? (grade / maxPoints) * 100 : null;
    }).filter((g): g is number => g !== null);

    const average = percentages.length
      ? percentages.reduce((a, b) => a + b, 0) / percentages.length
      : 0;

    return average.toFixed(2);
  });

  const data = {
    labels,
    datasets: [
      {
        label: 'Average % of Points',
        data: averages,
        backgroundColor: 'rgba(75, 192, 192, 0.6)',
        borderRadius: 4,
      },
    ],
  };

  const options = {
    responsive: true,
    plugins: {
      legend: {
        display: false,
      },
      title: {
        display: true,
        text: 'Average Percentage of Points per Assignment',
      },
    },
    scales: {
      y: {
        beginAtZero: true,
        max: 100, 
        ticks: {
          callback: (value: number | string ) => `${value}%`,
        },
      },
    },
  };

  return (<Bar data={data} options={options} />)
}
</file>

<file path="client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesCard.tsx">
import type { SingleAssignmentFeedback } from "src/types/AssignmentFeedback";

type CommonIssuesCardProps = {
  assignment: SingleAssignmentFeedback;
};

export default function CommonIssuesCard({ assignment } : CommonIssuesCardProps) {
  return (
    <div className="pl-3 pb-3">
      <h2 className=" text-gray-700 mb-2">Common issues in {assignment.assignmentName}</h2>
      <ul className="list-disc list-inside text-gray-700">
        {[...new Set(assignment.issues)].map((issue, index) => (
          <li key={index}>{issue}</li>
        ))}
      </ul>
    </div>
  );
}
</file>

<file path="client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesChart.tsx">
import type { SingleAssignmentFeedback } from 'src/types/AssignmentFeedback';
import { Bar } from 'react-chartjs-2';

type CommonIssuesChartProps = {
  assignment: SingleAssignmentFeedback;
};

export default function CommonIssuesChart({ assignment }: CommonIssuesChartProps) {
  const allIssues: string[] = assignment.issues;

  const issueCounts = allIssues.reduce<Record<string, number>>((acc, issue) => {
    acc[issue] = (acc[issue] || 0) + 1;
    return acc;
  }, {});

  const labels = Object.keys(issueCounts);
  const dataValues = Object.values(issueCounts);

  const data = {
    labels,
    datasets: [
      {
        label: 'Number of Students',
        data: dataValues,
        backgroundColor: 'rgba(255, 99, 132, 0.6)',
        borderRadius: 4,
      },
    ],
  };

  const options = {
    responsive: true,
    plugins: {
      legend: { display: false },
      title: { display: true, text: 'Common Issues Across Submissions' },
    },
    scales: {
      y: {
        beginAtZero: true,
        title: {
          display: true,
          text: 'Number of Occurences',
        },
        ticks: {
          stepSize: 1,
        },
      },
    },
  };

  return (
    <div className="p-3">
      <Bar data={data} options={options}/> 
    </div>
  );
}
</file>

<file path="client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesCollapsible.tsx">
import { useState } from "react";
import { FaChevronDown, FaChevronUp } from "react-icons/fa";
import CommonIssuesCard from "./CommonIssuesCard";
import type { SingleAssignmentFeedback } from "src/types/AssignmentFeedback";
import CommonIssuesChart from "./CommonIssuesChart";

type CommonIssuesCollapsibleProps = {
  assignment: SingleAssignmentFeedback;
};

export default function CommonIssuesCollapsible({ assignment }: CommonIssuesCollapsibleProps) {
  const [isOpen, setIsOpen] = useState(false);

  return (
     <div className="border-b border-[#D9D9D9]">
      <button
        onClick={() => setIsOpen((prev) => !prev)}
        className="w-full flex justify-between items-center text-left font-semibold text-gray-700 p-3 text-lg"
      >
        <span>{assignment.assignmentName}</span>
        {isOpen ? <FaChevronUp size={15} /> : <FaChevronDown size={15} />}
      </button>

      {isOpen && (
        <div>
            <CommonIssuesCard assignment={assignment} />
            <CommonIssuesChart assignment={assignment}/>
        </div>
      )}
    </div>
  )
}
</file>

<file path="client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesTab.tsx">
import type { AssignmentFeedbacks } from "src/types/AssignmentFeedback";
import CommonIssuesCollapsible from "./CommonIssuesCollapsible";

type CommonIssuesTabProps = {
  assignmentFeedbacks: AssignmentFeedbacks;
};

export default function CommonIssuesTab({ assignmentFeedbacks }: CommonIssuesTabProps) {
  return (
    <div>
      {assignmentFeedbacks.map((assignment, index) => (
        <CommonIssuesCollapsible key={index} assignment={assignment} />
      ))}
    </div>
  );
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/MissingSubmissionsTab.tsx">
import { useEffect, useState } from "react";
import UploadStudentRosterCSVButton from "./UploadStudentRosterCSVButton";
import Subtext from "./Subtext";
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";
import type { OrgReport } from "src/types/OrgReport";
import { useParams, useSearchParams } from "react-router-dom";
import StudentTableWithTabs from "./studentTable/StudentTableWithTabs";

type MissingSubmissionsTabProps = {
  orgData: OrgReport;
};

export default function MissingSubmissionsTab({ orgData }: MissingSubmissionsTabProps) {
  const [roster, setRoster] = useState<StudentInStudentRoster[]>([]);
  const { orgName } = useParams<{ orgName: string }>();
  const [searchParams] = useSearchParams();
  const selectedAssignment = searchParams.get("assignment") || "all";
  
  useEffect(() => {
    const fetchRoster = async () => {
      if (!orgName) return;
      try {
        // TODO: get the roster from the database
        const fetchedRoster = "" // await db.getStudentRoster(orgName); 
        setRoster(fetchedRoster || []);
      } catch (error) {
        console.error("Failed to fetch student roster:", error);
      }
    };

    fetchRoster();
  }, [orgName]); 

  return (
    <div>
      {roster.length === 0 ? (
        <div className="flex flex-col gap-y-6 items-center">
            <Subtext text={`Note: GitHubâ€™s API does not currently support fetching student rosters. To view missing submissions, please upload a roster manually. You can download your class roster from GitHub Classroom under the "Students" section.`} />
            <UploadStudentRosterCSVButton text="Upload Student Roster CSV" onUpload={setRoster}/>
        </div>
      ) : (
        <div className="flex flex-col gap-y-2">
          <div className="flex justify-between items-center">
            <Subtext text="Note: Student names and GitHub usernames are only visible once at least one assignment has been accepted."/>
            <UploadStudentRosterCSVButton text="Update Student Roster CSV" onUpload={setRoster}/>
          </div>
          {roster.length > 0 && (
            <StudentTableWithTabs roster={roster} orgData={orgData} selectedTab={selectedAssignment} orgName={orgName}/>
          )}
        </div>
      )}
    </div>
  )
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTable.tsx">
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";
import type { OrgReport } from "src/types/OrgReport";
import GetCSVFileButton from "../../../../components/GetCSVFileButton";
import StudentTableHeader from "./StudentTableHeader";
import StudentTableRow from "./StudentTableRow";

type StudentTableProps = {
  roster: StudentInStudentRoster[]; 
  orgData: OrgReport;
  assignmentFilter?: string[];
  orgName?: string;
};

export default function StudentTable({ roster, orgData, assignmentFilter, orgName }: StudentTableProps) {
  const submissions = orgData.submissions; 
  const submissionMap = new Map(submissions.map(s => [s.student, s]));
  const assignmentNames = assignmentFilter ?? orgData.assignments;

  const studentsInRoster = roster.map((student) => {
    const submission = submissionMap.get(student.github_username);
    const grades = assignmentNames.map((assignment) => {
      const value = submission?.grades?.[assignment];
      if (value === null || value === undefined) return "N/A";
      if (typeof value === "number") return value;
      return "Error";
    });

    const numericGrades = grades.filter(g => typeof g === "number") as number[];
    const totalPoints = numericGrades.length > 0 ? numericGrades.reduce((a, b) => a + b, 0) : "â€”";
    const submissionCount = numericGrades.length;

    return {
      ...student,
      grades,
      totalPoints,
      submissionCount,
    };
  });

  const sortedStudents = [...studentsInRoster].sort(
   (a, b) => a.submissionCount - b.submissionCount
  );

  return (
    <div>
      <div className="p-2 flex justify-end">
        <GetCSVFileButton 
          text={`Export ${assignmentFilter && assignmentFilter.length === 1 ? assignmentFilter[0] : "All Assignments"} CSV`}
          orgName={orgName}
          roster={roster}
          assignmentFilter={assignmentFilter}
        />
      </div>
    <table className="table-auto border rounded-lg border-gray-300 bg-white w-full text-sm text-left">
      <StudentTableHeader assignmentNames={assignmentNames}/>
      <tbody>
        {sortedStudents.map((student) => (
          <StudentTableRow studentInfo={student} assignmentNames={assignmentNames} />
        ))}
    </tbody>
   </table>
   </div>
  );
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTableHeader.tsx">
type StudentTableHeaderProps = {
  assignmentNames: string[];
};

export default function StudentTableHeader({ assignmentNames }: StudentTableHeaderProps) {
  return (
    <thead>
      <tr>
        <th className="border border-gray-700 px-4 py-2 font-medium">Name</th>
        <th className="border border-gray-700 px-4 py-2 font-medium">GitHub Username</th>
        <th className="border border-gray-700 px-4 py-2 font-medium">Roster Identifier</th>
        {assignmentNames.map((assignment) => (
          <th key={assignment} className="border border-gray-700 px-4 py-2 font-medium">
            {assignment}
          </th>
        ))}
        <th className="border border-gray-700 px-4 py-2 font-medium">Total Points</th>
      </tr>
    </thead>
  );
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTableRow.tsx">
import type { StudentInfo } from "src/types/StudentInfo";

type StudentTableRowProps = {
  studentInfo: StudentInfo;
  assignmentNames: string[]
};

export default function StudentTableRow({ studentInfo, assignmentNames }: StudentTableRowProps) {
  const { name, github_username, identifier, grades, totalPoints, submissionCount } = studentInfo;

  const rowClass =
    submissionCount === 0 ? "bg-red-100" :
    submissionCount < assignmentNames.length ? "bg-yellow-100" :
    "bg-green-100";

  return (
    <tr key={identifier} className={rowClass}>
      <td className="border border-gray-700 px-4 py-2">{name?.trim() || "N/A"}</td>
      <td className="border border-gray-700 px-4 py-2">{github_username?.trim() || "N/A"}</td>
      <td className="border border-gray-700 px-4 py-2">{identifier}</td>
      {grades.map((grade, idx) => (
        <td key={idx} className="border border-gray-700 px-4 py-2 text-center">{grade}</td>
      ))}
      <td className="border border-gray-700 px-4 py-2 text-center">{totalPoints}</td>
    </tr>
  );
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTableWithTabs.tsx">
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";
import { useSearchParams } from "react-router-dom";
import type { OrgReport } from "src/types/OrgReport";
import StudentTable from "./StudentTable";
import Tabs from "../../../../components/Tabs";

type StudentTableWithTabsProps = {
  roster: StudentInStudentRoster[];
  orgData: OrgReport;
  selectedTab: string;
  orgName?: string;
};

export default function StudentTableWithTabs({ roster, orgData, selectedTab, orgName }: StudentTableWithTabsProps) {
  const [searchParams, setSearchParams] = useSearchParams();

  const handleTabChange = (tabId: string) => {
    const params = new URLSearchParams(searchParams);
    params.set("assignment", tabId); 
    console.log(orgName + " " + orgData)
    setSearchParams(params);
  };

  const allAssignments = orgData.assignments;

  const tabs = [
    {
      id: "all",
      label: "All Submissions",
      content: <StudentTable roster={roster} orgData={orgData} orgName={orgName}/>
    },
    ...allAssignments.map((assignmentName) => ({
      id: assignmentName,
      label: assignmentName,
      content: (
        <StudentTable
          roster={roster}
          orgData={orgData}
          assignmentFilter={[assignmentName]}
          orgName={orgName}
        />
      )
    }))
  ];

  return (
    <div className="mt-4">
        <Tabs tabs={tabs} activeTab={selectedTab} onTabChange={handleTabChange}/>
    </div>
  );
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/Subtext.tsx">
interface SubtextProps {
  text: string;
}

export default function Subtext({ text }: SubtextProps) {
  return (
    <div>
        <p className="text-[16px]">{text}</p>
    </div>
  )
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/UploadStudentRosterCSVButton.tsx">
import { useRef } from "react";
import Papa from "papaparse";
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";
import { useParams } from "react-router-dom";

type UploadStudentRosterCSVButtonProps = {
  text: string,
  onUpload: (students: StudentInStudentRoster[]) => void;
};

// TODO: once we have access to database, save (or update if a new roster is provided) uploaded roster for specific organization there
export default function UploadStudentRosterCSVButton({ text, onUpload }: UploadStudentRosterCSVButtonProps) {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { orgName } = useParams<{ orgName: string }>();

  const handleClick = () => {
    fileInputRef.current?.click();
  };

  const saveRosterToDB = async (roster: StudentInStudentRoster[]) => {
    if (!orgName) return;
    try {
      const response = await fetch(`/api/orgs/${orgName}/roster`, {
        method: "POST", // in backend if a roster already exists for the specific org, update it instead of posting it (use same backend function for both though)
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ roster }),
      });

      if (!response.ok) {
        throw new Error(`Failed to save roster: ${response.statusText}`);
      }
    } catch (error) {
      console.error("Error saving roster to DB:", error);
    }
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    Papa.parse<StudentInStudentRoster>(file, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => {
        const expectedHeaders = ["identifier", "github_username", "github_id", "name"];
        const actualHeaders = results.meta.fields;
        const headersValid = actualHeaders && expectedHeaders.length === actualHeaders.length && expectedHeaders.every((h, i) => h === actualHeaders[i]);
        if (!headersValid) {
          console.error("Invalid CSV format. Expected headers:", expectedHeaders, "but got:", actualHeaders);
          alert("Invalid CSV format. Header row must exactly match: identifier,github_username,github_id,name");
          return;
        }
        const validStudents = results.data.filter((s) => s.identifier);
        onUpload(validStudents);
        (async () => {await saveRosterToDB(validStudents);})();
      },
      error: (err) => {
        console.error("CSV parsing error:", err);
      },
    });
    event.target.value = "";
  };

  return (
    <div>
      <button onClick={handleClick} className="flex items-center justify-between border border-[#D9D9D9] px-6 py-3 h-[40px] rounded-full w-fit min-w-[95px] gap-2 bg-[#1D1B20] hover:opacity-90 text-white">
        {text}
      </button>
      <input
        ref={fileInputRef}
        type="file"
        accept=".csv"
        onChange={handleFileChange}
        className="hidden"
      />
    </div>
  )
}
</file>

<file path="client/src/pages/assignmentPage/AssignmentsPage.tsx">
import BasicHeading from "../../components/BasicHeading";
import BasicList from "../../components/basicList/BasicList";
import BasicSearchBar from "../../components/BasicSearchBar";
import { useEffect, useState } from "react";
import { useGitHub } from "../../context/useGitHub";
import { useParams, useNavigate } from "react-router-dom";
import type { AssignmentInfo } from "@shared/githubInterfaces";
import { useFilteredList } from "../../hooks/useFilteredList";
import BackButton from "../../components/BackButton";
import BasicButton from "../../components/BasicButton";
import { sortData } from "../../utils/sortingUtils";
import type { SortOption } from "../../utils/sortingUtils";
import Sidebar from "./sidebar/Sidebar";
import Spinner from "../../components/Spinner";
import GetCSVFileButton from "../../components/GetCSVFileButton";

const allAssignments = [
  {
    name: "Assignment 1",
    submitted: 5,
    accepted: 5,
    total: 10,
    deadline: new Date('2025-04-01T23:59:59Z'),
  },
  {
    name: "Assignment 2",
    submitted: 10,
    accepted: 10,
    total: 10,
    deadline: new Date('2025-05-01T23:59:59Z'),
  },
  {
    name: "Assignment 3",
    submitted: 7,
    accepted: 8,
    total: 10,
    deadline: new Date('2025-06-01T23:59:59Z'),
  },
  {
    name: "Assignment 4",
    submitted: 3,
    accepted: 4,
    total: 10,
    deadline: new Date('2025-04-01T23:59:59Z'),
  },
  {
    name: "Assignment 5",
    submitted: 10,
    accepted: 10,
    total: 10,
    deadline: new Date('2025-04-10T23:59:59Z'),
  },
  {
    name: "Assignment 6",
    submitted: 6,
    accepted: 8,
    total: 10,
    deadline: new Date('2025-06-10T23:59:59Z'),
  },
];

export default function AssignmentsPage() {
  const { orgName } = useParams<{ orgName: string }>();
  const [assignments, setAssignments] = useState<AssignmentInfo[]>([]);
  const github = useGitHub();
  const navigate = useNavigate();
  const [searchTerm, setSearchTerm] = useState("");
  const [loading, setLoading] = useState(true);
  const [sortOrder, setSortOrder] = useState<SortOption>("Newest");

  const filteredAssignments = useFilteredList(
    assignments,
    searchTerm,
    (a, term) => a.name.toLowerCase().includes(term.toLowerCase())
  );

  const handleAnalyticsClick = () => {
    if (orgName) {
      navigate(`/orgs/${orgName}/analytics`);
    }
  };

  const sortedAssignments = sortData(filteredAssignments, sortOrder);

  useEffect(() => {
    if (orgName) {
      github
        .getAssignments(orgName)
        .then(setAssignments)
        .catch(console.error)
        .finally(() => setLoading(false));
    }
  }, [orgName, github]);

  return (
    <div className="flex flex-row min-h-screen">
      <Sidebar assignments={allAssignments}/>
      <div className="flex-1 flex justify-center"> 
      <div className="flex flex-col space-y-10 pr-4 pt-4 md:pr-12 md:pt-12 pl-0">
        <div className="flex flex-col space-y-6">
          <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
            <div className="flex space-x-4">
              <BackButton to="/orgs" />
              <BasicHeading heading={`Assignments in ${orgName}`} />
            </div>
            <div className="flex space-x-4">
              <BasicSearchBar value={searchTerm} onChange={setSearchTerm} />
            </div>
          </div>
          <div className="flex flex-col md:flex-row md:items-center md:justify-end gap-4">
            <BasicButton text="Go To Analytics Page" onClick={handleAnalyticsClick}/>
            <GetCSVFileButton text={"Export CSV Report"} orgName={orgName}/>
          </div>
        </div>
        {loading ? (
          <Spinner />
        ) : (
          <BasicList
            type="assignment"
            items={sortedAssignments}
            orgName={orgName!}
            isLoading={loading}
            sortOrder={sortOrder}
            onSortChange={setSortOrder}
          />
        )}
      </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/assignmentPage/sidebar/ProgressBar.tsx">
interface ProgressBarProps {
  progress: number; // 0 to 100
}

export default function ProgressBar({ progress }: ProgressBarProps) {

  // commonted out for now, would normally give more colours
  /*let bgColor = "bg-red-500";
  if (progress >= 70) {
    bgColor = "bg-green-500";
  } else if (progress >= 40) {
    bgColor = "bg-yellow-400";
  }*/

  let bgColor = "bg-black"

  return (
     <div className="w-full bg-gray-200 rounded-full h-4 overflow-hidden">
      <div
        className={`${bgColor} h-full transition-all duration-300`}
        style={{ width: `${progress}%` }}
      />
    </div>
  )
}
</file>

<file path="client/src/pages/assignmentPage/sidebar/Sidebar.tsx">
import { useState } from 'react';
import { useParams } from 'react-router-dom';
import SidebarButton from './SidebarButton';
import SidebarCard from './SidebarCard';
import SidebarPagination from './SidebarPagination';

type RosterAndOrgDataAssignmentInfo = {
  name: string;
  submitted: number;
  accepted: number;
  total: number;
  deadline: Date;
};

interface SidebarProps {
  assignments: RosterAndOrgDataAssignmentInfo[];
} 

export default function Sidebar({ assignments } : SidebarProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  const { orgName } = useParams<{ orgName: string }>();

  const sortedAssignments = [...assignments].sort((a, b) => {
    const now = new Date();
    const getRank = (assignment: RosterAndOrgDataAssignmentInfo) => {
      const isOverdue = assignment.deadline <= now;
      const isComplete = assignment.submitted >= assignment.total;
      if (isOverdue && !isComplete) return 0; // Highest priority 
      if (!isOverdue && !isComplete) return 1; // Second priority
      return 2; // Lowest priority (Completed)
    };
    const rankA = getRank(a);
    const rankB = getRank(b);
    if (rankA !== rankB) return rankA - rankB; 
    return a.deadline.getTime() - b.deadline.getTime();
  });

  const totalPages = Math.ceil(assignments.length / 3);
  const startIndex = (currentPage - 1) * 3;
  const currentAssignments = sortedAssignments.slice(startIndex, startIndex + 3);

  return (
    <>
      <SidebarButton isOpen={isOpen} toggle={() => setIsOpen(!isOpen)}/>
      <div 
        className={`fixed top-0 left-0 h-full w-64 bg-white p-4 md:pt-12 md:pl-12 transform transition-transform duration-300 z-40
        ${isOpen ? 'translate-x-0' : '-translate-x-full'} md:translate-x-0 md:static md:block`}
      >
        <h2 className="text-xl font-bold mb-4">Classroom Info</h2>
        {currentAssignments.map((assignment) => (
          <SidebarCard 
            key={assignment.name}
            name={assignment.name}
            acceptedAssignments={assignment.accepted}
            submittedAssignments={assignment.submitted}
            totalAssignments={assignment.total}
            assignmentDeadline={assignment.deadline}
            linkTo={`/orgs/${orgName}/analytics?tab=missing-submissions&assignment=${encodeURIComponent(assignment.name)}`}
          />
        ))}
        <SidebarPagination 
          totalPages={totalPages}
          currentPage={currentPage}
          onPageChange={setCurrentPage}
        />
      </div>

      {isOpen && (
        <div
          className="fixed inset-0 bg-black opacity-50 z-30 md:hidden"
          onClick={() => setIsOpen(false)}
        ></div>
      )}
    </>
  );
}
</file>

<file path="client/src/pages/assignmentPage/sidebar/SidebarButton.tsx">
import { BiMenu, BiX } from 'react-icons/bi';

interface SidebarButtonProps {
  isOpen: boolean; 
  toggle: () => void;
}

export default function SidebarButton({ isOpen, toggle }: SidebarButtonProps) {
  return (
    <button
        className="md:hidden p-4"
        onClick={toggle}
        aria-label="Toggle Sidebar"
        >
        {isOpen ? <BiX size={24} /> : <BiMenu size={24} />}
    </button>
  )
}
</file>

<file path="client/src/pages/assignmentPage/sidebar/SidebarCard.tsx">
import { useNavigate } from "react-router-dom";
import ProgressBar from './ProgressBar';

interface SidebarCardProps {
  name: string;
  acceptedAssignments: number
  submittedAssignments: number;
  totalAssignments: number;
  assignmentDeadline: Date;
  linkTo: string;
}

export default function SidebarCard({name, acceptedAssignments, submittedAssignments, totalAssignments, assignmentDeadline, linkTo }: SidebarCardProps) {
  const navigate = useNavigate();
  const now = new Date();
  const hasDeadlinePassed = assignmentDeadline.getTime() < now.getTime();

  const deadlineInfo = () => {
    const diff = assignmentDeadline.getTime() - now.getTime();
    if (diff > 0) {
      return `Deadline: ${assignmentDeadline.toLocaleDateString('en-GB', {day: '2-digit', month: '2-digit', year: 'numeric'})}`;
    } else {
      const msAgo = now.getTime() - assignmentDeadline.getTime();
      const daysAgo = Math.floor(msAgo / (1000 * 60 * 60 * 24));
      if (daysAgo < 1) {
        const hoursAgo = Math.floor(msAgo / (1000 * 60 * 60));
        if (hoursAgo < 1) {
          const minutesAgo = Math.floor(msAgo / (1000 * 60));
          return `Deadline passed ${minutesAgo} minute${minutesAgo !== 1 ? 's' : ''} ago`;
        }
        return `Deadline passed ${hoursAgo} hour${hoursAgo !== 1 ? 's' : ''} ago`;
      }
      return `Deadline passed ${daysAgo} day${daysAgo !== 1 ? 's' : ''} ago`;
    }
  };

  const progressOfAcceptedAssignments = totalAssignments > 0
    ? Math.round((acceptedAssignments / totalAssignments) * 100)
    : 0;
  
  const progressOfSubmittedAssignments = totalAssignments > 0
    ? Math.round((submittedAssignments / totalAssignments) * 100)
    : 0;

  return (
    <div onClick={() => navigate(linkTo)} className="border border-[#D9D9D9] rounded p-3 mb-2 space-y-2 cursor-pointer hover:bg-gray-100 active:bg-gray-200 transition-colors">
      <div>
        <h3 className="font-semibold text-gray-700">{name}</h3>
        <text className={`text-sm ${hasDeadlinePassed && progressOfSubmittedAssignments < 100? 'text-red-600 font-medium' : 'text-gray-600'}`}>{deadlineInfo()}</text>
      </div>           
      <div className="flex flex-col gap-1">
        <span className="text-sm">Assignments Accepted</span>
        <ProgressBar progress={progressOfAcceptedAssignments} />
      </div>
      <div className="flex flex-col gap-1">
        <span className="text-sm">Assignments Submitted</span>
        <ProgressBar progress={progressOfSubmittedAssignments} />
      </div>
    </div>
  )
}
</file>

<file path="client/src/pages/assignmentPage/sidebar/SidebarPagination.tsx">
interface SidebarPaginationProps {
  totalPages: number;
  currentPage: number;
  onPageChange: (page: number) => void;
}

export default function SidebarPagination({ totalPages, currentPage, onPageChange }: SidebarPaginationProps) {
  return (
    <div className="mt-4 flex justify-center gap-2">
      {Array.from({ length: totalPages }, (_, index) => (
        <button
          key={index}
          onClick={() => onPageChange(index + 1)}
          className={`px-3 py-1 rounded text-sm font-medium border ${
            currentPage === index + 1
              ? 'bg-black text-white'
              : 'bg-white text-black border-gray-300'
            }`}
            >
          {index + 1}
        </button>
      ))}
    </div>
  )
}
</file>

<file path="client/src/pages/loginPage/LoginButton.tsx">
import { FaGithub } from 'react-icons/fa';

interface LoginButtonProps {
  onClick: () => void;
}

export default function LoginButton({ onClick }: LoginButtonProps) {
  return (
    <button onClick={onClick} className="flex items-center bg-[#1D1B20] gap-3 px-16 py-5 hover:opacity-90 text-white text-lg rounded-full">
      <FaGithub className="w-6 h-6" />
      <span>Sign In With GitHub</span>
    </button> 
  )
}
</file>

<file path="client/src/pages/loginPage/LoginPage.tsx">
import BasicHeading from "../../components/BasicHeading";
import { useEffect } from "react";
import LoginButton from "./LoginButton";
import { useNavigate } from "react-router-dom";
import { useUser } from "../../context/useUser";

export default function LoginPage() {
  const { isLogin, login } = useUser();
  const navigate = useNavigate();

  useEffect(() => {
    if (isLogin) navigate("/orgs");
  }, [isLogin, navigate]);

  const handleLogin = () => {
    const loginUrl = login?.();
    if (loginUrl) {
      window.location.href = loginUrl;
    }
  };

  return (
    <div className="flex flex-col gap-20">
      <div className="flex flex-col items-center gap-2 px-4">
        <BasicHeading
          styling="text-center"
          heading="Login to GitHub Classroom Analyzer"
        />
        <p className="text-[20px] text-center">
          Sign in with GitHub to access your classroom repositories and analyze
          student submissions.
        </p>
      </div>
      <div className="flex flex-col items-center gap-10 px-4">
        <LoginButton onClick={handleLogin} />
        <p className="text-[16px] text-center">
          Only GitHub Classroom instructors can access this tool.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/orgPage/OrgsPage.tsx">
import { useEffect, useState } from "react";
import { useGitHub } from "../../context/useGitHub";
import type { OrgInfo } from "@shared/githubInterfaces";
import BasicHeading from "../../components/BasicHeading";
import BasicList from "../../components/basicList/BasicList";
import BasicSearchBar from "../../components/BasicSearchBar";
import { useFilteredList } from "../../hooks/useFilteredList";
import type { SortOption } from "../../utils/sortingUtils";
import { sortData } from "../../utils/sortingUtils";
import Spinner from "../../components/Spinner";

export default function OrgsPage() {
  const [orgs, setOrgs] = useState<OrgInfo[]>([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [loading, setLoading] = useState(true);
  const github = useGitHub();
  const [sortOrder, setSortOrder] = useState<SortOption>("Aâ€“Z");

  useEffect(() => {
    github
      .getOrganizations()
      .then(setOrgs)
      .catch(console.error)
      .finally(() => setLoading(false));
  }, [github]);

  const filteredOrgs = useFilteredList(orgs, searchTerm, (org, term) =>
    org.name.toLowerCase().includes(term.toLowerCase())
  );
  const sortedOrgs = sortData(filteredOrgs, sortOrder);
  console.log("orgs:", orgs);

  return (
    <div className="flex flex-col space-y-10 p-4 md:p-12">
      <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        <BasicHeading heading="Your Organizations" />
        <BasicSearchBar value={searchTerm} onChange={setSearchTerm} />
      </div>

      {loading ? (
        <Spinner />
      ) : (
        <BasicList
          type="org"
          items={sortedOrgs}
          isLoading={false}
          sortOrder={sortOrder}
          onSortChange={setSortOrder}
        />
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/CodeTab.tsx">
import Spinner from "../../components/Spinner";
import FileTree from "./FileTree";
import type { FileNode } from "./FileTree";
import { parseFileTree } from "../../utils/parseFileTree";

interface CodeTabProps {
  files: string[];
  selectedFile: string | null;
  content: string | null;
  loading?: boolean;
  onSelectFile: (file: string) => void;
}

export default function CodeTab({
  files,
  selectedFile,
  content,
  loading = false,
  onSelectFile,
}: CodeTabProps) {
  if (!files.length) return <Spinner />;
  const fileTree: FileNode[] = parseFileTree(files);

  return (
    <div className="flex">
      <div className="w-1/3 border-r p-4">
        <h3 className="font-semibold mb-2">Files</h3>
        <div className="bg-gray-100 rounded overflow-auto max-h-96">
          <FileTree
            nodes={fileTree}
            selectedPath={selectedFile}
            onSelect={onSelectFile}
          />
        </div>
      </div>
      <div className="w-2/3 p-4">
        <h3 className="font-semibold mb-2">Code</h3>
        {selectedFile ? (
          loading ? (
            <Spinner />
          ) : content ? (
            <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96">
              <code>{content}</code>
            </pre>
          ) : (
            <div className="text-red-500">Failed to load file content</div>
          )
        ) : (
          <div className="text-gray-500">Select a file to view</div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/CommitsTab.tsx">
import type { CommitInfo } from "@shared/githubInterfaces";
import Spinner from "../../components/Spinner";

interface CommitsTabProps {
  commits: CommitInfo[];
}

export default function CommitsTab({ commits }: CommitsTabProps) {
  if (!commits.length) return <Spinner />;

  return (
    <div className="space-y-2 overflow-auto max-h-96">
      {commits.map((commit) => (
        <div key={commit.sha} className="p-4 border rounded">
          <div className="flex items-center justify-between">
            <div className="w-11/12 font-medium">{commit.commit.message}</div>
            <div className="w-1/12 text-sm text-gray-500">
              {new Date(commit.commit.author.date).toLocaleString()}
            </div>
          </div>
          <div className="text-sm text-gray-600 pt-2">
            {commit.commit.author.name}
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/DiffTab.tsx">
import { useEffect, useState } from "react";
import { useGitHub } from "../../context/useGitHub";
import type {
  RepoInfo,
  CompareCommitsInfo,
  CommitInfo,
} from "@shared/githubInterfaces";
import Spinner from "../../components/Spinner";

interface DiffTabProps {
  repo: RepoInfo;
}

interface FileDiff {
  filename: string;
  status: string;
  patch?: string;
}

export default function DiffTab({ repo }: DiffTabProps) {
  const github = useGitHub();
  const [diff, setDiff] = useState<FileDiff[] | null>(null);

  useEffect(() => {
    if (repo) {
      // Compare last two commits
      github
        ?.getCommits(repo.owner, repo.name)
        .then((commits: CommitInfo[]) => {
          if (commits.length > 1) {
            return github?.compareCommits(
              repo.owner,
              repo.name,
              commits[1].sha,
              commits[0].sha
            );
          }
          return null;
        })
        .then((comparison: CompareCommitsInfo | null) => {
          setDiff(comparison?.files || null);
        });
    }
  }, [repo, github]);

  return (
    <div className="p-4">
      {diff ? (
        <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96">
          {diff.map((file: FileDiff) => (
            <div key={file.filename} className="mb-4">
              <div className="font-mono text-sm">
                {file.filename} ({file.status})
              </div>
              {file.patch && (
                <div className="bg-white p-2 rounded">
                  <code>{file.patch}</code>
                </div>
              )}
            </div>
          ))}
        </pre>
      ) : (
        <Spinner />
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FeedbackActions.tsx">
import BasicButton from "../../components/BasicButton";

interface Props {
  isEditing: boolean;
  onEditToggle: () => void;
  onDownload: () => void;
}

export default function FeedbackActions({
  isEditing,
  onEditToggle,
  onDownload,
}: Props) {
  return (
    <div className="flex justify-end space-x-2">
      <BasicButton onClick={onDownload} text="Download Feedback PDF" />
      <BasicButton
        onClick={onEditToggle}
        text={isEditing ? "Save Changes" : "Edit Feedback & Grade"}
      />
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FeedbackCard.tsx">
import { useState } from "react";
import type { AssignmentFeedback } from "@shared/aiInterfaces";
import FileFeedbackSection from "./FileFeedbackSection";
import { TbTriangleFilled } from "react-icons/tb";

interface FeedbackCardProps {
  isEditing: boolean;
  feedbackData: AssignmentFeedback;
  onFeedbackChange: (newText: string) => void;
  onGradeChange: (newGrade: string) => void;
}

export default function FeedbackCard({
  isEditing,
  feedbackData,
  onFeedbackChange,
  onGradeChange,
}: FeedbackCardProps) {
  const [expanded, setExpanded] = useState(true);
  const [fileExpanded, setFileExpanded] = useState<Record<string, boolean>>({});

  const toggleFile = (fileName: string) => {
    setFileExpanded((prev) => ({
      ...prev,
      [fileName]: !prev[fileName],
    }));
  };

  const totalIssues = feedbackData.feedbackByFile.reduce(
    (acc, file) => acc + file.issues.length,
    0
  );

  return (
    <div className="flex flex-col space-y-2 p-4 border rounded-md">
      <h2 className="text-lg font-semibold text-center">AI Feedback</h2>

      {/* Grade */}
      <div className="flex items-center space-x-4">
        <label className="font-semibold">Grade:</label>
        {isEditing ? (
          <select
            className="border rounded px-2 py-1"
            value={feedbackData.grade}
            onChange={(e) => onGradeChange(e.target.value)}
          >
            {["5", "4", "3", "2", "1"].map((val) => (
              <option key={val} value={val}>
                {val}
              </option>
            ))}
          </select>
        ) : (
          <span>{feedbackData.grade}</span>
        )}
      </div>

      {/* Overall Feedback */}
      <div>
        <label className="font-semibold">Overall Feedback:</label>
        {isEditing ? (
          <textarea
            className="w-full p-2 border rounded mt-1 resize-y min-h-[100px]"
            value={feedbackData.feedback}
            onChange={(e) => onFeedbackChange(e.target.value)}
          />
        ) : (
          <p className="text-sm whitespace-pre-wrap mt-1">
            {feedbackData.feedback}
          </p>
        )}
      </div>

      {/* Collapsible Issues Section */}
      <div className="mt-2 space-y-4">
        <button
          onClick={() => setExpanded((prev) => !prev)}
          className="flex items-center space-x-2 font-semibold focus:outline-none"
        >
          <span
            className={`transform transition-transform duration-200 ${
              expanded ? "rotate-180" : "rotate-90"
            }`}
          >
            <TbTriangleFilled />
          </span>
          <span>Issues ({totalIssues})</span>
        </button>

        {expanded && (
          <div className="max-h-[300px] overflow-y-auto space-y-2 pr-1">
            {feedbackData.feedbackByFile.map((file) => (
              <FileFeedbackSection
                key={file.fileName}
                fileName={file.fileName}
                issues={file.issues}
                expanded={!!fileExpanded[file.fileName]}
                onToggle={() => toggleFile(file.fileName)}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FeedbackTab.tsx">
import Spinner from "../../components/Spinner";
import FeedbackCard from "./FeedbackCard";
import FeedbackActions from "./FeedbackActions";
import type { AssignmentFeedback } from "@shared/aiInterfaces";

interface FeedbackTabProps {
  isEditing: boolean;
  feedbackData: AssignmentFeedback;
  onFeedbackChange: (newText: string) => void;
  onGradeChange: (newGrade: string) => void;
  onToggleEdit: () => void;
  onDownload: () => void;
}

export default function FeedbackTab({
  isEditing,
  feedbackData,
  onFeedbackChange,
  onGradeChange,
  onToggleEdit,
  onDownload,
}: FeedbackTabProps) {
  if (!feedbackData) return <Spinner />;

  return (
    <div className="flex flex-col space-y-6">
      <div className="flex-col space-y-4">
        <FeedbackActions
          isEditing={isEditing}
          onEditToggle={onToggleEdit}
          onDownload={onDownload}
        />
      </div>
      <FeedbackCard
        isEditing={isEditing}
        feedbackData={feedbackData}
        onFeedbackChange={onFeedbackChange}
        onGradeChange={onGradeChange}
      />
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FileFeedbackSection.tsx">
interface Props {
  fileName: string;
  issues: { id: number; line?: number; text: string }[];
  expanded: boolean;
  onToggle: () => void;
}

export default function FileFeedbackSection({
  fileName,
  issues,
  expanded,
  onToggle,
}: Props) {
  return (
    <div className="border p-2 rounded">
      <button
        onClick={onToggle}
        className="flex items-center space-x-2 font-medium w-full text-left"
      >
        <span
          className={`transform transition-transform ${
            expanded ? "rotate-90" : ""
          }`}
        >
          â–¶
        </span>
        <span>
          {fileName} ({issues.length} issues)
        </span>
      </button>
      {expanded && (
        <ul className="list-disc list-inside mt-2">
          {issues.map((issue) => (
            <li key={issue.id} className="text-sm">
              {issue.line ? `Line ${issue.line}: ` : ""}
              {issue.text}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FileTree.tsx">
import { useState } from "react";
import { TbTriangleFilled } from "react-icons/tb";

export interface FileNode {
  name: string;
  path: string;
  isDirectory: boolean;
  children?: FileNode[];
}

interface FileTreeProps {
  nodes: FileNode[];
  selectedPath: string | null;
  onSelect: (path: string) => void;
}

export default function FileTree({
  nodes,
  selectedPath,
  onSelect,
}: FileTreeProps) {
  return (
    <div>
      {nodes.map((node) => (
        <TreeNode
          key={node.path}
          node={node}
          selectedPath={selectedPath}
          onSelect={onSelect}
        />
      ))}
    </div>
  );
}

function TreeNode({
  node,
  selectedPath,
  onSelect,
}: {
  node: FileNode;
  selectedPath: string | null;
  onSelect: (path: string) => void;
}) {
  const [open, setOpen] = useState(false);
  const isSelected = selectedPath === node.path;

  const handleClick = () => {
    if (node.isDirectory) setOpen((prev) => !prev);
    else onSelect(node.path);
  };

  return (
    <div className="ml-2">
      <div
        className={`flex items-center cursor-pointer p-1 rounded hover:bg-gray-100 ${
          isSelected ? "bg-blue-50" : ""
        }`}
        onClick={handleClick}
      >
        {node.isDirectory ? (
          <TbTriangleFilled
            size={16}
            className={`transform transition-transform duration-200 ${
              open ? "rotate-180" : "rotate-90"
            }`}
          />
        ) : (
          <span className="w-4" />
        )}
        <span className="ml-1">{node.name}</span>
      </div>
      {open && node.children && (
        <div className="ml-4">
          {node.children.map((child) => (
            <TreeNode
              key={child.path}
              node={child}
              selectedPath={selectedPath}
              onSelect={onSelect}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/MetadataTab.tsx">
import type { RepoInfo } from "@shared/githubInterfaces";
import Spinner from "../../components/Spinner";

interface MetadataTabProps {
  repo: RepoInfo;
}

export default function MetadataTab({ repo }: MetadataTabProps) {
  if (!repo) return <Spinner />;
  return (
    <div className="grid grid-cols-2 gap-4 p-4">
      <div className="bg-gray-100 rounded p-2">
        <h3 className="font-semibold mb-2">Repository Info</h3>
        <dl className="space-y-2">
          <div>
            <dt className="text-gray-600">Created</dt>
            <dd>{new Date(repo.createdAt).toLocaleString()}</dd>
          </div>
          <div>
            <dt className="text-gray-600">Last Updated</dt>
            <dd>{new Date(repo.updatedAt).toLocaleString()}</dd>
          </div>
        </dl>
      </div>
      <div className="bg-gray-100 rounded p-2">
        <h3 className="font-semibold mb-2">Collaborators</h3>
        <div className="space-y-2">
          {repo.collaborators.map((collaborator) => (
            <div key={collaborator.id} className="flex items-center space-x-2">
              <img
                src={collaborator.avatarUrl}
                className="w-6 h-6 rounded-full"
                alt={collaborator.name}
              />
              <span>{collaborator.name}</span>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/RepoDetailPage.tsx">
import { useParams, useLocation } from "react-router-dom";
import { useEffect, useState, useMemo } from "react";
import type { RepoInfo, CommitInfo } from "@shared/githubInterfaces";
import BackButton from "../../components/BackButton";
import BasicHeading from "../../components/BasicHeading";
import { useGitHub } from "../../context/useGitHub";
import Tabs from "../../components/Tabs";
import CodeTab from "./CodeTab";
import CommitsTab from "./CommitsTab";
import MetadataTab from "./MetadataTab";
import DiffTab from "./DiffTab";
import FeedbackTab from "./FeedbackTab";
import Spinner from "../../components/Spinner";

import { getInitialFeedback } from "../../utils/feedbackUtils";

import type { AssignmentFeedback } from "@shared/aiInterfaces";

export default function RepoDetailPage() {
  const location = useLocation();
  const repoFromState = location.state as RepoInfo | undefined;
  const { orgName, assignmentName, repoName } = useParams();
  const github = useGitHub();

  const [repo, setRepo] = useState<RepoInfo | null>(repoFromState ?? null);
  const [loading, setLoading] = useState(true);
  const [isEditing, setIsEditing] = useState(false);

  const [files, setFiles] = useState<string[]>([]);
  const [selectedFile, setSelectedFile] = useState<string | null>(null);
  const [fileContent, setFileContent] = useState<string | null>(null);
  const [fileLoading, setFileLoading] = useState(false);
  const [commits, setCommits] = useState<CommitInfo[]>([]);

  const [feedbackData, setFeedbackData] =
    useState<AssignmentFeedback>(getInitialFeedback);

  const handleClick = (action: string) => {
    if (action === "Edit Feedback") {
      setIsEditing((prev) => !prev);
    } else {
      console.log(`Clicked ${action}`);
    }
  };

  const handleFeedbackTextChange = (newText: string) => {
    setFeedbackData((prev) => ({ ...prev, feedback: newText }));
  };

  useEffect(() => {
    if (!repoFromState && github && orgName && assignmentName && repoName) {
      setLoading(true);
      github
        .getRepos(orgName, assignmentName)
        .then((repos) => {
          const found = repos.find((r) => r.name === repoName);
          setRepo(found || null);
        })
        .finally(() => setLoading(false));
    } else {
      setLoading(false);
    }
  }, [orgName, assignmentName, repoName, github, repoFromState]);

  // Fetch initial data
  useEffect(() => {
    if (repo) {
      // Load commits
      github?.getCommits(repo.owner, repo.name).then(setCommits);

      // Load file tree
      github?.getRepoTree(repo.owner, repo.name).then(setFiles);
    }
  }, [repo, github]);

  useEffect(() => {
    if (!selectedFile || !repo || !github) return;

    setFileLoading(true);
    setFileContent(null);

    github
      .getFileContents(repo.owner, repo.name, selectedFile)
      .then((content) => {
        setFileContent(content);
      })
      .catch((error) => {
        console.error("Error fetching file content:", error);
        setFileContent("Error loading file content");
      })
      .finally(() => {
        setFileLoading(false);
      });
  }, [selectedFile, repo, github]);

  useEffect(() => {
    console.log("repo:", repo);
  }, [repo]);

  const tabs = useMemo(
    () => [
      {
        id: "code",
        label: "Code",
        content: (
          <CodeTab
            files={files}
            selectedFile={selectedFile}
            content={fileContent}
            loading={fileLoading}
            onSelectFile={setSelectedFile}
          />
        ),
      },
      {
        id: "commits",
        label: "Commits",
        content: <CommitsTab commits={commits} />,
      },
      {
        id: "diff",
        label: "Diff",
        content: repo ? <DiffTab repo={repo} /> : <div>No repo found</div>,
      },
      {
        id: "metadata",
        label: "Metadata",
        content: repo ? <MetadataTab repo={repo} /> : <div>No repo found</div>,
      },
      {
        id: "feedback",
        label: "Feedback",
        content: (
          <FeedbackTab
            isEditing={isEditing}
            feedbackData={feedbackData}
            onFeedbackChange={handleFeedbackTextChange}
            onGradeChange={(newGrade) =>
              setFeedbackData((prev) => ({ ...prev, grade: newGrade }))
            }
            onToggleEdit={() => setIsEditing((prev) => !prev)}
            onDownload={() => handleClick("Download Feedback PDF")}
          />
        ),
      },
    ],
    [
      files,
      selectedFile,
      fileContent,
      fileLoading,
      commits,
      repo,
      isEditing,
      feedbackData,
    ]
  );

  if (loading) return <Spinner />;

  if (!repo)
    return <div className="p-4 text-red-600">Repository not found.</div>;

  return (
    <div className="flex flex-col space-y-10 p-4 md:p-12">
      <div className="flex flex-col space-y-6">
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          <div className="flex space-x-4">
            <BackButton
              to={`/orgs/${orgName}/assignments/${assignmentName}/repos`}
            />
            <BasicHeading heading={repo.name} />
          </div>
        </div>
        <Tabs tabs={tabs} />
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/RepoInfoCard.tsx">
import type { RepoInfo } from "@shared/githubInterfaces";

interface RepoInfoCardProps {
  title?: string;
  repo: RepoInfo;
}

export default function RepoInfoCard({ title, repo }: RepoInfoCardProps) {
  return (
    <div className={`rounded shadow p-4 bg-white border`}>
      {title && (
        <h2 className="text-lg font-semibold text-gray-800 mb-3">{title}</h2>
      )}
      <div className="text-gray-700 text-sm">
        <ul className="space-y-1 text-sm">
          <li>
            <div className="flex items-center space-x-3">
              <img
                src={repo.collaborators[0].avatarUrl}
                alt={repo.avatarUrl}
                className="w-6 h-6 rounded-full"
              />
              <strong>{repo.collaborators[0].name}</strong>
            </div>
          </li>
          <li>
            <strong>Created:</strong>{" "}
            {new Date(repo.createdAt).toLocaleString()}
          </li>
          <li>
            <strong>Updated:</strong>{" "}
            {new Date(repo.updatedAt).toLocaleString()}
          </li>
          <li>
            <strong>URL:</strong>{" "}
            <a
              href={repo.url}
              target="_blank"
              rel="noopener noreferrer"
              className="text-blue-600 underline"
            >
              {repo?.url}
            </a>
          </li>
        </ul>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoPage/ReposPage.tsx">
import BasicHeading from "../../components/BasicHeading";
import BasicList from "../../components/basicList/BasicList";
import BasicSearchBar from "../../components/BasicSearchBar";
import type { RepoInfo } from "@shared/githubInterfaces";
import { useEffect, useState } from "react";
import { useGitHub } from "../../context/useGitHub";
import { useParams } from "react-router-dom";
import { useFilteredList } from "../../hooks/useFilteredList";
import BackButton from "../../components/BackButton";
import BasicButton from "../../components/BasicButton";
import { sortData } from "../../utils/sortingUtils";
import type { SortOption } from "../../utils/sortingUtils";
import Spinner from "../../components/Spinner";

export default function ReposPage() {
  const { orgName } = useParams<{ orgName: string }>();
  const { assignmentName } = useParams<{ assignmentName: string }>();
  const github = useGitHub();
  const [repos, setRepos] = useState<RepoInfo[]>([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [loading, setLoading] = useState(true);
  const [sortOrder, setSortOrder] = useState<SortOption>("Newest");

  const filteredRepos = useFilteredList(repos ?? [], searchTerm, (repo, term) =>
    repo.name.toLowerCase().includes(term.toLowerCase())
  );

  const sortedRepos = sortData(filteredRepos, sortOrder);

  useEffect(() => {
    if (orgName) {
      github
        .getRepos(orgName, assignmentName)
        .then(setRepos)
        .catch(console.error)
        .finally(() => setLoading(false));
    }
  }, [orgName, assignmentName, github]);

  const handleClick = (action: string) => {
    console.log(`Clicked ${action}`);
  };

  console.log("repos", repos);
  return (
    <div className="flex flex-col space-y-10 p-4 md:p-12">
      <div className="flex flex-col space-y-6">
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          <div className="flex space-x-4">
            <BackButton to={`/orgs/${orgName}/assignments`} />
            <BasicHeading heading={`Repositories in ${assignmentName}`} />
          </div>
          <div className="flex space-x-4">
            <BasicSearchBar value={searchTerm} onChange={setSearchTerm} />
          </div>
        </div>
        <div className="flex flex-col md:flex-row md:items-center md:justify-end gap-4">
          <BasicButton
            onClick={() => handleClick("Run Analysis")}
            text="Run Analysis"
          />
          <BasicButton
            onClick={() => handleClick("View Summary")}
            text="View Summary"
          />
        </div>
      </div>

      {loading ? (
        <Spinner />
      ) : (
        <BasicList
          type="repo"
          items={sortedRepos}
          orgName={orgName!}
          assignmentName={assignmentName!}
          isLoading={loading}
          sortOrder={sortOrder}
          onSortChange={setSortOrder}
        />
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/SpecificUserSubmissionScreen.tsx">
import { useEffect, useState } from "react";
import { useParams, useNavigate } from "react-router-dom";

interface SubmissionData {
  name: string;
  feedback: string;
  date: string;
  fileName: string;
  grade: string;
}

export default function SpecificUserSubmissionScreen() {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const [data, setData] = useState<SubmissionData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Edit-tilat
  const [isEditing, setIsEditing] = useState(false);
  const [editedFeedback, setEditedFeedback] = useState("");

  useEffect(() => {
    setLoading(true);
    setError(null);
    setTimeout(() => {
      if (!id) {
        setError("ID puuttuu");
        setLoading(false);
        return;
      }
      setData({
        name: `Matti MeikÃ¤lÃ¤inen`,
        feedback: "",
        date:
          new Date().toLocaleDateString("fi-FI") +
          " " +
          new Date().toLocaleTimeString("fi-FI", {
            hour: "2-digit",
            minute: "2-digit",
          }),
        fileName: `tehtava${id}.zip`,
        grade: "3/5",
      });
      setLoading(false);
    }, 800);
  }, [id]);

  if (loading) {
    return <div className="text-center mt-10">Ladataan...</div>;
  }
  if (error) {
    return <div className="text-center mt-10 text-red-600">{error}</div>;
  }
  if (!data) {
    return null;
  }

  // Edit-painikkeen toiminta
  const handleEditClick = () => {
    setIsEditing(true);
    setEditedFeedback(data.feedback);
  };

  const handleSave = () => {
    setData({ ...data, feedback: editedFeedback });
    setIsEditing(false);
  };

  const handleCancel = () => {
    setIsEditing(false);
    setEditedFeedback("");
  };

  // Download-painikkeen toiminta (simuloitu PDF)
  const handleDownload = () => {
    const element = document.createElement("a");
    const file = new Blob([data.feedback], { type: "application/pdf" });
    element.href = URL.createObjectURL(file);
    element.download = data.fileName.replace(/\.zip$/, ".pdf");
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  };

  // Edit Grade -painikkeen toiminta
  const handleEditGrade = () => {
    const uusiArvosana = window.prompt(
      "SyÃ¶tÃ¤ uusi arvosana (esim. 4/5):",
      data.grade
    );
    if (uusiArvosana && uusiArvosana.trim() !== "") {
      setData({ ...data, grade: uusiArvosana });
    }
  };

  // Delete-painikkeen toiminta
  const handleDelete = () => {
    if (
      window.confirm(
        "Haluatko varmasti poistaa koko palautuksen? TÃ¤tÃ¤ toimintoa ei voi perua."
      )
    ) {
      navigate(-1);
    }
  };

  return (
    <div className="min-h-screen bg-[#F5F5F5] flex justify-center items-center">
      <div className="max-w-[820px] w-full bg-white rounded-[16px] shadow-lg p-0 sm:p-[60px] py-[48px] border border-[#E0E0E0]">
        <div className="relative w-full h-full flex flex-col items-start">
          <div
            className="w-full h-full bg-white rounded-none shadow-none px-0 py-0 relative border-none"
            style={{ boxShadow: "none" }}
          >
            {/* YlÃ¤rivi: tekstit vasemmalle, painikkeet oikealle */}
            <div className="flex flex-row justify-between items-start w-full gap-4 mt-2 mb-2">
              <div className="flex flex-row items-start gap-4">
                <button
                  onClick={() => navigate(-1)}
                  className="p-0 rounded-full text-[32px] font-extrabold text-[#1E1E1E] leading-none border-none bg-transparent hover:bg-gray-100 mt-1"
                  aria-label="Takaisin"
                  style={{ fontFamily: "inherit", border: "none" }}
                >
                  &#8592;
                </button>
                <div>
                  <h1
                    className="text-[20px] font-extrabold text-[#1E1E1E] mb-1"
                    style={{ fontFamily: "inherit" }}
                  >
                    Matti MeikÃ¤lÃ¤inen
                  </h1>
                  <div className="text-[#1E1E1E] text-[13px] flex flex-col gap-0.5">
                    <span>Submission time: {data.date}</span>
                    <span>Grade: {data.grade}</span>
                  </div>
                </div>
              </div>
              <div className="flex flex-col gap-4 items-end pr-8">
                <button
                  className="bg-[#1E1E1E] text-white px-6 py-1.5 rounded-full font-medium text-[13px] w-[180px] text-right"
                  style={{ boxShadow: "none", letterSpacing: 0 }}
                  onClick={handleDownload}
                >
                  Download Feedback PDF
                </button>
                <button
                  className="bg-[#1E1E1E] text-white px-6 py-1.5 rounded-full font-medium text-[13px] w-[180px] text-right"
                  style={{ boxShadow: "none", letterSpacing: 0 }}
                  onClick={handleEditGrade}
                >
                  Edit Grade
                </button>
                <button
                  className="bg-[#1E1E1E] text-white px-6 py-1.5 rounded-full font-medium text-[13px] w-[180px] text-right"
                  style={{ boxShadow: "none", letterSpacing: 0 }}
                  onClick={handleEditClick}
                  disabled={isEditing}
                >
                  Edit Feedback
                </button>
              </div>
            </div>
            {/* AI Feedback -laatikko */}
            <div className="pt-6 pb-4">
              <div className="text-[15px] font-semibold text-[#1E1E1E] mb-2">
                AI Feedback:
              </div>
              <div
                className="w-full bg-[#C7C7C7] rounded-[8px] min-h-[120px] flex items-center justify-center text-[#1E1E1E] text-[15px] p-6 border-none"
                style={{ height: 120 }}
              >
                {isEditing ? (
                  <div className="w-full">
                    <textarea
                      className="w-full border rounded p-4 min-h-[80px] bg-white text-[#1E1E1E] text-[15px]"
                      value={editedFeedback}
                      onChange={(e) => setEditedFeedback(e.target.value)}
                    />
                    <div className="mt-2 flex gap-2">
                      <button
                        className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 text-[13px]"
                        onClick={handleSave}
                      >
                        Tallenna
                      </button>
                      <button
                        className="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 text-[13px]"
                        onClick={handleCancel}
                      >
                        Peruuta
                      </button>
                    </div>
                  </div>
                ) : data.feedback ? (
                  data.feedback
                ) : (
                  <span className="text-[#757575]">
                    Highlighted issues, what went well etc etc
                  </span>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/services/feedbackService.ts">
import { supabase } from "../../../server/utils/supabase";

export async function saveFeedback(submissionId: string, aiComment: string, score: number) {
  const { data, error } = await supabase.from("feedback").insert([
    {
      submission_id: submissionId,
      ai_comment: aiComment,
      score,
    },
  ]);

  if (error) throw error;
  return data?.[0];
}
</file>

<file path="client/src/services/submissionService.ts">
import { supabase } from "../../../server/utils/supabase";

export async function saveSubmission(
  assignmentId: string,
  studentGithub: string,
  repoUrl: string
) {
  const { data, error } = await supabase.from("submissions").insert([
    {
      assignment_id: assignmentId,
      student_github: studentGithub,
      repo_url: repoUrl,
    },
  ]);

  if (error) throw error;
  return data?.[0];
}
</file>

<file path="client/src/types/AssignmentFeedback.ts">
export type SingleAssignmentFeedback = {
  assignmentName: string;
  issues: string[];
};

export type AssignmentFeedbacks = SingleAssignmentFeedback[];
</file>

<file path="client/src/types/OrgReport.ts">
// this is the output of the handleGetAllOrganizationData() call to the backend (using GutHub API)
export type OrgReport = {
  org: string;
  assignments: string[];
  submissions: {
    student: string; // student github username
    grades: Record<string, number | string | null>; 
  }[];
};
</file>

<file path="client/src/types/StudentInfo.ts">
import type { StudentInStudentRoster } from "./StudentInStudentRoster";

// a lenghtier version of the studentInStudentRoster
export type StudentInfo = StudentInStudentRoster & {
  grades: (number | string)[];
  totalPoints: number | string;
  submissionCount: number;
};
</file>

<file path="client/src/types/StudentInStudentRoster.ts">
// this is what we get from each student when a roster from GitHub classroom is created
export type StudentInStudentRoster = {
  identifier: string;
  github_username: string;
  github_id: string;
  name: string;
};
</file>

<file path="client/src/types/StudentSubmissionInfo.ts">
export interface StudentSubmissionInfo {
  id: string;
  studentProfilePicture: string;
  studentName: string;
  submissionStatus: string;
  currentGrade: string;
  submissionTime: string;
}
</file>

<file path="client/src/utils/feedbackUtils.ts">
import type { AssignmentFeedback } from "@shared/aiInterfaces";

function generateSummaryFeedback(
  feedbackByFile: AssignmentFeedback["feedbackByFile"]
): string {
  const summary =
    "Overall, good structure and code readability. Minor issues found.";
  const issues: string[] = [];

  let count = 1;
  for (const file of feedbackByFile) {
    for (const issue of file.issues) {
      issues.push(
        `Issue ${count}: ${issue.text}${
          issue.line ? ` (line ${issue.line}, in ${file.fileName})` : ""
        }`
      );
      count++;
    }
  }

  return [summary, ...issues].join("\n");
}

const feedbackByFile: AssignmentFeedback["feedbackByFile"] = [
  {
    fileName: "App.tsx",
    issues: [
      { id: 1, line: 5, text: "It would be better to use justify-end." },
      { id: 2, line: 34, text: "I couldn't find the import component." },
    ],
  },
  {
    fileName: "Home.tsx",
    issues: [
      {
        id: 1,
        line: 5,
        text: "I couldn't find any useContent component in the App.tsx - compulsory requirement.",
      },
    ],
  },
];

const defaultFeedback: AssignmentFeedback = {
  repoName: "week-2-assignment-tangerinekey380",
  assignmentTitle: "React Todo App",
  grade: "4",
  date: "2025-05-20T15:23:00Z",
  feedbackByFile,
  feedback: generateSummaryFeedback(feedbackByFile),
};

export function getInitialFeedback(): AssignmentFeedback {
  return defaultFeedback;
}
</file>

<file path="client/src/utils/generateCSVFromOrg.ts">
/* 
FORMAT OF CSV DOCUMENT:

Overview of Student Points and Submissions

Name            GitHub Username     Roster Identifier     Assignment 1      Assignment 2     Assignment 3     Total Points
Alice Park          alice                al3park              5                 N/A               2               7
Micheal Devon       michael               19029               4                 3                 5               12
Willie Wonka        willie                23234             Error               N/A               5               5

*/

import type { OrgReport } from "src/types/OrgReport";
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";

function downloadCSV(csvContent: string, filename: string = "report.csv") {
  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.setAttribute("href", url);
  link.setAttribute("download", filename);
  link.style.visibility = "hidden";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

export function generateCSVFromOrg(orgData: OrgReport, roster: StudentInStudentRoster[]) {
  const assignmentNames = orgData.assignments;
  const headerRow = ["Name", "GitHub Username", "Roster Identifier", ...assignmentNames, "Total Points"]; 
  const submissionMap = new Map(
    orgData.submissions.map((s) => [s.student, s.grades])
  );
  const csvLines: string[][] = [
    ["Overview of Student Points and Submissions"], // title row
    headerRow, // header row
  ];
  for (const student of roster) {
    if (!student.identifier) continue;
    const scores = submissionMap.get(student.github_username) || {};
    const row: (string | number)[] = [
      student.name || "N/A",
      student.github_username || "N/A",
      student.identifier || "N/A",
    ];
    let total = 0;
    let count = 0;
    for (const assignment of assignmentNames) {
      const points = scores[assignment];
      if (typeof points === "number") {
        row.push(points);
        total += points;
        count++;
      } else if (points === "Error") {
        row.push("Error");
      } else {
        row.push("N/A");
      }
    }
    row.push(count > 0 ? total : "N/A");
    csvLines.push(row.map(String));
  }

  const csvContent = csvLines.map((row) => row.join(";")).join("\n");
  downloadCSV(csvContent, `${orgData.org}_assignments_overview.csv`);
}
</file>

<file path="client/src/utils/parseFileTree.ts">
import type { FileNode } from "../pages/repoDetailPage/FileTree";

// Internal type for building tree using object map
interface InternalNode extends Omit<FileNode, "children"> {
  children?: Record<string, InternalNode>;
}

export function parseFileTree(paths: string[]): FileNode[] {
  const root: Record<string, InternalNode> = {};

  paths.forEach((path) => {
    const parts = path.split("/");
    let current = root;
    let currentPath = "";

    parts.forEach((part, index) => {
      currentPath = currentPath ? `${currentPath}/${part}` : part;

      if (!current[part]) {
        current[part] = {
          name: part,
          path: currentPath,
          isDirectory: index < parts.length - 1,
          children: index < parts.length - 1 ? {} : undefined,
        };
      }

      if (index < parts.length - 1) {
        current = current[part].children!;
      }
    });
  });

  // Convert InternalNode -> FileNode (with children as array)
  const convert = (nodes: Record<string, InternalNode>): FileNode[] =>
    Object.values(nodes).map((node) => ({
      name: node.name,
      path: node.path,
      isDirectory: node.isDirectory,
      children: node.children ? convert(node.children) : undefined,
    }));

  return convert(root);
}
</file>

<file path="client/src/utils/sortingUtils.ts">
export type SortOption =
  | "Newest"
  | "Oldest"
  | "Aâ€“Z"
  | "Zâ€“A"
  | "Amount of Students"
  | "Amount of Students (desc)";

interface WithUpdatedAt {
  updatedAt: string;
}

interface WithAmountOfStudents {
  amountOfStudents: number;
}

function hasUpdatedAt(obj: unknown): obj is WithUpdatedAt {
  return typeof obj === "object" && obj !== null && "updatedAt" in obj;
}

function hasAmountOfStudents(obj: unknown): obj is WithAmountOfStudents {
  return typeof obj === "object" && obj !== null && "amountOfStudents" in obj;
}

export function sortData<T extends { name: string }>(
  data: T[],
  sortOrder: SortOption
): T[] {
  const sorted = [...data];

  switch (sortOrder) {
    case "Aâ€“Z":
      return sorted.sort((a, b) => a.name.localeCompare(b.name));

    case "Zâ€“A":
      return sorted.sort((a, b) => b.name.localeCompare(a.name));

    case "Newest":
      return sorted.sort((a, b) =>
        hasUpdatedAt(a) && hasUpdatedAt(b)
          ? new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
          : 0
      );

    case "Oldest":
      return sorted.sort((a, b) =>
        hasUpdatedAt(a) && hasUpdatedAt(b)
          ? new Date(a.updatedAt).getTime() - new Date(b.updatedAt).getTime()
          : 0
      );

    case "Amount of Students":
      return sorted.sort((a, b) =>
        hasAmountOfStudents(a) && hasAmountOfStudents(b)
          ? a.amountOfStudents - b.amountOfStudents
          : 0
      );

    case "Amount of Students (desc)":
      return sorted.sort((a, b) =>
        hasAmountOfStudents(a) && hasAmountOfStudents(b)
          ? b.amountOfStudents - a.amountOfStudents
          : 0
      );

    default:
      return sorted;
  }
}
</file>

<file path="client/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="client/tailwind.config.js">
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}", // adjust this if your files are in different folders
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
</file>

<file path="client/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@shared/*": ["../shared/*"]
    },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "types": ["react", "react-dom"],

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src", "../server/routes/testroutes.ts", "../server/AssignmentsService.ts", "../server/services/UserService.ts"]
}
</file>

<file path="client/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="client/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,
    "types": ["node"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="client/vite.config.ts">
import { defineConfig } from "vite";
import tailwindcss from "@tailwindcss/vite";
import react from "@vitejs/plugin-react";
import path from "path";

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      "@shared": path.resolve(__dirname, "../shared"),
    },
  },
  server: {
    proxy: {
      "/api": {
        target: "http://localhost:5000", // backend server
        changeOrigin: true,
        secure: false,
      },
    },
  },
});
</file>

<file path="docs/ARCHITECTURE.md">
# System Architecture

## Overview

This system is designed as a full-stack web application that automates feedback for programming assignments submitted via GitHub Classroom. It consists of three core layersâ€”Frontend, Backend, and External Integrationsâ€”each playing a distinct role in delivering real-time, AI-assisted insights to both students and teachers.

The Frontend, built with React, provides a user-friendly interface for authentication, repository selection, and feedback visualization. It communicates with the Backend via RESTful APIs.

The Backend, powered by Node.js and Express, handles user authentication through GitHub OAuth, fetches repository data via the GitHub API, and manages prompt generation and communication with AI services like OpenAI or DeepSeek. It also formats and returns feedback, summaries, and CSV exports to the frontend.

The system leverages external APIsâ€”GitHub API for accessing student submissions and AI APIs for analyzing code and generating feedbackâ€”without requiring a dedicated database for the MVP.

Components are containerized using Docker to ensure portability and consistent development environments.

## Components

- **Frontend (React):**
  Built with React and Vite, the frontend provides the user interface for teachers. It includes components for login, repository selection, feedback display, and summary reports. Styled with Tailwind CSS, it communicates with the backend via a structured API service layer using axios.

- **Backend (Node.js/Express):** Handles authentication, repository reading, AI communication.
  Acts as the main server layer. It handles GitHub OAuth authentication, fetches repositories, processes requests, and orchestrates interactions between GitHub and AI services. Follows a modular structure with routes, controllers, and services.

- **AI Integration (OpenAI):** Generates feedback from student code.
  Uses AI APIs to analyze student code, generate insightful feedback, and suggest improvements. Prompts are crafted dynamically based on submission context and user roles (teacher).

- **GitHub API:** Used to access student repositories and commit history.
  Integrates GitHub REST APIs to authenticate users, list repositories, and fetch student assignment code and metadata (e.g., commits, diffs). It serves as the bridge between GitHub Classroom and the feedback system.

<!-- - **(Optional) Database:** If used, describe its purpose. -->

## Data Flow

1. Teacher logs in via GitHub OAuth.
2. Repositories are listed via GitHub API.
3. Code is fetched and passed to the AI with a prompt.
4. AI response is returned and shown in UI.
5. Feedback summary and CSV report are generated.

## Architecture Diagram

[![System Architecture](https://mermaid.ink/img/pako:eNp1VE1vm0AQ_SurPeRSPgw2YHOoZGMntdRKkZ320NLDGsaAArtoWdo4lv97Z4FEwXI5oBnevLdvZoAzTUQKNKSmacY8EfxYZGHMCSnZSbQqJCnLJMS8g4-l-JvkTCrytMaapj1kktU5uZeCK-Dpr5i-hTH9rVX6a-kg8n1LIlHVggNXzRh2EX5kGTT2Ds-EK3SK6PJxS_Yg_xQJkK_sBHIo0Sd9MLJiyXPvY4hGSittY_NSS2gacuOklfYRoX8pyhLkFahtPBTqS3sgy1bl5BPZQS3wxtJ3O0PpTPcjsVlFHoCDZEpcVXi6py25B0gP6JRseFZwGNf42s3-B0HHQqr_taz9MuTKwXsXj4Qi3fZa4DzksSiBmOTmkiL3uuzWDCM9hrSrMhO9zgasU1WOvHVLI6ZJdpv9E9GrM83POP0eWjl96g6p26dTcoeD0zd_AGY94PVp1NOWg0rkjkSjaZdi0R1C_bOkLHCyKBzTXKm6CW0bjTdWVqi8PVjo3gZu48ugYjpieB8YdcnUUcjKEjVwVnQsrWJrDjVoJouUhkq2YNAKZMV0Ss9aL6YqhwqXGmKYMvmsKRfk1Iz_FKJ6o0nRZjkNj6xsMGvrlClYF_jZser9qcTJgoxEyxUNF50EDc_0hYZOEFj-wvGnwcRZOO5kMTfoiYb-xPLnwSxw557rLDDyLgZ97U6dWPPAMyikBb6W3_qvv_sJXP4Bq800Cg?type=png)](https://mermaid.live/edit#pako:eNp1VE1vm0AQ_SurPeRSPgw2YHOoZGMntdRKkZ320NLDGsaAArtoWdo4lv97Z4FEwXI5oBnevLdvZoAzTUQKNKSmacY8EfxYZGHMCSnZSbQqJCnLJMS8g4-l-JvkTCrytMaapj1kktU5uZeCK-Dpr5i-hTH9rVX6a-kg8n1LIlHVggNXzRh2EX5kGTT2Ds-EK3SK6PJxS_Yg_xQJkK_sBHIo0Sd9MLJiyXPvY4hGSittY_NSS2gacuOklfYRoX8pyhLkFahtPBTqS3sgy1bl5BPZQS3wxtJ3O0PpTPcjsVlFHoCDZEpcVXi6py25B0gP6JRseFZwGNf42s3-B0HHQqr_taz9MuTKwXsXj4Qi3fZa4DzksSiBmOTmkiL3uuzWDCM9hrSrMhO9zgasU1WOvHVLI6ZJdpv9E9GrM83POP0eWjl96g6p26dTcoeD0zd_AGY94PVp1NOWg0rkjkSjaZdi0R1C_bOkLHCyKBzTXKm6CW0bjTdWVqi8PVjo3gZu48ugYjpieB8YdcnUUcjKEjVwVnQsrWJrDjVoJouUhkq2YNAKZMV0Ss9aL6YqhwqXGmKYMvmsKRfk1Iz_FKJ6o0nRZjkNj6xsMGvrlClYF_jZser9qcTJgoxEyxUNF50EDc_0hYZOEFj-wvGnwcRZOO5kMTfoiYb-xPLnwSxw557rLDDyLgZ97U6dWPPAMyikBb6W3_qvv_sJXP4Bq800Cg)
</file>

<file path="docs/EPICS.md">
# Epic Stories

Organize your features and user stories into broader epics.

## Epics and Related Stories

### 1. GitHub Integration

#### Goal: Enable secure and seamless access to student repositories using GitHub's API.

##### User stories:

- As a teacher, I want to authenticate with GitHub using OAuth so I can securely access student repositories.
- As a teacher, I want to view a list of student repositories so I can select which ones to analyze.
- As a teacher, I want to fetch code and metadata (e.g., last commit, repo owner) for each repository.

##### Suggestions:

- Support GitHub Classroom filtering/tagging to improve repo discovery.
- Cache repository metadata to reduce API usage and improve performance.

### 2. AI Feedback Engine

#### Goal: Provide automated, context-aware feedback on student code using LLMs.

##### User stories:

- As a teacher, I want to automatically generate prompts from student code so I can get feedback from the AI without manual formatting.
- As a system, I need to send these prompts to an AI engine (OpenAI or DeepSeek) and receive relevant, structured feedback.
- As a user, I want error handling and retry mechanisms in case of AI API failures.

##### Suggestions:

- Store past AI responses temporarily (in memory or local cache) to reduce duplicate requests during session.
- Define prompt templates that adapt to different code types or assignment goals.
- Consider feedback format standardization (e.g., issue type, severity, suggestion) for easier UI rendering and reporting.

### 3. Feedback UI

#### Goal: Display AI feedback clearly and helpfully for each studentâ€™s submission.

##### User stories:

- As a teacher, I want to view AI-generated feedback per student with syntax-highlighted code.
- As a teacher, I want common issues or coding patterns visually highlighted.
- As a user, I want the ability to toggle views between individual feedback and group insights.

##### Suggestions:

- Add collapsible sections and tags (e.g., logic, naming, performance) for better navigation.
- Consider future read-only student access UI for feedback transparency and self-learning.

### 4. Reporting Tools

#### Goal: Aggregate and export meaningful summaries of student feedback and performance.

##### User stories:

- As a teacher, I want to generate group-level summaries to identify widespread challenges.
- As a teacher, I want to export all feedback and points as a CSV file for grading or archival purposes.
- As a teacher, I want to see submission trends over time to evaluate class progress.

##### Suggestions:

- Include analytics like â€œtop 5 common issuesâ€ or â€œaverage feedback scoreâ€ per assignment.
- Allow optional filters (by student, assignment, or issue type) when generating reports.

### 5. Project Infrastructure

#### Goal: Support scalable development and deployment through reliable tooling.

##### User stories:

- As a developer, I want Docker containers for both frontend and backend to ensure consistency across environments.
- As a team, I want a basic CI/CD pipeline to run tests and deploy the app automatically (optional in MVP).
- As a developer, I want a documented deployment plan (e.g., Vercel for frontend, Render/Fly.io/Heroku for backend, optional in MVP).

##### Suggestions:

- Add environment variable management and secrets handling early on (e.g., .env, GitHub secrets).
- Plan for rate limits and retries when integrating with GitHub or AI APIs.
</file>

<file path="docs/PROJECT_PLAN.md">
# Project Plan

## Team Members and Roles

- [Helmi Griffiths](https://github.com/HelmiGr) - Full Stack developer
- [Sam Chou](https://github.com/FuzzyKala) - Full Stack developer
- [Ville Matilainen](https://github.com/vima20) - Full Stack developer

## Working Methods

- Daily check-ins on working day[11 AM]
- GitHub [Project board](https://github.com/orgs/Summer-project-25-AI-Feedback-system/projects/1) to manage tasks
- Time tracking in [Time Sheet](https://unioulu-my.sharepoint.com/:x:/r/personal/t3chsa01_students_oamk_fi/_layouts/15/Doc.aspx?sourcedoc=%7B7D663633-A44C-426A-B63D-24642BF47BFC%7D&file=worked_hours.xlsx&action=default&mobileredirect=true)

## Sprint Goals

### Sprint 1 (Setup & Planning)

- Set up development environment
- Create architecture and wireframes
- Agree on tech stack and workflow

### Sprint 2 (GitHub API & Prompting)

- Implement OAuth login
- Read student repositories
- Design and test initial AI prompts

### Sprint 3 (AI Feedback & UI Integration)

- Send code to AI and receive response
- Display feedback in frontend
- Refine prompt structure

### Sprint 4 (Reporting & Finalization)

- Generate summary reports
- Implement CSV export
- Final documentation and testing

## Risks and Mitigation

- AI API cost â†’ Limit test requests
- Prompt quality â†’ Peer review
- Time management â†’ Weekly deadlines
</file>

<file path="docs/REQUIREMENTS.md">
# Functional Requirements

## User Roles

- **Teacher**: Authenticates via GitHub, views student submissions, reviews AI-generated feedback, generates summary reports, and exports data as CSV.
- **Student** (optional): May access personal feedback in future versions.

## MVP Requirements

- GitHub OAuth login for authentication
- List and fetch student repositories from GitHub Classroom
- Analyze code submissions using AI (OpenAI/DeepSeek)
- Display per-student feedback in the web UI
- Generate aggregated summary reports (e.g., most common issues, success rates)
- Export detailed feedback and grading data as a CSV file

## User Stories

- As a teacher, I want to authenticate via GitHub so I can access my studentsâ€™ repositories.
- As a teacher, I want to view AI-generated feedback for each student submission to save review time.
- As a teacher, I want to download a CSV file with feedback and points to simplify grading.
- As a teacher, I want to see common errors and patterns across submissions to guide class instruction.

## Non-Functional Requirements

- The system must work reliably on modern browsers (Chrome, Firefox, Edge).
- API keys and secrets must be securely stored on the server and never exposed to the frontend.
- The response time from the AI feedback engine should be under 5 seconds to ensure a smooth user experience.
- The system should be containerized (via Docker) to support easy deployment and consistent development environments.
</file>

<file path="server/.dockerignore">
# Ignore node_modules (since we install dependencies in Docker)
node_modules/

# Ignore logs and temp files
*.log
*.tmp
*.swp

# Ignore environment files (make sure not to include .env files in your image)
.env
.env.* 

# Ignore Git-related files and directories
.git/
.gitignore

# Ignore Docker files (you don't want to copy the Dockerfile itself)
Dockerfile
.dockerignore

# Ignore package manager logs (npm-debug.log, yarn-error.log)
npm-debug.log*
yarn-error.log*

# Ignore build and dist directories (as the image should be built within Docker)
dist/
build/

# Ignore any IDE specific files (like VS Code, JetBrains, etc.)
.vscode/
.idea/

# Ignore other temporary files
*.bak
*.orig

.env*
.flaskenv*
!.env.project
!.env.vault
</file>

<file path="server/Aievolution.ts">
import * as fs from "fs/promises";
import axios from "axios";
import * as dotenv from "dotenv";
import * as nodemailer from "nodemailer";
import path from "path";
import { simpleGit, SimpleGit } from "simple-git";
import { existsSync } from "fs";
import { resolve } from "path";

// Load environment variables from .env file
dotenv.config();

// OpenAI API response types
interface OpenAIResponse {
  choices: Array<{
    message: {
      content: string;
    };
  }>;
}

// Create email transporter
const createTransporter = () => {
  if (!process.env.GMAIL_USER || !process.env.GMAIL_APP_PASSWORD) {
    throw new Error("Gmail credentials missing from .env file");
  }

  return nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: process.env.GMAIL_USER,
      pass: process.env.GMAIL_APP_PASSWORD,
    },
  });
};

// Wait for specified time
const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

// Get all XML files from output directory
async function getXmlFiles(dir: string): Promise<string[]> {
  try {
    const files = await fs.readdir(dir);
    return files.filter((f) => f.endsWith(".xml")).map((f) => `${dir}/${f}`);
  } catch (error) {
    console.error("Error reading directory:", error);
    return [];
  }
}

// Split large XML file into smaller chunks
function splitXmlIntoChunks(
  xmlContent: string,
  maxChunkSize: number = 15000
): string[] {
  const chunks: string[] = [];
  let currentChunk = "";

  // Split XML line by line
  const lines = xmlContent.split("\n");

  for (const line of lines) {
    // If current chunk + new line is too large, save chunk and start new one
    if ((currentChunk + line).length > maxChunkSize) {
      if (currentChunk) {
        chunks.push(currentChunk);
        currentChunk = "";
      }
      // If single line is too long, split it into smaller parts
      if (line.length > maxChunkSize) {
        const subChunks =
          line.match(new RegExp(`.{1,${maxChunkSize}}`, "g")) || [];
        chunks.push(...subChunks);
      } else {
        currentChunk = line;
      }
    } else {
      currentChunk += (currentChunk ? "\n" : "") + line;
    }
  }

  if (currentChunk) {
    chunks.push(currentChunk);
  }

  return chunks;
}

// Get value from .env file
const DAILY_CALL_LIMIT = parseInt(process.env.DAILY_CALL_LIMIT || "10");
const WEEKLY_CALL_LIMIT = parseInt(process.env.WEEKLY_CALL_LIMIT || "50");

// Counters
let dailyCallCount = 0;
let weeklyCallCount = 0;
let lastDailyReset = new Date();
let lastWeeklyReset = new Date();

async function checkRateLimits(repoPath: string): Promise<boolean> {
  try {
    const git: SimpleGit = simpleGit(repoPath);

    // Get latest commit
    const lastCommit = await git.revparse(["HEAD"]);

    const dailyCommits = await git.log(['--since="24 hours ago"']);
    const weeklyCommits = await git.log(['--since="7 days ago"']);

    // Check daily limit
    if (dailyCommits.total >= DAILY_CALL_LIMIT) {
      console.log(`Daily AI call limit reached (${DAILY_CALL_LIMIT})`);
      return false;
    }

    if (weeklyCommits.total >= WEEKLY_CALL_LIMIT) {
      console.log(`Weekly AI call limit reached (${WEEKLY_CALL_LIMIT})`);
      return false;
    }

    return true;
  } catch (error) {
    console.error("Error checking rate limits:", error);
    return false;
  }
}

// Add these interfaces
interface TokenUsage {
  organizationId: string;
  tokens: number;
  timestamp: number;
}

interface RepoSize {
  organizationId: string;
  size: number;
  lastChecked: number;
}

// Add these variables
const tokenUsageMap = new Map<string, TokenUsage[]>();
const repoSizeMap = new Map<string, RepoSize>();
const MAX_TOKENS_PER_DAY = 1000000; // 1M tokens per day
const MAX_REPO_SIZE = 100000000; // 100MB

// Add this function for token usage tracking
async function trackTokenUsage(organizationId: string, tokens: number) {
  const now = Date.now();
  const dayAgo = now - 24 * 60 * 60 * 1000;

  // Get organization's token usage
  let usage = tokenUsageMap.get(organizationId) || [];

  // Remove old entries (older than 24h)
  usage = usage.filter((u) => u.timestamp > dayAgo);

  // Add new entry
  usage.push({
    organizationId,
    tokens,
    timestamp: now,
  });

  // Update usage
  tokenUsageMap.set(organizationId, usage);

  // Calculate total daily usage
  const dailyUsage = usage.reduce((sum, u) => sum + u.tokens, 0);

  // Check if limit is exceeded
  if (dailyUsage > MAX_TOKENS_PER_DAY) {
    throw new Error(
      `Organization ${organizationId} token usage limit exceeded. Used: ${dailyUsage}, Limit: ${MAX_TOKENS_PER_DAY}`
    );
  }
}

// Add this function to check repository size
async function checkRepoSize(organizationId: string, repoPath: string) {
  const now = Date.now();
  const lastChecked = repoSizeMap.get(organizationId)?.lastChecked || 0;

  // Check size only once per hour
  if (now - lastChecked < 60 * 60 * 1000) {
    return;
  }

  try {
    // Calculate repository size
    const size = await calculateRepoSize(repoPath);

    // Update size
    repoSizeMap.set(organizationId, {
      organizationId,
      size,
      lastChecked: now,
    });

    // Check if limit is exceeded
    if (size > MAX_REPO_SIZE) {
      console.warn(
        `Warning: Repository size exceeds recommended limit. Size: ${size}, Limit: ${MAX_REPO_SIZE}`
      );
      // Don't throw error, continue processing
      return;
    }
  } catch (error) {
    console.error("Error checking repo size:", error);
    // Don't throw error, continue processing
  }
}

// Add this function to calculate repository size
async function calculateRepoSize(repoPath: string): Promise<number> {
  let totalSize = 0;

  async function calculateDirSize(dir: string) {
    const files = await fs.readdir(dir);

    for (const file of files) {
      const filePath = path.join(dir, file);
      const stats = await fs.stat(filePath);

      if (stats.isDirectory()) {
        await calculateDirSize(filePath);
      } else {
        totalSize += stats.size;
      }
    }
  }

  await calculateDirSize(repoPath);
  return totalSize;
}

// Update interface for GitHub stats to match terminal output
interface GitHubStats {
  organizationId: string;
  repoPath: string;
  analysis: {
    timestamp: string;
    lastCommit: {
      hash: string;
      time: string;
    };
    repository: {
      totalCommits: number;
      sizeInMB: number;
      changes24h: number;
    };
    warnings: {
      highCommitCount: boolean;
      largeRepoSize: boolean;
    };
  };
}

// Update function to save GitHub stats to JSON
async function saveGitHubStats(stats: GitHubStats) {
  const outputDir = "output";
  const statsFile = path.join(outputDir, "github_stats.json");

  try {
    // Create output directory if it doesn't exist
    await fs.mkdir(outputDir, { recursive: true });

    // Read existing stats if file exists
    let allStats: GitHubStats[] = [];
    try {
      const existingData = await fs.readFile(statsFile, "utf-8");
      allStats = JSON.parse(existingData);
    } catch (error) {
      // File doesn't exist or is invalid, start with empty array
      allStats = [];
    }

    // Add new stats
    allStats.push(stats);

    // Save updated stats
    await fs.writeFile(statsFile, JSON.stringify(allStats, null, 2), "utf-8");
    console.log(`GitHub stats saved to ${statsFile}`);
  } catch (error) {
    console.error("Error saving GitHub stats:", error);
  }
}

// Add interface for Git info
interface GitInfo {
  organizationId: string;
  repoPath: string;
  lastCommit: string;
  lastCommitTime: number;
  lastChecked: number;
  size: number;
  commitCount: number;
}

// Add variable for storing Git info
const gitInfoMap = new Map<string, GitInfo>();

// Update checkGitRepo function
async function checkGitRepo(organizationId: string, repoPath: string) {
  const now = Date.now();
  const lastChecked = gitInfoMap.get(organizationId)?.lastChecked || 0;

  // Check only once per hour
  if (now - lastChecked < 60 * 60 * 1000) {
    console.log(`Git info was checked recently, using cached value`);
    return;
  }

  const absoluteRepoPath = resolve(repoPath); // âœ… Resolve to absolute path

  if (!existsSync(absoluteRepoPath)) {
    throw new Error(`Git repo path does not exist: ${absoluteRepoPath}`);
  }

  console.log(`[checkGitRepo] Using repoPath: ${absoluteRepoPath}`);

  try {
    console.log(`Analyzing Git repository for ${organizationId}...`);
    const git: SimpleGit = simpleGit(repoPath);

    // Get latest commit and its time
    const lastCommit = await git.revparse(["HEAD"]);
    const lastCommitInfo = await git.show(["--format=%at", "-s", lastCommit]);
    const lastCommitTime = parseInt(lastCommitInfo) * 1000; // Convert to milliseconds

    console.log(`Last commit: ${lastCommit}`);
    console.log(
      `Last commit time: ${new Date(lastCommitTime).toLocaleString()}`
    );

    // Get commit count
    const commitCount = (await git.log()).total;
    console.log(`Total commits: ${commitCount}`);

    // Get repository size
    const size = await calculateRepoSize(repoPath);
    const sizeInMB = size / (1024 * 1024);
    console.log(`Repository size: ${sizeInMB.toFixed(2)} MB`);

    // Get changes in last 24h
    const changes = await git.log(['--since="24 hours ago"']);
    console.log(`Changes in last 24h: ${changes.total} commits`);

    // Check for warnings
    const highCommitCount = changes.total > 50;
    const largeRepoSize = size > MAX_REPO_SIZE;

    if (highCommitCount) {
      console.warn(
        `Warning: High number of commits in last 24h (${changes.total})`
      );
    }

    if (largeRepoSize) {
      console.warn(`Warning: Repository size exceeds limit`);
    }

    // Create stats object matching terminal output
    const stats: GitHubStats = {
      organizationId,
      repoPath,
      analysis: {
        timestamp: new Date(now).toLocaleString(),
        lastCommit: {
          hash: lastCommit,
          time: new Date(lastCommitTime).toLocaleString(),
        },
        repository: {
          totalCommits: commitCount,
          sizeInMB: parseFloat(sizeInMB.toFixed(2)),
          changes24h: changes.total,
        },
        warnings: {
          highCommitCount,
          largeRepoSize,
        },
      },
    };

    // Save stats to JSON
    await saveGitHubStats(stats);

    // Update Git info map
    gitInfoMap.set(organizationId, {
      organizationId,
      repoPath,
      lastCommit,
      lastCommitTime,
      lastChecked: now,
      size,
      commitCount,
    });
  } catch (error) {
    console.error("Error checking Git repository:", error);
  }
}

// Add new interface for evaluation tracking
interface EvaluationRecord {
  submissionId: string;
  timestamp: number;
  evaluatedBy: "AI" | "TEACHER";
  teacherId?: string;
}

// Add new Map for evaluation tracking
const evaluationHistory = new Map<string, EvaluationRecord[]>();

// Modify hasBeenEvaluated function
async function hasBeenEvaluated(file: string): Promise<{
  evaluated: boolean;
  needsUpdate: boolean;
  lastEvaluation: EvaluationRecord | null;
}> {
  const submissionId = path.basename(file, ".xml");
  const markdownFile = path.join("output", "ASSIGNMENT_EVALUATION.md");

  try {
    const xmlLastModified = await getLastModifiedTime(file);
    const markdownLastModified = await getLastModifiedTime(markdownFile);

    const gitInfo = gitInfoMap.get("org123");
    const lastCommitTime = gitInfo?.lastCommitTime || 0;

    const needsUpdate =
      xmlLastModified > markdownLastModified ||
      lastCommitTime > markdownLastModified;

    const evaluations = evaluationHistory.get(submissionId) || [];
    const lastEvaluation = evaluations[evaluations.length - 1] || null;

    if (lastEvaluation?.evaluatedBy === "AI") {
      return {
        evaluated: true,
        needsUpdate: false,
        lastEvaluation,
      };
    }

    return {
      evaluated: true,
      needsUpdate: needsUpdate,
      lastEvaluation,
    };
  } catch {
    return {
      evaluated: false,
      needsUpdate: true,
      lastEvaluation: null,
    };
  }
}

// Add new function to record evaluations
async function recordEvaluation(
  submissionId: string,
  evaluatedBy: "AI" | "TEACHER",
  teacherId?: string
) {
  const evaluations = evaluationHistory.get(submissionId) || [];
  evaluations.push({
    submissionId,
    timestamp: Date.now(),
    evaluatedBy,
    teacherId,
  });
  evaluationHistory.set(submissionId, evaluations);
}

// Modify evaluateWithOpenAI function
export async function evaluateWithOpenAI(
  xmlContent: string,
  organizationId: string,
  repoPath: string
): Promise<string> {
  const submissionId = path.basename(repoPath, ".xml");

  // Check evaluation history
  const evaluations = evaluationHistory.get(submissionId) || [];
  const lastEvaluation = evaluations[evaluations.length - 1];

  if (lastEvaluation?.evaluatedBy === "AI") {
    throw new Error(
      "This submission has already been evaluated by AI. Please contact your teacher for re-evaluation."
    );
  }

  // Check Git repository
  await checkGitRepo(organizationId, repoPath);

  // Calculate token count
  const estimatedTokens = Math.ceil(xmlContent.length / 4);
  console.log(`Estimated token count: ${estimatedTokens}`);

  // Track token usage
  await trackTokenUsage(organizationId, estimatedTokens);

  // Check limits
  if (!(await checkRateLimits(repoPath))) {
    throw new Error("AI call limit reached. Try again later.");
  }

  // Increment counters
  dailyCallCount++;
  weeklyCallCount++;
  console.log(
    `Daily calls: ${dailyCallCount}, Weekly calls: ${weeklyCallCount}`
  );

  const apiKey = process.env.OPENAI_API_KEY?.trim();
  if (!apiKey) {
    throw new Error("OpenAI API key not found in .env file");
  }

  const endpoint = "https://api.openai.com/v1/chat/completions";

  // Leave room for prompt and response (about 1000 tokens)
  const maxContentTokens = 3000;

  // Truncate content if it's too long
  const truncatedContent =
    estimatedTokens > maxContentTokens
      ? xmlContent.substring(0, maxContentTokens * 4) +
        "\n... (content truncated)"
      : xmlContent;

  const prompt = `
You are a information technlogy teacher evaluating a student's project or code. Your goal is to provide constructive, concise, and actionable feedback that helps the student learn and improve. Analyze the following and rate it according to the following criteria:

1. Syntax and Validity (0-10): Is the code syntactically correct and does it run/compile without errors?

2. Structure and Organization (0-20): Is the code logically organized and are functions, classes, modules, and other language features used appropriately?

3. Clarity and Readability (0-20): Are the names of variables, functions, and classes descriptive? Is the code well-formed and easy to read?

4. Language-specific features (0-20): Does the code use features and best practices of the programming language in question (e.g., idiomatic constructs, error handling, etc.)?

5. Best practices (0-30): Does the code follow general and language-specific best practices (e.g., modularity, avoiding code duplication, proper error handling)?

Instructions:
- Analyze the code based on the criteria above.
- Provide a brief summary of the overall quality of the code, including strengths and areas for improvement.
- Give rates for each criteria and a total rating (0-5, where 0 is incomplete and 5 is excellent) based on the criteria.
- Keep the feedback clear, supportive, and instructive, student-friendly, and respectful.
- If the code seems unfinished or the context is unclear, note this and suggest possible improvements.
- If the code breaks in the middle of a function, note possible problems, but avoid speculative assumptions.

Student Code:
${truncatedContent}
`;

  let retries = 3;
  while (retries > 0) {
    try {
      console.log("Sending request to OpenAI API...");
      const response = await axios.post(
        endpoint,
        {
          model: "gpt-3.5-turbo",
          messages: [{ role: "user", content: prompt }],
          max_tokens: 1000,
          temperature: 0.3,
        },
        {
          headers: {
            Authorization: `Bearer ${apiKey}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (response.data?.choices?.[0]?.message?.content) {
        console.log("Response received from OpenAI API");
        // Record evaluation
        await recordEvaluation(submissionId, "AI");
        return response.data.choices[0].message.content;
      }
      throw new Error("Invalid response from OpenAI API");
    } catch (error: unknown) {
      if (error instanceof Error) {
        console.log(`Error calling OpenAI API: ${error.message}`);
      } else {
        console.log(`Unknown error calling OpenAI API: ${error}`);
      }
      if (axios.isAxiosError(error)) {
        if (error.response?.status === 401) {
          throw new Error("Invalid OpenAI API key. Check .env file.");
        }
        if (error.response?.status === 429) {
          console.log("Rate limit reached, waiting 20 seconds...");
          await sleep(20000);
          retries--;
          continue;
        }
      }
      if (retries === 1) throw error;
      retries--;
      await sleep(20000);
    }
  }

  throw new Error("Failed to get response from OpenAI API after all retries");
}

// Modify email sending function for Gmail
async function sendEmailFeedback(feedbackPath: string, studentEmail: string) {
  try {
    console.log("Attempting to send email...");

    if (!process.env.GMAIL_USER || !process.env.GMAIL_APP_PASSWORD) {
      throw new Error("Gmail credentials missing from .env file");
    }

    const transporter = nodemailer.createTransport({
      service: "gmail",
      auth: {
        user: process.env.GMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD,
      },
      tls: {
        rejectUnauthorized: false,
      },
    });

    // Check connection
    await transporter.verify();
    console.log("Email connection verified");

    const mailOptions = {
      from: process.env.GMAIL_USER,
      to: studentEmail,
      subject: "Assignment Evaluation",
      text: "Your assignment evaluation is attached to this email.",
      attachments: [
        {
          filename: "ASSIGNMENT_EVALUATION.md",
          path: feedbackPath,
        },
      ],
    };

    const info = await transporter.sendMail(mailOptions);
    console.log("Email sent successfully");
    return info;
  } catch (error: unknown) {
    if (error instanceof Error) {
      console.log(`Error sending email: ${error.message}`);
    } else {
      console.log("Unknown error sending email:", error);
    }
    throw error;
  }
}

interface EvaluationInfo {
  timestamp: number;
  lastModified: number;
}

async function getLastModifiedTime(file: string): Promise<number> {
  try {
    const stats = await fs.stat(file);
    return stats.mtime.getTime();
  } catch (error) {
    console.error(`Error getting file stats for ${file}:`, error);
    return 0;
  }
}

// Add this function to check token usage
async function getTokenUsage(organizationId: string): Promise<{
  dailyUsage: number;
  weeklyUsage: number;
  last24Hours: TokenUsage[];
}> {
  const now = Date.now();
  const dayAgo = now - 24 * 60 * 60 * 1000;
  const weekAgo = now - 7 * 24 * 60 * 60 * 1000;

  const usage = tokenUsageMap.get(organizationId) || [];

  return {
    dailyUsage: usage
      .filter((u) => u.timestamp > dayAgo)
      .reduce((sum, u) => sum + u.tokens, 0),
    weeklyUsage: usage
      .filter((u) => u.timestamp > weekAgo)
      .reduce((sum, u) => sum + u.tokens, 0),
    last24Hours: usage.filter((u) => u.timestamp > dayAgo),
  };
}

// Add function to get Git info
async function getGitInfo(
  organizationId: string
): Promise<GitInfo | undefined> {
  return gitInfoMap.get(organizationId);
}

// Fix error handling
async function handleError(error: unknown): Promise<never> {
  if (error instanceof Error) {
    console.log(`Error: ${error.message}`);
    throw error;
  }
  console.log("Unknown error occurred");
  throw new Error("Unknown error occurred");
}

// Modify main function
async function main() {
  try {
    // Check output directory
    await fs.access("output").catch(async () => {
      console.log("Creating output directory...");
      await fs.mkdir("output", { recursive: true });
    });

    const xmlFiles = await getXmlFiles("output");

    if (xmlFiles.length === 0) {
      console.log("No XML files found in output directory");
      return;
    }

    console.log(`Found ${xmlFiles.length} XML files to evaluate`);

    for (const file of xmlFiles) {
      try {
        // Check if file has been evaluated
        const evaluationStatus = await hasBeenEvaluated(file);

        if (evaluationStatus.evaluated && !evaluationStatus.needsUpdate) {
          console.log(
            `File ${file} has already been evaluated and is up to date. Skipping...`
          );
          continue;
        }

        if (evaluationStatus.evaluated && evaluationStatus.needsUpdate) {
          console.log(
            `File ${file} has been modified since last evaluation. Re-evaluating...`
          );
        }

        const xml = await fs.readFile(file, "utf-8");
        console.log(`Evaluating file ${file}...`);

        const feedback = await evaluateWithOpenAI(xml, "org123", path.dirname(file));

        // JÃ¤sennÃ¤ AI:n palaute
        const parsedFeedback = await parseAIFeedback(feedback);

        // Lasketaan kokonaisarvosana
        const overallRating = await calculateOverallRating(parsedFeedback.criteria);

        // Luo arviointitulokset
        const evaluationResult: EvaluationResult = {
          overallRating,
          criteria: parsedFeedback.criteria,
          summary: parsedFeedback.summary,
          metadata: {
            evaluationDate: new Date().toISOString(),
            submissionId: path.basename(file, ".xml"),
            repoName: path.basename(path.dirname(file)),
            assignmentName: "Assignment",
          },
        };

        // Tallenna markdown-tiedosto
        await saveEvaluationToMarkdown(evaluationResult, path.dirname(file));

        // LÃ¤hetÃ¤ sÃ¤hkÃ¶posti
        const studentEmail = "student@example.com";
        await sendEmailFeedback(
          path.join(path.dirname(file), "ASSIGNMENT_EVALUATION.md"),
          studentEmail
        );
        console.log(`Feedback sent via email to ${studentEmail}`);
      } catch (e: unknown) {
        if (e instanceof Error) {
          console.log(`Error evaluating file ${file}: ${e.message}`);
        } else {
          console.log("Unknown error evaluating file:", e);
        }
      }
    }
  } catch (error: unknown) {
    await handleError(error);
  }
}

// Kutsu main-funktiota
main().catch(console.error);

interface EvaluationCriteria {
  name: string;
  score: number;
  maxScore: number;
  comments: string[];
}

interface EvaluationResult {
  overallRating: number;
  criteria: EvaluationCriteria[];
  summary: string;
  metadata: {
    evaluationDate: string;
    submissionId: string;
    repoName: string;
    assignmentName: string;
  };
}

async function calculateOverallRating(
  criteria: EvaluationCriteria[]
): Promise<number> {
  const totalScore = criteria.reduce(
    (sum, criteria) => sum + criteria.score,
    0
  );
  const maxScore = criteria.reduce(
    (sum, criteria) => sum + criteria.maxScore,
    0
  );
  // Muunnetaan 100-pistejÃ¤rjestelmÃ¤stÃ¤ 5-pistejÃ¤rjestelmÃ¤Ã¤n
  return (totalScore / maxScore) * 5;
}

async function saveEvaluationToMarkdown(
  evaluationResult: EvaluationResult,
  repoPath: string
): Promise<void> {
  const evaluationPath = path.join("output", "ASSIGNMENT_EVALUATION.md");

  const evaluationDate = new Date(evaluationResult.metadata.evaluationDate);
  const formattedDate = evaluationDate.toLocaleDateString("fi-FI", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });

  // KÃ¤ytetÃ¤Ã¤n suoraan evaluationResult.overallRating
  const markdownContent = `# Assignment Evaluation

## Summary

${evaluationResult.summary}

Total Score: ${evaluationResult.overallRating.toFixed(1)}/5

## Metadata
- **Evaluation Date:** ${formattedDate}
- **Evaluation ID:** ${evaluationResult.metadata.submissionId}
- **Repository:** ${evaluationResult.metadata.repoName}
- **Assignment:** ${evaluationResult.metadata.assignmentName}
`;

  try {
    await fs.mkdir("output", { recursive: true });
    await fs.writeFile(evaluationPath, markdownContent, "utf-8");
    console.log(`Evaluation saved to ${evaluationPath}`);
  } catch (error) {
    console.error("Error saving evaluation to markdown:", error);
    throw error;
  }
}

interface ParsedFeedback {
  criteria: EvaluationCriteria[];
  summary: string;
}

async function parseAIFeedback(feedback: string): Promise<ParsedFeedback> {
  const criteria: EvaluationCriteria[] = [];

  // Syntax and Validity (0-10)
  const syntaxMatch = feedback.match(/Syntax and Validity\s*\((\d+)\/(\d+)\)/);
  if (syntaxMatch) {
    criteria.push({
      name: "Syntax and Validity",
      score: parseInt(syntaxMatch[1]),
      maxScore: parseInt(syntaxMatch[2]),
      comments: extractComments(feedback, "Syntax and Validity"),
    });
  }

  // Structure and Organization (0-20)
  const structureMatch = feedback.match(
    /Structure and Organization\s*\((\d+)\/(\d+)\)/
  );
  if (structureMatch) {
    criteria.push({
      name: "Structure and Organization",
      score: parseInt(structureMatch[1]),
      maxScore: parseInt(structureMatch[2]),
      comments: extractComments(feedback, "Structure and Organization"),
    });
  }

  // Clarity and Readability (0-20)
  const clarityMatch = feedback.match(
    /Clarity and Readability\s*\((\d+)\/(\d+)\)/
  );
  if (clarityMatch) {
    criteria.push({
      name: "Clarity and Readability",
      score: parseInt(clarityMatch[1]),
      maxScore: parseInt(clarityMatch[2]),
      comments: extractComments(feedback, "Clarity and Readability"),
    });
  }

  // Language-specific features (0-20)
  const languageMatch = feedback.match(
    /Language-specific features\s*\((\d+)\/(\d+)\)/
  );
  if (languageMatch) {
    criteria.push({
      name: "Language-specific Features",
      score: parseInt(languageMatch[1]),
      maxScore: parseInt(languageMatch[2]),
      comments: extractComments(feedback, "Language-specific features"),
    });
  }

  // Best practices (0-30)
  const practicesMatch = feedback.match(/Best practices\s*\((\d+)\/(\d+)\)/);
  if (practicesMatch) {
    criteria.push({
      name: "Best Practices",
      score: parseInt(practicesMatch[1]),
      maxScore: parseInt(practicesMatch[2]),
      comments: extractComments(feedback, "Best practices"),
    });
  }

  // Poistetaan kaikki Overall Rating -rivit yhteenvedosta
  const summary = feedback
    .replace(/Overall Rating: \d+\/5\n/g, "")
    .replace(/Overall Rating: \d+\/5/g, "")
    .trim();

  return {
    criteria,
    summary,
  };
}

function extractComments(feedback: string, criteriaName: string): string[] {
  const comments: string[] = [];
  const lines = feedback.split("\n");
  let isInCriteria = false;

  for (const line of lines) {
    if (line.includes(criteriaName)) {
      isInCriteria = true;
      continue;
    }
    if (isInCriteria && line.trim().startsWith("-")) {
      comments.push(line.trim().substring(1).trim());
    }
    if (isInCriteria && line.trim() === "") {
      isInCriteria = false;
    }
  }

  return comments;
}
</file>

<file path="server/AssignmentsService.ts">
import { supabase } from "./utils/supabase";

export async function saveAssignment(name: string, githubUrl: string) {
  const { data, error } = await supabase
    .from("assignments")
    .insert([{ name, github_url: githubUrl }]);

  if (error) {
    console.error("Supabase error:", error);
    throw error;
  }
}
</file>

<file path="server/controllers/aiController.ts">
import { Request, Response } from "express";
import { runRepomix, runAIEvolution } from "../services/ai/aiService";

export async function handleRunRepomix(
  req: Request,
  res: Response
): Promise<void> {
  const { repoUrl } = req.body;

  if (!repoUrl) {
    res.status(400).json({ error: "Missing repoUrl" });
    return;
  }

  try {
    const xmlOutput = await runRepomix(repoUrl);
    const encoded = Buffer.from(xmlOutput, "utf-8").toString("base64");
    res.json({ xml: encoded });
  } catch (error) {
    console.error("Repomix error:", error);
    res.status(500).json({ error: "Failed to run repomix" });
  }
}

export async function handleRunAIEvolution(
  req: Request,
  res: Response
): Promise<void> {
  const { xml: base64Xml, organizationId, repoPath } = req.body;

  console.log("[Controller] Submitting repoPath to AIEvolution:", repoPath);

  if (!base64Xml || !organizationId || !repoPath) {
    res.status(400).json({ error: "Missing xml, organizationId, or repoPath" });
    return;
  }

  try {
    const xml = Buffer.from(base64Xml, "base64").toString("utf-8");
    const feedback = await runAIEvolution(xml, organizationId, repoPath);
    res.json({ feedback });
  } catch (error) {
    console.error("AIEvolution error:", error);
    res.status(500).json({ error: "Failed to run AIEvolution" });
  }
}
</file>

<file path="server/controllers/authController.ts">
import { Request, Response } from "express";
import dotenv from "dotenv";
dotenv.config();

export const githubCallback = (req: Request, res: Response) => {
  // console.log("Authenticated user:", req.user);
  res.redirect(`${process.env.FRONTEND_ORIGIN}/orgs`);
};

export const getCurrentUser = (req: Request, res: Response) => {
  res.json({ user: req.user });
};

export const logout = (req: Request, res: Response) => {
  req.logout((err) => {
    if (err) {
      return res.status(500).json({ error: "Logout failed" });
    }
    req.session.destroy(() => {
      res.clearCookie("connect.sid");
      res.status(200).json({ message: "Logged out successfully" });
    });
  });
};
</file>

<file path="server/controllers/githubController.ts">
import { Request, Response } from "express";
import { extractAssignmentName } from "../utils/githubUtils";
import {
  getOrganizations,
  getAssignments,
  getStudentReposForAssignment,
  getCommits,
  getRepoTree,
  getFileContents,
  compareCommits,
} from "../services/github/githubService";

export async function handleGetOrganizations(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const orgs = await getOrganizations();
    res.json(orgs);
  } catch (error) {
    console.error("Failed to fetch organizations:", error);
    res.status(500).json({ error: "Failed to fetch organizations" });
  }
}

export async function handleGetAssignments(
  req: Request,
  res: Response
): Promise<void> {
  const orgName = req.params.orgName;

  if (!orgName) {
    res.status(400).json({ error: "Organization login not provided" });
    return;
  }

  try {
    const assignments = await getAssignments(orgName);
    res.json(assignments);
  } catch (error: any) {
    console.error("Failed to fetch assignments:", error);
    res.status(500).json({ error: "Failed to fetch assignments" });
  }
}

export async function handleGetStudentReposForAssignment(
  req: Request,
  res: Response
): Promise<void> {
  const orgName = req.params.orgName;
  const assignmentName = req.params.assignmentName;

  if (!orgName) {
    res.status(400).json({ error: "Missing organization or assignment name" });
    return;
  }

  try {
    const repos = await getStudentReposForAssignment(orgName, assignmentName);
    res.json(repos);
  } catch (error) {
    console.error("Failed to fetch student repos:", error);
    res.status(500).json({ error: "Failed to fetch student repos" });
  }
}

export async function handleGetCommits(
  req: Request,
  res: Response
): Promise<void> {
  const { orgName, repoName } = req.params;

  try {
    const commits = await getCommits(orgName, repoName);
    res.json(commits);
  } catch (error) {
    console.error("Failed to fetch commits:", error);
    res.status(500).json({ error: "Failed to fetch commits" });
  }
}

export async function handleGetRepoTree(
  req: Request,
  res: Response
): Promise<void> {
  const { orgName, repoName } = req.params;

  if (!orgName || !repoName) {
    res
      .status(400)
      .json({ error: "Organization and repository names are required" });
    return;
  }

  try {
    const tree = await getRepoTree(orgName as string, repoName as string);
    res.json(tree);
  } catch (error) {
    console.error("Failed to fetch repository tree:", error);
    res.status(500).json({ error: "Failed to fetch repository tree" });
  }
}

export async function handleGetFileContents(
  req: Request,
  res: Response
): Promise<void> {
  const { orgName, repoName } = req.params;
  const path = req.query.path as string;

  if (!orgName || !repoName || !path) {
    res.status(400).json({
      error: "Organization, repository and path are required",
    });
    return;
  }

  try {
    const contents = await getFileContents(orgName, repoName, path);
    if (contents === null) {
      res.status(404).json({ error: "File not found" });
      return;
    }
    res.json(contents);
  } catch (error) {
    console.error("Failed to fetch file contents:", error);
    res.status(500).json({ error: "Failed to fetch file contents" });
  }
}

export async function handleCompareCommits(
  req: Request,
  res: Response
): Promise<void> {
  const orgName = req.params.orgName;
  const repoName = req.params.repoName;
  const base = req.params.base;
  const head = req.params.head;

  if (!orgName || !repoName || !base || !head) {
    res.status(400).json({
      error: "Organization, repository, base and head commits are required",
    });
    return;
  }

  try {
    const comparison = await compareCommits(orgName, repoName, base, head);
    res.json(comparison);
  } catch (error) {
    console.error("Failed to compare commits:", error);
    res.status(500).json({ error: "Failed to compare commits" });
  }
}

export async function handleGetAllOrganizationData(
  req: Request,
  res: Response
): Promise<void> {
  const org = req.query.org as string;
  if (!org) {
    res.status(400).json({ error: "Missing organization parameter" });
    return;
  }
  try {
    const repos = await getStudentReposForAssignment(org);
    const assignmentSet = new Set<string>();
    const studentMap = new Map<string, Record<string, null>>();
    for (const repo of repos) {
      const assignment = extractAssignmentName(repo.name);
      assignmentSet.add(assignment);
      const student = repo.collaborators?.[0]?.name || "Unknown Student";
      // TODO: get grade here later from the db (as given by the AI)
      if (!studentMap.has(student)) {
        studentMap.set(student, {});
      }
      studentMap.get(student)![assignment] = null;
    }
    const responseData = {
      org,
      assignments: Array.from(assignmentSet),
      submissions: Array.from(studentMap.entries()).map(
        ([student, grades]) => ({
          student,
          grades, // all values null for now
        })
      ),
    };
    res.json(responseData);
  } catch (error) {
    console.error("Failed to get all data:", error);
    res.status(500).json({ error: "Failed to generate all data" });
  }
}
</file>

<file path="server/Dockerfile">
# 1. Base image
FROM node:22-alpine
LABEL org.opencontainers.image.source="https://github.com/Summer-project-25-AI-Feedback-system/AFS"

# 2. Set working directory
WORKDIR /app

# 3. Copy package files and install deps
COPY server/package*.json ./server/
RUN cd server && npm install

# 4. Copy server code and shared interfaces
COPY . .

# 5. Build TypeScript
WORKDIR /app/server
RUN npm run build

# 6. Expose port
EXPOSE 5000

# 7. Start app
CMD ["node", "dist/server/index.js"]
</file>

<file path="server/index.ts">
import express from "express";
import session from "express-session";
import passport from "./utils/passport";
import cors from "cors";
import dotenv from "dotenv";
import authRoutes from "./routes/authRoutes";
import githubRoutes from "./routes/githubRoutes";
import submitRoute from "./routes/submitRoute";
import uploadCsvRoute from "./routes/uploadCsvRoute";
import aiRoutes from "./routes/aiRoutes";

dotenv.config();

const app = express();
const PORT = process.env.PORT || 5000;

app.use(
  cors({
    origin: process.env.FRONTEND_ORIGIN,
    credentials: true,
  })
);

app.use(express.json());
app.use(express.urlencoded({ extended: false }));

// Set up session
app.use(
  session({
    secret: process.env.SESSION_SECRET || "secret",
    resave: false,
    saveUninitialized: true,
    cookie: {
      httpOnly: true,
      secure: false, // Set to true only in production (HTTPS)
      sameSite: "lax", // or "none" if secure: true for cross-origin
    },
  })
);

// Initialize passport
app.use(passport.initialize());
app.use(passport.session());

// test message
app.get("/api/message", (req, res) => {
  res.json({ message: "Test message from backend!" });
});

// Routes
app.use("/api/auth", authRoutes);
app.use("/api/github", githubRoutes);
app.use("/api/evaluation", aiRoutes);
app.use("/submit", submitRoute);
app.use("/api", uploadCsvRoute);

// Error handling
app.use(
  (
    err: any,
    req: express.Request,
    res: express.Response,
    next: express.NextFunction
  ) => {
    console.error(err.stack);
    res.status(500).json({ error: "Something went wrong!" });
  }
);

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
</file>

<file path="server/middlewares/isAuthenticated.ts">
import { Request, Response, NextFunction } from "express";

export const isAuthenticated = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  if (req.isAuthenticated && req.isAuthenticated()) {
    return next();
  }
  res.status(401).json({ error: "Unauthorized" });
};
</file>

<file path="server/output/AI-Feedback-System.xml">
This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules/*, dist/*, build/*, *.md, *.log, *.lock, *.json, *.yml, *.yaml, *.xml, *.txt, *.gitignore, *.editorconfig, *.prettierrc, *.eslintrc, *.env, *.env.*, *.config.js, *.config.ts, *.d.ts, *.map, *.min.js, *.min.css, *.ico, *.png, *.jpg, *.jpeg, *.gif, *.svg, *.woff, *.woff2, *.ttf, *.eot, *.otf, *.mp3, *.mp4, *.webm, *.webp, *.zip, *.tar, *.gz, *.rar, *.7z, *.pdf, *.doc, *.docx, *.xls, *.xlsx, *.ppt, *.pptx, *.csv, *.tsv, *.sql, *.bak, *.tmp, *.temp, *.swp, *.swo, *.swn, *.sublime-workspace, *.sublime-project, *.vscode/*, *.idea/*, *.DS_Store, Thumbs.db
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/eslint.config.js
client/index.html
client/package.json
client/public/vite.svg
client/src/App.tsx
client/src/assets/react.svg
client/src/components/AssignmentList.tsx
client/src/components/BackButton.tsx
client/src/components/BasicButton.tsx
client/src/components/BasicHeading.tsx
client/src/components/basicList/BasicList.tsx
client/src/components/basicList/ListButton.tsx
client/src/components/basicList/ListHeader.tsx
client/src/components/basicList/ListItem.tsx
client/src/components/BasicSearchBar.tsx
client/src/components/FeedbackViewer.tsx
client/src/components/Footer.tsx
client/src/components/GetCSVFileButton.tsx
client/src/components/Header.tsx
client/src/components/SortableHeader.tsx
client/src/components/SortingButton.tsx
client/src/components/Spinner.tsx
client/src/components/Tabs.tsx
client/src/context/GitHubContext.ts
client/src/context/GitHubProvider.tsx
client/src/context/types.ts
client/src/context/useGitHub.ts
client/src/context/UserContext.ts
client/src/context/UserProvider.tsx
client/src/context/useUser.ts
client/src/hooks/useFilteredList.ts
client/src/index.css
client/src/layouts/MainLayout.tsx
client/src/main.tsx
client/src/pages/analyticsPage/AnalyticsPage.tsx
client/src/pages/analyticsPage/averageAssignmentPointsTab/AveragePointsChart.tsx
client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesCard.tsx
client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesChart.tsx
client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesCollapsible.tsx
client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesTab.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/MissingSubmissionsTab.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTable.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTableHeader.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTableRow.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTableWithTabs.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/Subtext.tsx
client/src/pages/analyticsPage/missingSubmissionsTab/UploadStudentRosterCSVButton.tsx
client/src/pages/assignmentPage/AssignmentsPage.tsx
client/src/pages/assignmentPage/sidebar/ProgressBar.tsx
client/src/pages/assignmentPage/sidebar/Sidebar.tsx
client/src/pages/assignmentPage/sidebar/SidebarButton.tsx
client/src/pages/assignmentPage/sidebar/SidebarCard.tsx
client/src/pages/assignmentPage/sidebar/SidebarPagination.tsx
client/src/pages/loginPage/LoginButton.tsx
client/src/pages/loginPage/LoginPage.tsx
client/src/pages/orgPage/OrgsPage.tsx
client/src/pages/repoDetailPage/CodeTab.tsx
client/src/pages/repoDetailPage/CommitsTab.tsx
client/src/pages/repoDetailPage/DiffTab.tsx
client/src/pages/repoDetailPage/FeedbackActions.tsx
client/src/pages/repoDetailPage/FeedbackCard.tsx
client/src/pages/repoDetailPage/FeedbackTab.tsx
client/src/pages/repoDetailPage/FileFeedbackSection.tsx
client/src/pages/repoDetailPage/FileTree.tsx
client/src/pages/repoDetailPage/MetadataTab.tsx
client/src/pages/repoDetailPage/RepoDetailPage.tsx
client/src/pages/repoDetailPage/RepoInfoCard.tsx
client/src/pages/repoPage/ReposPage.tsx
client/src/pages/SpecificUserSubmissionScreen.tsx
client/src/services/feedbackService.ts
client/src/services/submissionService.ts
client/src/types/AssignmentFeedback.ts
client/src/types/OrgReport.ts
client/src/types/StudentInfo.ts
client/src/types/StudentInStudentRoster.ts
client/src/types/StudentSubmissionInfo.ts
client/src/utils/feedbackUtils.ts
client/src/utils/generateCSVFromOrg.ts
client/src/utils/parseFileTree.ts
client/src/utils/sortingUtils.ts
client/src/vite-env.d.ts
client/tailwind.config.js
client/tsconfig.app.json
client/tsconfig.json
client/tsconfig.node.json
client/vite.config.ts
docs/ARCHITECTURE.md
docs/EPICS.md
docs/PROJECT_PLAN.md
docs/REQUIREMENTS.md
server/.dockerignore
server/Aievolution.ts
server/AssignmentsService.ts
server/controllers/aiController.ts
server/controllers/authController.ts
server/controllers/githubController.ts
server/Dockerfile
server/index.ts
server/middlewares/isAuthenticated.ts
server/output/ASSIGNMENT_EVALUATION.md
server/package.json
server/repomix.js
server/repomix.ts
server/routes/aiRoutes.ts
server/routes/authRoutes.ts
server/routes/githubRoutes.ts
server/routes/submitRoute.ts
server/routes/uploadCsvRoute.ts
server/services/ai/aiService.ts
server/services/github/githubService.ts
server/services/github/octokitClient.ts
server/services/UserService.ts
server/tsconfig.json
server/utils/githubUtils.ts
server/utils/json2csv.ts
server/utils/passport.ts
server/utils/supabase.ts
shared/aiInterfaces.ts
shared/githubInterfaces.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)
</file>

<file path="client/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitHub Classroom Analyzer</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="client/package.json">
{
  "name": "afs",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@heroicons/react": "^2.2.0",
    "@tailwindcss/vite": "^4.1.7",
    "axios": "^1.9.0",
    "chart.js": "^4.4.9",
    "papaparse": "^5.5.3",
    "react": "^19.1.0",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^19.1.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.5.3",
    "tailwindcss": "^4.1.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@types/node": "^22.15.18",
    "@types/papaparse": "^5.3.16",
    "@types/react": "^19.1.4",
    "@types/react-dom": "^19.1.5",
    "@vitejs/plugin-react": "^4.4.1",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.30.1",
    "vite": "^6.3.5",
    "vite-tsconfig-paths": "^5.1.4"
  }
}
</file>

<file path="client/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="client/src/App.tsx">
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import MainLayout from "./layouts/MainLayout";
import LoginPage from "./pages/loginPage/LoginPage";
import OrgsPage from "./pages/orgPage/OrgsPage";
import AssignmentsPage from "./pages/assignmentPage/AssignmentsPage";
import { UserProvider } from "./context/UserProvider";
import RepoDetailPage from "./pages/repoDetailPage/RepoDetailPage";
import { GitHubProvider } from "./context/GitHubProvider";
import ReposPage from "./pages/repoPage/ReposPage";
import SpecificUserSubmissionScreen from "./pages/SpecificUserSubmissionScreen";
import AnalyticsPage from './pages/analyticsPage/AnalyticsPage';

function App() {
  return (
    <GitHubProvider>
      <UserProvider>
        <Router>
          <Routes>
            <Route path="/" element={<MainLayout />}>
              <Route index element={<LoginPage />} />
              <Route path="/orgs" element={<OrgsPage />} />
              <Route
                path="/orgs/:orgName/assignments"
                element={<AssignmentsPage />}
              />
              <Route
                path="/orgs/:orgName/assignments/:assignmentName/repos"
                element={<ReposPage />}
              />
              <Route
                path="/orgs/:orgName/assignments/:assignmentName/repos/:repoId"
                element={<RepoDetailPage />}
              />
              <Route
                path="/orgs/:orgName/assignments/:assignmentName/submission"
                element={<SpecificUserSubmissionScreen />}
              />
              <Route 
                path="/orgs/:orgName/analytics"
                element={<AnalyticsPage />}
              />
              </Route>
          </Routes>
        </Router>
      </UserProvider>
    </GitHubProvider>
  );
}

export default App;
</file>

<file path="client/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="client/src/components/AssignmentList.tsx">
import { useEffect, useState } from "react";
import { fetchAssignments } from "../../../server/AssignmentsService";

const AssignmentList = () => {
  const [assignments, setAssignments] = useState<any[]>([]);

  useEffect(() => {
    const load = async () => {
      const data = await fetchAssignments();
      setAssignments(data);
    };
    load();
  }, []);

  return (
    <div>
      <h2>Assignments</h2>
      <ul>
        {assignments.map((a) => (
          <li key={a.id}>
            {a.title} (due: {a.due_date})
          </li>
        ))}
      </ul>
    </div>
  );
};

export default AssignmentList;
</file>

<file path="client/src/components/BackButton.tsx">
import { useNavigate } from "react-router-dom";
import { BiArrowBack } from "react-icons/bi";

type BackButtonProps = {
  to: string;
};

export default function BackButton({ to }: BackButtonProps) {
  const navigate = useNavigate();

  return (
    <button
      onClick={() => navigate(to)}
      className="flex items-center text-gray-600 round"
    >
      <BiArrowBack className="mr-2" size={20} />
    </button>
  );
}
</file>

<file path="client/src/components/BasicButton.tsx">
interface BasicButtonProps {
  text: string;
  onClick: () => void;
}

export default function BasicButton({ text, onClick }: BasicButtonProps) {
  return (
    <button
      onClick={onClick}
      className="flex items-center justify-center border border-[#D9D9D9] px-6 py-3 h-[40px] rounded-full w-[220px] gap-2 bg-[#1D1B20] hover:opacity-90 text-white"
    >
      <span className="text-xs sm:text-sm text-center">{text}</span>
    </button>
  );
}
</file>

<file path="client/src/components/BasicHeading.tsx">
interface BasicHeadingProps {
  heading?: string;
  styling?: string;
}

export default function BasicHeading({
  heading,
  styling = "",
}: BasicHeadingProps) {
  return <h1 className={`text-[29px] font-bold ${styling}`}>{heading}</h1>;
}
</file>

<file path="client/src/components/basicList/BasicList.tsx">
import { useNavigate } from "react-router-dom";
import ListHeader from "./ListHeader";
import ListItem from "./ListItem";
import type { StudentSubmissionInfo } from "../../types/StudentSubmissionInfo";
import type {
  AssignmentInfo,
  OrgInfo,
  RepoInfo,
} from "@shared/githubInterfaces";
import type { SortOption } from "src/utils/sortingUtils";

interface BasicListProps {
  type: "org" | "assignment" | "repo" | "submission";
  items: OrgInfo[] | AssignmentInfo[] | RepoInfo[] | StudentSubmissionInfo[];
  isLoading: boolean;
  orgName?: string;
  assignmentName?: string;
  sortOrder?: SortOption;
  onSortChange?: (option: SortOption) => void;
}

export default function BasicList(props: BasicListProps) {
  const navigate = useNavigate();
  const isEmpty = Array.isArray(props.items) && props.items.length === 0;

  return (
    <div className="flex flex-col">
      <ListHeader
        type={props.type}
        sortOrder={props.sortOrder}
        onSortChange={props.onSortChange}
      />

      {props.isLoading && <div className="text-gray-500 p-4">Loading...</div>}

      {!props.isLoading && isEmpty && (
        <div className="text-gray-500 p-4">No items found.</div>
      )}
      {!props.isLoading &&
        !isEmpty &&
        props.items.map((item, index) => {
          const key = `${props.type}-${index}`;

          switch (props.type) {
            case "org":
              return (
                <ListItem
                  key={key}
                  type="org"
                  data={item as OrgInfo}
                  onClick={() =>
                    navigate(`/orgs/${(item as OrgInfo).name}/assignments`)
                  }
                />
              );

            case "assignment":
              return (
                <ListItem
                  key={key}
                  type="assignment"
                  data={item as AssignmentInfo}
                  onClick={() =>
                    navigate(
                      `/orgs/${props.orgName}/assignments/${encodeURIComponent(
                        (item as AssignmentInfo).name
                      )}/repos`
                    )
                  }
                />
              );

            case "repo":
              return (
                <ListItem
                  key={key}
                  type="repo"
                  data={item as RepoInfo}
                  onClick={() =>
                    navigate(
                      `/orgs/${props.orgName}/assignments/${encodeURIComponent(
                        props.assignmentName!
                      )}/repos/${(item as RepoInfo).id}`,
                      { state: item }
                    )
                  }
                />
              );

            case "submission":
              return (
                <ListItem
                  key={key}
                  type="submission"
                  data={item as StudentSubmissionInfo}
                />
              );
          }
        })}
    </div>
  );
}
</file>

<file path="client/src/components/basicList/ListButton.tsx">
interface ListButtonProps {
  text: string;
}

export default function ListButton({ text }: ListButtonProps) {
  return (
    <button className="h-8 px-4 text-xs sm:text-sm bg-[#1D1B20] text-white rounded-full w-fit min-w-[100px]">
        {text}
    </button>
  )
}
</file>

<file path="client/src/components/basicList/ListHeader.tsx">
import type { SortOption } from "src/utils/sortingUtils";
import SortableHeader from "../../components/SortableHeader";

interface ListHeaderProps {
  type: "repo" | "submission" | "assignment" | "org";
  sortOrder?: SortOption;
  onSortChange?: (option: SortOption) => void;
}

export default function ListHeader({
  type,
  sortOrder,
  onSortChange,
}: ListHeaderProps) {
  if (type === "org") {
    return (
      <div className="grid grid-cols-[40px_1fr_1fr] h-[40px] bg-[#EADDFF] px-4 gap-2 items-center text-sm font-medium border rounded border-b border-l border-r border-[#D9D9D9]">
        <div />
        <SortableHeader
          label="Organization name"
          currentSort={sortOrder}
          ascValue="Aâ€“Z"
          descValue="Zâ€“A"
          onChange={onSortChange}
        />
        <p className="text-left">Description</p>
      </div>
    );
  }

  if (type === "assignment") {
    return (
      <div className="grid grid-cols-[40px_1fr_1fr_1fr] h-[40px] bg-[#EADDFF] px-4 gap-2 items-center text-sm font-medium border rounded border-b border-l border-r border-[#D9D9D9]">
        <div />
        <SortableHeader
          label="Assignment name"
          currentSort={sortOrder}
          ascValue="Aâ€“Z"
          descValue="Zâ€“A"
          onChange={onSortChange}
        />
        <SortableHeader
          label="Amount of Students"
          currentSort={sortOrder}
          ascValue="Amount of Students"
          descValue="Amount of Students (desc)"
          onChange={onSortChange}
          center
        />
        <SortableHeader
          label="Last updated"
          currentSort={sortOrder}
          ascValue="Oldest"
          descValue="Newest"
          onChange={onSortChange}
        />
      </div>
    );
  }

  if (type === "repo") {
    return (
      <div className="grid grid-cols-[40px_1fr_1fr_1fr] h-[40px] bg-[#EADDFF] px-4 gap-2 items-center text-sm font-medium border rounded border-b border-l border-r border-[#D9D9D9]">
        <div />
        <SortableHeader
          label="Repository name"
          currentSort={sortOrder}
          ascValue="Aâ€“Z"
          descValue="Zâ€“A"
          onChange={onSortChange}
        />
        <p className="text-center">Students</p>
        <SortableHeader
          label="Last updated"
          currentSort={sortOrder}
          ascValue="Oldest"
          descValue="Newest"
          onChange={onSortChange}
        />
      </div>
    );
  }

  if (type === "submission") {
    return (
      <div className="grid grid-cols-[40px_1fr_1fr_1fr] h-[40px] bg-[#EADDFF] px-4 gap-2 items-center text-sm font-medium border rounded border-b border-l border-r border-[#D9D9D9]">
        <div />
        <p className="text-center">Student</p>
        <p className="text-center">Submission status</p>
        <p className="text-center">Grade</p>
      </div>
    );
  }
}
</file>

<file path="client/src/components/basicList/ListItem.tsx">
import type { StudentSubmissionInfo } from "../../types/StudentSubmissionInfo";
import type {
  AssignmentInfo,
  OrgInfo,
  RepoInfo,
} from "@shared/githubInterfaces";

type ListItemProps =
  | { type: "org"; data: OrgInfo; onClick?: () => void }
  | { type: "assignment"; data: AssignmentInfo; onClick?: () => void }
  | { type: "repo"; data: RepoInfo; onClick?: () => void }
  | { type: "submission"; data: StudentSubmissionInfo; onClick?: () => void };

export default function ListItem(props: ListItemProps) {
  const commonClass =
    "h-[56px] px-4 gap-2 items-center text-sm hover:bg-gray-100 cursor-pointer border rounded border-[#D9D9D9] overflow-y-auto max-h-[calc(100vh-240px)]";

  let content;
  let className = "";

  switch (props.type) {
    case "org": {
      const org = props.data;
      className = `grid grid-cols-[40px_1fr_1fr] ${commonClass}`;
      content = (
        <>
          <img
            src={org.avatarUrl}
            alt={org.name}
            className="w-6 h-6 rounded-full"
          />
          <p className="text-left">{org.name}</p>
          <p className="text-left">{org.description || "No description"}</p>
        </>
      );
      break;
    }

    case "assignment": {
      const assignment = props.data;
      const assignmentName = assignment.name;
      const amountOfStudents = assignment.amountOfStudents;
      const updatedAt = new Date(assignment.updatedAt).toLocaleString();
      className = `grid grid-cols-[40px_1fr_1fr_1fr] ${commonClass}`;
      content = (
        <>
          <div className="w-6 h-6 rounded-full" />
          <p className="text-left">{assignmentName}</p>
          <p className="text-center">{amountOfStudents}</p>
          <p className="text-left">{updatedAt}</p>
        </>
      );
      break;
    }

    case "repo": {
      const repo = props.data;
      const avatar = repo.collaborators[0]?.avatarUrl || "";
      const students = repo.collaborators[0].name;
      const updatedAt = new Date(repo.updatedAt).toLocaleString();
      className = `grid grid-cols-[40px_1fr_1fr_1fr] ${commonClass}`;
      content = (
        <>
          <img src={avatar} alt="repo" className="w-6 h-6 rounded-full" />
          <p className="text-left">{repo.name}</p>
          <p className="text-center">{students}</p>
          <p className="text-left">{updatedAt}</p>
        </>
      );
      break;
    }

    case "submission": {
      const submission = props.data;
      className = `grid grid-cols-[40px_1fr_1fr_1fr_auto] ${commonClass} text-xs sm:text-sm`;
      content = (
        <>
          <img
            src={submission.studentProfilePicture}
            alt="student"
            className="w-6 h-6 rounded-full"
          />
          <p className="text-center">{submission.studentName}</p>
          <p className="text-center">{submission.submissionStatus}</p>
          <p className="text-center">{submission.currentGrade}</p>
        </>
      );
      break;
    }
  }

  return (
    <div className={className} onClick={props.onClick}>
      {content}
    </div>
  );
}
</file>

<file path="client/src/components/BasicSearchBar.tsx">
import { BiSearch } from "react-icons/bi";
import { RxCross1 } from "react-icons/rx";

interface BasicSearchBarProps {
  value: string;
  onChange: (value: string) => void;
}

export default function BasicSearchBar({
  value,
  onChange,
}: BasicSearchBarProps) {
  return (
    <div className="w-[360px] h-[56px] border border-[#D9D9D9] rounded-full flex items-center px-4">
      <input
        type="text"
        placeholder="Search by repository name or class"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className="flex-grow bg-transparent outline-none text-gray-800 placeholder-gray-500"
      />
      {value ? (
        <button
          onClick={() => onChange("")}
          className="text-gray-500 hover:text-gray-700"
        >
          <RxCross1 size={18} />
        </button>
      ) : (
        <BiSearch className="text-gray-500" size={20} />
      )}
    </div>
  );
}
</file>

<file path="client/src/components/FeedbackViewer.tsx">
import { useEffect, useState } from "react";
import { fetchFeedback } from "../services/feedbackService";

const FeedbackViewer = ({ submissionId }: { submissionId: number }) => {
  const [feedback, setFeedback] = useState<any[]>([]);

  useEffect(() => {
    const load = async () => {
      const data = await fetchFeedback(submissionId);
      setFeedback(data);
    };
    load();
  }, [submissionId]);

  return (
    <div>
      <h3>Feedback</h3>
      {feedback.map((f) => (
        <div key={f.id}>
          <strong>Score:</strong> {f.score}/100
          <p>{f.comments}</p>
        </div>
      ))}
    </div>
  );
};

export default FeedbackViewer;
</file>

<file path="client/src/components/Footer.tsx">
export default function Footer() {
  return (
    <footer className="w-full h-[99px] py-4 border-t border-[#D9D9D9] text-center text-lg text-gray-500">
      Footer
    </footer>
  )
}
</file>

<file path="client/src/components/GetCSVFileButton.tsx">
import { generateCSVFromOrg } from "../utils/generateCSVFromOrg";
import { useGitHub } from "../context/useGitHub";
import UserContext from "../context/UserContext"
import { useContext } from "react";
import { useNavigate } from "react-router-dom";
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";


interface GetCSVFileButtonProps {
  text: string;
  orgName: string | undefined;
  roster?: StudentInStudentRoster[];
  assignmentFilter?: string[];
}

// delete this later
const mockOrgData = {
  org: "Mock University",
  assignments: ["intro-to-data", "java-assignment", "css-intro-assignment"],
  submissions: [
    {
      student: "astronautie",
      grades: {
        "intro-to-data": 20,
        "java-assignment": 10,
        "css-intro-assignment": null,
      },
    },
    {
      student: "FuzzyKala",
      grades: {
        "intro-to-data": 18,
        "java-assignment": null, 
        "css-intro-assignment": null,
      },
    },
    {
      student: "vima20",
      grades: {
        "intro-to-data": 20,
        "java-assignment": 10,
        "css-intro-assignment": 30,
      },
    },
    {
      student: "nonRoster",
      grades: {
        "intro-to-data": null,
        "java-assignment": 15,
        "css-intro-assignment": 25,
      },
    },
  ],
};

export default function GetCSVFileButton({ text, orgName, roster, assignmentFilter }: GetCSVFileButtonProps) {
  const github = useGitHub();
  const navigate = useNavigate();
  const { user } = useContext(UserContext);
  const username = user?.username || "unknownuser";

  const handleClick = async () => {
    if (!orgName) return;
    if (!roster || roster.length === 0) {
      navigate(`/orgs/${orgName}/analytics?tab=missing-submissions`); 
      alert("A roster is required to generate the CSV report. Please upload a roster first.");
      return;
    }
    try {
      // const data = await github.getAllOrganizationData(orgName);
      const data = mockOrgData
      const filteredData = assignmentFilter ? {
        ...data,
        assignments: assignmentFilter,
        submissions: data.submissions.map((s: any) => ({ // change the type of s later
          ...s,
          grades: Object.fromEntries(
            Object.entries(s.grades || {}).filter(([k]) =>
              assignmentFilter.includes(k)
            )
          ),
        })),
      } : data;
      generateCSVFromOrg(filteredData, roster); 
      const response = await fetch("http://localhost:5000/api/csv-reports", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ rows: data,
           username: username }), 
      });
      const result = await response.json();
      if (!response.ok) {
        throw new Error(result.error || "Tallennus epÃ¤onnistui");
      }
      console.log("âœ… Data tallennettu Supabaseen"); 
    } catch (error) {
      console.error("ðŸš« Virhe tallennuksessa:", error);
    }
  };

  return (
    <button
      onClick={handleClick}
      className="flex items-center justify-between border border-[#D9D9D9] px-6 py-3 h-[40px] rounded-full w-fit min-w-[95px] gap-2 bg-[#1D1B20] hover:opacity-90 text-white"
    >
      <span className="text-xs sm:text-sm">{text}</span>
    </button>
  );
}
</file>

<file path="client/src/components/Header.tsx">
interface HeaderProps {
  loggedIn: boolean;
  onClick: () => void;
}

export default function Header({ onClick, loggedIn }: HeaderProps) {
  const text = loggedIn ? "Logout" : "Login";

  return (
    <header className="top-0 left-0 w-full h-[99px] border-b border-[#D9D9D9] px-8 py-8 flex items-center justify-between">
      <div className="flex-shrink-0">
        {/* the logo needs to be added or deleted fully if it's not needed */}
        <img src="/logo.svg" alt="Logo" className="h-full" />
      </div>
      <div className="flex items-center gap-6">
        <span className="text-lg text-[#1E1E1E]">Languages</span>
        <button
          onClick={onClick}
          className="bg-[#1D1B20] w-[148px] text-white text-lg px-4 py-2 rounded-full hover:opacity-90"
        >
          {text}
        </button>
      </div>
    </header>
  );
}
</file>

<file path="client/src/components/SortableHeader.tsx">
import type { SortOption } from "src/utils/sortingUtils";
import { IoIosArrowUp, IoIosArrowDown } from "react-icons/io";
import { FaMinus } from "react-icons/fa6";

export default function SortableHeader({
  label,
  currentSort,
  ascValue,
  descValue,
  onChange,
  center,
}: {
  label: string;
  currentSort: SortOption | undefined;
  ascValue: SortOption;
  descValue: SortOption;
  onChange?: (option: SortOption) => void;
  center?: boolean;
}) {
  const isAsc = currentSort === ascValue;
  const isDesc = currentSort === descValue;
  const isActive = isAsc || isDesc;

  return (
    <button
      onClick={() => {
        if (!onChange) return;
        onChange(isAsc ? descValue : ascValue);
      }}
      className={`flex items-center gap-1 ${center ? "justify-center" : ""}`}
    >
      {label}
      {isActive ? (
        isAsc ? (
          <IoIosArrowUp />
        ) : (
          <IoIosArrowDown />
        )
      ) : (
        <FaMinus className="text-gray-400" />
      )}
    </button>
  );
}
</file>

<file path="client/src/components/SortingButton.tsx">
import { useState } from "react";
import { BiSolidDownArrow } from "react-icons/bi";

interface FilterButtonProps {
  buttonText: string;
  items: string[];
  onSelect?: (value: string) => void;
}

export default function SortingButton({
  buttonText,
  items,
  onSelect,
}: FilterButtonProps) {
  const [isOpen, setIsOpen] = useState(false);
  const toggleDropdown = () => setIsOpen((prev) => !prev);

  const handleSelect = (item: string) => {
    onSelect?.(item);
    setIsOpen(false);
  };

  return (
    <div className="relative inline-block">
      <button
        onClick={toggleDropdown}
        className="flex items-center justify-between border border-[#D9D9D9] px-4 py-3 rounded-full w-fit min-w-[95px] gap-2 h-[56px]"
      >
        <span className="text-xs sm:text-sm text-[#1E1E1E]">{buttonText}</span>
        <BiSolidDownArrow
          className={`w-3 h-3 transition-transform duration-200 ${
            isOpen ? "" : "rotate-180"
          }`}
        />
      </button>
      {isOpen && (
        <ul className="absolute mt-2 w-full bg-white border border-[#D9D9D9] rounded-md shadow-md z-10">
          {items.map((item, index) => (
            <li
              key={index}
              className="px-4 py-2 hover:bg-gray-100 cursor-pointer text-sm text-[#1E1E1E]"
              onClick={() => handleSelect(item)}
            >
              {item}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
</file>

<file path="client/src/components/Spinner.tsx">
export default function Spinner() {
  return (
    <div className="flex items-center justify-center min-h-[200px]">
      <div className="h-8 w-8 animate-spin rounded-full border-4 border-gray-300 border-t-blue-500" />
    </div>
  );
}
</file>

<file path="client/src/components/Tabs.tsx">
import { useState, useEffect } from "react";
import type { ReactNode } from "react";

type Tab = {
  id: string;
  label: string;
  content: ReactNode;
}

type TabsProps = {
  tabs: Tab[];
  activeTab?: string;
  onTabChange?: (tabId: string) => void;
}

export default function Tabs({ tabs, activeTab: controlledTab, onTabChange } : TabsProps) {
  const [activeTab, setActiveTab] = useState(tabs[0].id);

 useEffect(() => {
    if (controlledTab && tabs.some((tab) => tab.id === controlledTab)) {
      setActiveTab(controlledTab);
    }
  }, [controlledTab, tabs]);

  const handleTabClick = (tabId: string) => {
    setActiveTab(tabId);
    onTabChange?.(tabId); 
  };

  return (
    <div className="flex flex-col space-y-4">
      <div className="flex border-b border-gray-200">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            onClick={() => handleTabClick(tab.id)}
            className={`px-4 py-2 text-sm font-medium ${
              activeTab === tab.id
                ? "border-b-2 border-blue-500 text-blue-600"
                : "text-gray-500 hover:text-gray-700"
            }`}
          >
            {tab.label}
          </button>
        ))}
      </div>
      <div>{tabs.find((tab) => tab.id === activeTab)?.content}</div>
    </div>
  );
}
</file>

<file path="client/src/context/GitHubContext.ts">
import { createContext } from "react";
import type { GitHubContextType } from "./types";

const GitHubContext = createContext<GitHubContextType | null>(null);
export default GitHubContext;
</file>

<file path="client/src/context/GitHubProvider.tsx">
import { useMemo } from "react";
import axios from "axios";
import GitHubContext from "./GitHubContext";
import type { GitHubContextType } from "./types";
import type {
  AssignmentInfo,
  OrgInfo,
  RepoInfo,
  CommitInfo,
  CompareCommitsInfo,
} from "@shared/githubInterfaces";

const baseUrl = import.meta.env.VITE_API_BASE_URL;

export const GitHubProvider = ({ children }: { children: React.ReactNode }) => {
  const getOrganizations = async (): Promise<OrgInfo[]> => {
    const res = await axios.get(`${baseUrl}/api/github/orgs`, {
      withCredentials: true,
    });
    return res.data;
  };

  const getAssignments = async (orgName: string): Promise<AssignmentInfo[]> => {
    const res = await axios.get(
      `${baseUrl}/api/github/orgs/${orgName}/assignments`,
      {
        withCredentials: true,
      }
    );
    return res.data;
  };

  const getRepos = async (
    orgName: string,
    assignmentName = ""
  ): Promise<RepoInfo[]> => {
    const res = await axios.get(
      `${baseUrl}/api/github/orgs/${orgName}/assignments/${assignmentName}/repos`,
      { withCredentials: true }
    );
    return res.data;
  };

  const getAllOrganizationData = async (org: string) => {
    const res = await axios.get(`${baseUrl}/api/github/org-report`, {
      withCredentials: true,
      params: { org },
    });
    return res.data;
  };

  const getCommits = async (
    orgName: string,
    repoName: string
  ): Promise<CommitInfo[]> => {
    const res = await axios.get(
      `${baseUrl}/api/github/repos/${orgName}/${repoName}/commits`,
      { withCredentials: true }
    );
    return res.data;
  };

  const getRepoTree = async (
    orgName: string,
    repoName: string
  ): Promise<string[]> => {
    const res = await axios.get(
      `${baseUrl}/api/github/repos/${orgName}/${repoName}/tree`,
      { withCredentials: true }
    );
    return res.data;
  };

  const getFileContents = async (
    orgName: string,
    repoName: string,
    path: string
  ): Promise<string | null> => {
    const res = await axios.get(
      `${baseUrl}/api/github/repos/${orgName}/${repoName}/contents`,
      {
        withCredentials: true,
        params: { path },
      }
    );
    return res.data;
  };

  const compareCommits = async (
    orgName: string,
    repoName: string,
    base: string,
    head: string
  ): Promise<CompareCommitsInfo> => {
    const res = await axios.get(
      `${baseUrl}/api/github/repos/${orgName}/${repoName}/compare/${base}/${head}`,
      { withCredentials: true }
    );
    return res.data;
  };

  const contextValue: GitHubContextType = useMemo(
    () => ({
      getOrganizations,
      getRepos,
      getAllOrganizationData,
      getAssignments,
      getCommits,
      getRepoTree,
      getFileContents,
      compareCommits,
    }),
    []
  );

  return (
    <GitHubContext.Provider value={contextValue}>
      {children}
    </GitHubContext.Provider>
  );
};
</file>

<file path="client/src/context/types.ts">
import type {
  OrgInfo,
  AssignmentInfo,
  RepoInfo,
  User,
  CommitInfo,
  CompareCommitsInfo,
} from "@shared/githubInterfaces";

export interface GitHubContextType {
  getOrganizations: () => Promise<OrgInfo[]>;
  getAssignments: (orgLogin: string) => Promise<AssignmentInfo[]>;
  getRepos: (org: string, assignmentPrefix?: string) => Promise<RepoInfo[]>;
  getAllOrganizationData: (org: string) => Promise<any>;
  getCommits: (orgName: string, repoName: string) => Promise<CommitInfo[]>;
  getRepoTree: (orgName: string, repoName: string) => Promise<string[]>;
  getFileContents: (
    orgName: string,
    repoName: string,
    path: string
  ) => Promise<string | null>;
  compareCommits: (
    orgName: string,
    repoName: string,
    base: string,
    head: string
  ) => Promise<CompareCommitsInfo>;
}

export interface UserContextType {
  user: User | null;
  isLogin: boolean;
  refreshUser: () => Promise<void>;
  logout: () => Promise<void>;
  login: () => string;
}
</file>

<file path="client/src/context/useGitHub.ts">
import { useContext } from "react";
import GitHubContext from "./GitHubContext";
import type { GitHubContextType } from "./types";

export const useGitHub = (): GitHubContextType => {
  const context = useContext(GitHubContext);

  if (!context) {
    throw new Error("useGitHub must be used within a GitHubProvider");
  }
  return context;
};
</file>

<file path="client/src/context/UserContext.ts">
// Declares the context object only
import { createContext } from "react";
import type { UserContextType } from "../types/UserInfo";

const UserContext = createContext<UserContextType | undefined>(undefined);
export default UserContext;
</file>

<file path="client/src/context/UserProvider.tsx">
// Provides state and logic (data + functions)
import { useEffect, useState, useMemo } from "react";
import axios from "axios";
import UserContext from "./UserContext";
import type { UserContextType } from "./types";
import type { User } from "@shared/githubInterfaces";

const baseUrl = import.meta.env.VITE_API_BASE_URL;

export const UserProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);

  const refreshUser = async () => {
    try {
      const res = await axios.get(`${baseUrl}/api/auth/getCurrentUser`, {
        withCredentials: true,
      });
      setUser(res.data.user || null);
    } catch {
      setUser(null);
    }
  };

  const login = () => {
    return `${baseUrl}/api/auth/login`;
  };

  const logout = async () => {
    await axios.get(`${baseUrl}/api/auth/logout`, { withCredentials: true });
    setUser(null);
  };

  useEffect(() => {
    refreshUser();
  }, []);

  const contextValue: UserContextType = useMemo(
    () => ({
      user,
      isLogin: !!user,
      refreshUser,
      logout,
      login,
    }),
    [user]
  );

  return (
    <UserContext.Provider value={contextValue}>{children}</UserContext.Provider>
  );
};
</file>

<file path="client/src/context/useUser.ts">
// Exports the custom hook for using the context
import { useContext } from "react";
import UserContext from "./UserContext";
import type { UserContextType } from "../types/UserInfo";

export const useUser = (): UserContextType => {
  const context = useContext(UserContext);

  if (!context) {
    throw new Error("useUser must be used within a UserProvider");
  }
  return context;
};
</file>

<file path="client/src/hooks/useFilteredList.ts">
import { useMemo } from "react";

export function useFilteredList<T>(
  list: T[] = [],
  searchTerm: string,
  predicate: (item: T, searchTerm: string) => boolean
): T[] {
  return useMemo(() => {
    return list.filter((item) => predicate(item, searchTerm));
  }, [list, searchTerm, predicate]);
}
</file>

<file path="client/src/index.css">
@import "tailwindcss";
</file>

<file path="client/src/layouts/MainLayout.tsx">
import { Outlet, useNavigate, useLocation } from "react-router-dom";
import { useEffect } from "react";
import Header from "../components/Header";
import Footer from "../components/Footer";
import { useUser } from "../context/useUser";

export default function MainLayout() {
  const { user, isLogin, refreshUser, logout, login } = useUser();

  const navigate = useNavigate();
  const location = useLocation();

  useEffect(() => {
    const checkAndRedirect = async () => {
      await refreshUser?.();
      if (user && location.pathname === "/") {
        navigate("/orgs");
      }
    };
    checkAndRedirect();
  }, [refreshUser, navigate, user, location.pathname]);

  const handleHeaderButtonClick = async () => {
    if (isLogin) {
      await logout?.();
      navigate("/");
    } else {
      const loginUrl = login?.();
      if (loginUrl) {
        window.location.href = loginUrl;
      }
    }
  };

  return (
    <div className="flex flex-col min-h-screen">
      <Header loggedIn={!!isLogin} onClick={handleHeaderButtonClick} />
      <main className="flex-1 flex justify-center items-start">
          <div className="w-full max-w-screen-xl">
            <Outlet />
          </div>
      </main>
      <Footer />
    </div>
  );
}
</file>

<file path="client/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="client/src/pages/analyticsPage/AnalyticsPage.tsx">
import { useParams, useSearchParams } from "react-router-dom";
import { useEffect, useState, useMemo } from "react";
import { useGitHub } from "../../context/useGitHub";
import type { OrgReport } from "src/types/OrgReport";
import BackButton from "../../components/BackButton";
import BasicHeading from "../../components/BasicHeading";
import AveragePointsChart from "./averageAssignmentPointsTab/AveragePointsChart";
import MissingSubmissionsList from "./missingSubmissionsTab/MissingSubmissionsTab";
import Spinner from "../../components/Spinner";
import CommonIssuesTab from "./commonIssuesTab/CommonIssuesTab";
import Tabs from "../../components/Tabs";

// delete this later
const mockOrgData = {
  org: "Mock University",
  assignments: ["intro-to-data", "java-assignment", "css-intro-assignment"],
  submissions: [
    {
      student: "astronautie",
      grades: {
        "intro-to-data": 20,
        "java-assignment": 10,
        "css-intro-assignment": null,
      },
    },
    {
      student: "FuzzyKala",
      grades: {
        "intro-to-data": 18,
        "java-assignment": null, 
        "css-intro-assignment": null,
      },
    },
    {
      student: "vima20",
      grades: {
        "intro-to-data": 20,
        "java-assignment": 10,
        "css-intro-assignment": 30,
      },
    },
    {
      student: "nonRoster",
      grades: {
        "intro-to-data": null,
        "java-assignment": 15,
        "css-intro-assignment": 25,
      },
    },
  ],
};

// TODO: get this from github with real values (preferably with the OrgData and not separately)
const maxPointsPerAssignment = {
  "intro-to-data": 20,
  "java-assignment": 15,
  "css-intro-assignment": 30,
}

// TODO: get the real issues from the database(?)
const mockAssignmentData = [
  {
    assignmentName: "Assignment 1",
    issues: ["Repeating code", "Another issue", "Another issue", "Poor Naming", "Poor Naming", "Poor Naming", "Poor Naming"],
  },
  {
    assignmentName: "Assignment 2",
    issues: ["Bad logic", "Poor Naming", "Poor Naming", "Poor Naming", "Repeating Code", "No imports", "No imports"],
  },
  {
    assignmentName: "Assignment 3",
    issues: ["Bad logic", "Poor naming", "Bad logic", "Poor naming", "Poor naming", "Repeating code"],
  },
  {
    assignmentName: "Assignment 4",
    issues: ["Bad logic", "Poor naming", "Poor naming"],
  },
];

export default function AnalyticsPage() {
  const { orgName } = useParams<{ orgName: string }>();
  const github = useGitHub();
  const [orgData, setOrgData] = useState<OrgReport | null>(null);
  const [loading, setLoading] = useState(true);
  const [searchParams, setSearchParams] = useSearchParams();

  const activeTab = searchParams.get("tab") || "average-points";

  useEffect(() => {
    const fetchOrgData = async () => {
      if (!orgName) return;
      try {
        const data = await github.getAllOrganizationData(orgName);
        setOrgData(data);
      } catch (error) {
        console.error("Failed to fetch org data:", error);
      } finally {
        setLoading(false);
      }
    };
    fetchOrgData();
  }, [orgName, github]);

  function onTabChange(tabId: string) {
    const assignment = searchParams.get("assignment");
    const params = new URLSearchParams();
    params.set("tab", tabId);
    if (tabId === "missing-submissions" && assignment) {
      params.set("assignment", assignment);
    }
    setSearchParams(params);
  }

  const tabs = useMemo(
    () => [
      {
        id: "average-points",
        label: "Average Assignment Points",
        content: (
          <AveragePointsChart
            orgData={mockOrgData}
            maxPointsPerAssignment={maxPointsPerAssignment}
          />
        ),
      },
      {
        id: "common-issues",
        label: "Common Issues",
        content: (
          <CommonIssuesTab assignmentFeedbacks={mockAssignmentData} />
        ),
      },
      {
        id: "missing-submissions",
        label: "Missing Submissions",
        content: <MissingSubmissionsList orgData={mockOrgData} />,
      },
    ],[]
  );

  return (
    <div className="flex flex-col space-y-10 p-4 md:p-12"> 
      <div className="flex flex-col space-y-6">
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4"> 
          <div className="flex space-x-4">
            <BackButton to={`/orgs/${orgName}/assignments`}/>
            <BasicHeading heading={`Analytics for ${orgName}`} /> 
          </div>
        </div>
        <div>
          {loading ? (
            <Spinner />
          ) : !orgData ? (
            <div className="p-4">No organization data found.</div>
          ) : (
            <Tabs tabs={tabs} activeTab={activeTab} onTabChange={onTabChange} />
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/analyticsPage/averageAssignmentPointsTab/AveragePointsChart.tsx">
import { Bar } from 'react-chartjs-2';
import type { OrgReport } from 'src/types/OrgReport';
import { Chart as ChartJS, CategoryScale, LinearScale, BarElement, Tooltip, Title, Legend } from 'chart.js';

ChartJS.register(CategoryScale, LinearScale, BarElement, Tooltip, Title, Legend);

type AverageGradeChartProps = {
  orgData: OrgReport;
  maxPointsPerAssignment: { [assignmentName: string]: number };
};

export default function AveragePointsChart({ orgData, maxPointsPerAssignment }: AverageGradeChartProps) {
  const labels = orgData.assignments;

  const averages = orgData.assignments.map((assignment) => {
    const maxPoints = maxPointsPerAssignment[assignment];
    if (!maxPoints || maxPoints === 0) return 0;
    const percentages = orgData.submissions.map((s) => {
      const grade = s.grades[assignment];
      return typeof grade === 'number' ? (grade / maxPoints) * 100 : null;
    }).filter((g): g is number => g !== null);

    const average = percentages.length
      ? percentages.reduce((a, b) => a + b, 0) / percentages.length
      : 0;

    return average.toFixed(2);
  });

  const data = {
    labels,
    datasets: [
      {
        label: 'Average % of Points',
        data: averages,
        backgroundColor: 'rgba(75, 192, 192, 0.6)',
        borderRadius: 4,
      },
    ],
  };

  const options = {
    responsive: true,
    plugins: {
      legend: {
        display: false,
      },
      title: {
        display: true,
        text: 'Average Percentage of Points per Assignment',
      },
    },
    scales: {
      y: {
        beginAtZero: true,
        max: 100, 
        ticks: {
          callback: (value: number | string ) => `${value}%`,
        },
      },
    },
  };

  return (<Bar data={data} options={options} />)
}
</file>

<file path="client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesCard.tsx">
import type { SingleAssignmentFeedback } from "src/types/AssignmentFeedback";

type CommonIssuesCardProps = {
  assignment: SingleAssignmentFeedback;
};

export default function CommonIssuesCard({ assignment } : CommonIssuesCardProps) {
  return (
    <div className="pl-3 pb-3">
      <h2 className=" text-gray-700 mb-2">Common issues in {assignment.assignmentName}</h2>
      <ul className="list-disc list-inside text-gray-700">
        {[...new Set(assignment.issues)].map((issue, index) => (
          <li key={index}>{issue}</li>
        ))}
      </ul>
    </div>
  );
}
</file>

<file path="client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesChart.tsx">
import type { SingleAssignmentFeedback } from 'src/types/AssignmentFeedback';
import { Bar } from 'react-chartjs-2';

type CommonIssuesChartProps = {
  assignment: SingleAssignmentFeedback;
};

export default function CommonIssuesChart({ assignment }: CommonIssuesChartProps) {
  const allIssues: string[] = assignment.issues;

  const issueCounts = allIssues.reduce<Record<string, number>>((acc, issue) => {
    acc[issue] = (acc[issue] || 0) + 1;
    return acc;
  }, {});

  const labels = Object.keys(issueCounts);
  const dataValues = Object.values(issueCounts);

  const data = {
    labels,
    datasets: [
      {
        label: 'Number of Students',
        data: dataValues,
        backgroundColor: 'rgba(255, 99, 132, 0.6)',
        borderRadius: 4,
      },
    ],
  };

  const options = {
    responsive: true,
    plugins: {
      legend: { display: false },
      title: { display: true, text: 'Common Issues Across Submissions' },
    },
    scales: {
      y: {
        beginAtZero: true,
        title: {
          display: true,
          text: 'Number of Occurences',
        },
        ticks: {
          stepSize: 1,
        },
      },
    },
  };

  return (
    <div className="p-3">
      <Bar data={data} options={options}/> 
    </div>
  );
}
</file>

<file path="client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesCollapsible.tsx">
import { useState } from "react";
import { FaChevronDown, FaChevronUp } from "react-icons/fa";
import CommonIssuesCard from "./CommonIssuesCard";
import type { SingleAssignmentFeedback } from "src/types/AssignmentFeedback";
import CommonIssuesChart from "./CommonIssuesChart";

type CommonIssuesCollapsibleProps = {
  assignment: SingleAssignmentFeedback;
};

export default function CommonIssuesCollapsible({ assignment }: CommonIssuesCollapsibleProps) {
  const [isOpen, setIsOpen] = useState(false);

  return (
     <div className="border-b border-[#D9D9D9]">
      <button
        onClick={() => setIsOpen((prev) => !prev)}
        className="w-full flex justify-between items-center text-left font-semibold text-gray-700 p-3 text-lg"
      >
        <span>{assignment.assignmentName}</span>
        {isOpen ? <FaChevronUp size={15} /> : <FaChevronDown size={15} />}
      </button>

      {isOpen && (
        <div>
            <CommonIssuesCard assignment={assignment} />
            <CommonIssuesChart assignment={assignment}/>
        </div>
      )}
    </div>
  )
}
</file>

<file path="client/src/pages/analyticsPage/commonIssuesTab/CommonIssuesTab.tsx">
import type { AssignmentFeedbacks } from "src/types/AssignmentFeedback";
import CommonIssuesCollapsible from "./CommonIssuesCollapsible";

type CommonIssuesTabProps = {
  assignmentFeedbacks: AssignmentFeedbacks;
};

export default function CommonIssuesTab({ assignmentFeedbacks }: CommonIssuesTabProps) {
  return (
    <div>
      {assignmentFeedbacks.map((assignment, index) => (
        <CommonIssuesCollapsible key={index} assignment={assignment} />
      ))}
    </div>
  );
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/MissingSubmissionsTab.tsx">
import { useEffect, useState } from "react";
import UploadStudentRosterCSVButton from "./UploadStudentRosterCSVButton";
import Subtext from "./Subtext";
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";
import type { OrgReport } from "src/types/OrgReport";
import { useParams, useSearchParams } from "react-router-dom";
import StudentTableWithTabs from "./studentTable/StudentTableWithTabs";

type MissingSubmissionsTabProps = {
  orgData: OrgReport;
};

export default function MissingSubmissionsTab({ orgData }: MissingSubmissionsTabProps) {
  const [roster, setRoster] = useState<StudentInStudentRoster[]>([]);
  const { orgName } = useParams<{ orgName: string }>();
  const [searchParams] = useSearchParams();
  const selectedAssignment = searchParams.get("assignment") || "all";
  
  useEffect(() => {
    const fetchRoster = async () => {
      if (!orgName) return;
      try {
        // TODO: get the roster from the database
        const fetchedRoster = "" // await db.getStudentRoster(orgName); 
        setRoster(fetchedRoster || []);
      } catch (error) {
        console.error("Failed to fetch student roster:", error);
      }
    };

    fetchRoster();
  }, [orgName]); 

  return (
    <div>
      {roster.length === 0 ? (
        <div className="flex flex-col gap-y-6 items-center">
            <Subtext text={`Note: GitHubâ€™s API does not currently support fetching student rosters. To view missing submissions, please upload a roster manually. You can download your class roster from GitHub Classroom under the "Students" section.`} />
            <UploadStudentRosterCSVButton text="Upload Student Roster CSV" onUpload={setRoster}/>
        </div>
      ) : (
        <div className="flex flex-col gap-y-2">
          <div className="flex justify-between items-center">
            <Subtext text="Note: Student names and GitHub usernames are only visible once at least one assignment has been accepted."/>
            <UploadStudentRosterCSVButton text="Update Student Roster CSV" onUpload={setRoster}/>
          </div>
          {roster.length > 0 && (
            <StudentTableWithTabs roster={roster} orgData={orgData} selectedTab={selectedAssignment} orgName={orgName}/>
          )}
        </div>
      )}
    </div>
  )
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTable.tsx">
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";
import type { OrgReport } from "src/types/OrgReport";
import GetCSVFileButton from "../../../../components/GetCSVFileButton";
import StudentTableHeader from "./StudentTableHeader";
import StudentTableRow from "./StudentTableRow";

type StudentTableProps = {
  roster: StudentInStudentRoster[]; 
  orgData: OrgReport;
  assignmentFilter?: string[];
  orgName?: string;
};

export default function StudentTable({ roster, orgData, assignmentFilter, orgName }: StudentTableProps) {
  const submissions = orgData.submissions; 
  const submissionMap = new Map(submissions.map(s => [s.student, s]));
  const assignmentNames = assignmentFilter ?? orgData.assignments;

  const studentsInRoster = roster.map((student) => {
    const submission = submissionMap.get(student.github_username);
    const grades = assignmentNames.map((assignment) => {
      const value = submission?.grades?.[assignment];
      if (value === null || value === undefined) return "N/A";
      if (typeof value === "number") return value;
      return "Error";
    });

    const numericGrades = grades.filter(g => typeof g === "number") as number[];
    const totalPoints = numericGrades.length > 0 ? numericGrades.reduce((a, b) => a + b, 0) : "â€”";
    const submissionCount = numericGrades.length;

    return {
      ...student,
      grades,
      totalPoints,
      submissionCount,
    };
  });

  const sortedStudents = [...studentsInRoster].sort(
   (a, b) => a.submissionCount - b.submissionCount
  );

  return (
    <div>
      <div className="p-2 flex justify-end">
        <GetCSVFileButton 
          text={`Export ${assignmentFilter && assignmentFilter.length === 1 ? assignmentFilter[0] : "All Assignments"} CSV`}
          orgName={orgName}
          roster={roster}
          assignmentFilter={assignmentFilter}
        />
      </div>
    <table className="table-auto border rounded-lg border-gray-300 bg-white w-full text-sm text-left">
      <StudentTableHeader assignmentNames={assignmentNames}/>
      <tbody>
        {sortedStudents.map((student) => (
          <StudentTableRow studentInfo={student} assignmentNames={assignmentNames} />
        ))}
    </tbody>
   </table>
   </div>
  );
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTableHeader.tsx">
type StudentTableHeaderProps = {
  assignmentNames: string[];
};

export default function StudentTableHeader({ assignmentNames }: StudentTableHeaderProps) {
  return (
    <thead>
      <tr>
        <th className="border border-gray-700 px-4 py-2 font-medium">Name</th>
        <th className="border border-gray-700 px-4 py-2 font-medium">GitHub Username</th>
        <th className="border border-gray-700 px-4 py-2 font-medium">Roster Identifier</th>
        {assignmentNames.map((assignment) => (
          <th key={assignment} className="border border-gray-700 px-4 py-2 font-medium">
            {assignment}
          </th>
        ))}
        <th className="border border-gray-700 px-4 py-2 font-medium">Total Points</th>
      </tr>
    </thead>
  );
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTableRow.tsx">
import type { StudentInfo } from "src/types/StudentInfo";

type StudentTableRowProps = {
  studentInfo: StudentInfo;
  assignmentNames: string[]
};

export default function StudentTableRow({ studentInfo, assignmentNames }: StudentTableRowProps) {
  const { name, github_username, identifier, grades, totalPoints, submissionCount } = studentInfo;

  const rowClass =
    submissionCount === 0 ? "bg-red-100" :
    submissionCount < assignmentNames.length ? "bg-yellow-100" :
    "bg-green-100";

  return (
    <tr key={identifier} className={rowClass}>
      <td className="border border-gray-700 px-4 py-2">{name?.trim() || "N/A"}</td>
      <td className="border border-gray-700 px-4 py-2">{github_username?.trim() || "N/A"}</td>
      <td className="border border-gray-700 px-4 py-2">{identifier}</td>
      {grades.map((grade, idx) => (
        <td key={idx} className="border border-gray-700 px-4 py-2 text-center">{grade}</td>
      ))}
      <td className="border border-gray-700 px-4 py-2 text-center">{totalPoints}</td>
    </tr>
  );
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/studentTable/StudentTableWithTabs.tsx">
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";
import { useSearchParams } from "react-router-dom";
import type { OrgReport } from "src/types/OrgReport";
import StudentTable from "./StudentTable";
import Tabs from "../../../../components/Tabs";

type StudentTableWithTabsProps = {
  roster: StudentInStudentRoster[];
  orgData: OrgReport;
  selectedTab: string;
  orgName?: string;
};

export default function StudentTableWithTabs({ roster, orgData, selectedTab, orgName }: StudentTableWithTabsProps) {
  const [searchParams, setSearchParams] = useSearchParams();

  const handleTabChange = (tabId: string) => {
    const params = new URLSearchParams(searchParams);
    params.set("assignment", tabId); 
    console.log(orgName + " " + orgData)
    setSearchParams(params);
  };

  const allAssignments = orgData.assignments;

  const tabs = [
    {
      id: "all",
      label: "All Submissions",
      content: <StudentTable roster={roster} orgData={orgData} orgName={orgName}/>
    },
    ...allAssignments.map((assignmentName) => ({
      id: assignmentName,
      label: assignmentName,
      content: (
        <StudentTable
          roster={roster}
          orgData={orgData}
          assignmentFilter={[assignmentName]}
          orgName={orgName}
        />
      )
    }))
  ];

  return (
    <div className="mt-4">
        <Tabs tabs={tabs} activeTab={selectedTab} onTabChange={handleTabChange}/>
    </div>
  );
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/Subtext.tsx">
interface SubtextProps {
  text: string;
}

export default function Subtext({ text }: SubtextProps) {
  return (
    <div>
        <p className="text-[16px]">{text}</p>
    </div>
  )
}
</file>

<file path="client/src/pages/analyticsPage/missingSubmissionsTab/UploadStudentRosterCSVButton.tsx">
import { useRef } from "react";
import Papa from "papaparse";
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";
import { useParams } from "react-router-dom";

type UploadStudentRosterCSVButtonProps = {
  text: string,
  onUpload: (students: StudentInStudentRoster[]) => void;
};

// TODO: once we have access to database, save (or update if a new roster is provided) uploaded roster for specific organization there
export default function UploadStudentRosterCSVButton({ text, onUpload }: UploadStudentRosterCSVButtonProps) {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { orgName } = useParams<{ orgName: string }>();

  const handleClick = () => {
    fileInputRef.current?.click();
  };

  const saveRosterToDB = async (roster: StudentInStudentRoster[]) => {
    if (!orgName) return;
    try {
      const response = await fetch(`/api/orgs/${orgName}/roster`, {
        method: "POST", // in backend if a roster already exists for the specific org, update it instead of posting it (use same backend function for both though)
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ roster }),
      });

      if (!response.ok) {
        throw new Error(`Failed to save roster: ${response.statusText}`);
      }
    } catch (error) {
      console.error("Error saving roster to DB:", error);
    }
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    Papa.parse<StudentInStudentRoster>(file, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => {
        const expectedHeaders = ["identifier", "github_username", "github_id", "name"];
        const actualHeaders = results.meta.fields;
        const headersValid = actualHeaders && expectedHeaders.length === actualHeaders.length && expectedHeaders.every((h, i) => h === actualHeaders[i]);
        if (!headersValid) {
          console.error("Invalid CSV format. Expected headers:", expectedHeaders, "but got:", actualHeaders);
          alert("Invalid CSV format. Header row must exactly match: identifier,github_username,github_id,name");
          return;
        }
        const validStudents = results.data.filter((s) => s.identifier);
        onUpload(validStudents);
        (async () => {await saveRosterToDB(validStudents);})();
      },
      error: (err) => {
        console.error("CSV parsing error:", err);
      },
    });
    event.target.value = "";
  };

  return (
    <div>
      <button onClick={handleClick} className="flex items-center justify-between border border-[#D9D9D9] px-6 py-3 h-[40px] rounded-full w-fit min-w-[95px] gap-2 bg-[#1D1B20] hover:opacity-90 text-white">
        {text}
      </button>
      <input
        ref={fileInputRef}
        type="file"
        accept=".csv"
        onChange={handleFileChange}
        className="hidden"
      />
    </div>
  )
}
</file>

<file path="client/src/pages/assignmentPage/AssignmentsPage.tsx">
import BasicHeading from "../../components/BasicHeading";
import BasicList from "../../components/basicList/BasicList";
import BasicSearchBar from "../../components/BasicSearchBar";
import { useEffect, useState } from "react";
import { useGitHub } from "../../context/useGitHub";
import { useParams, useNavigate } from "react-router-dom";
import type { AssignmentInfo } from "@shared/githubInterfaces";
import { useFilteredList } from "../../hooks/useFilteredList";
import BackButton from "../../components/BackButton";
import BasicButton from "../../components/BasicButton";
import { sortData } from "../../utils/sortingUtils";
import type { SortOption } from "../../utils/sortingUtils";
import Sidebar from "./sidebar/Sidebar";
import Spinner from "../../components/Spinner";
import GetCSVFileButton from "../../components/GetCSVFileButton";

const allAssignments = [
  {
    name: "Assignment 1",
    submitted: 5,
    accepted: 5,
    total: 10,
    deadline: new Date('2025-04-01T23:59:59Z'),
  },
  {
    name: "Assignment 2",
    submitted: 10,
    accepted: 10,
    total: 10,
    deadline: new Date('2025-05-01T23:59:59Z'),
  },
  {
    name: "Assignment 3",
    submitted: 7,
    accepted: 8,
    total: 10,
    deadline: new Date('2025-06-01T23:59:59Z'),
  },
  {
    name: "Assignment 4",
    submitted: 3,
    accepted: 4,
    total: 10,
    deadline: new Date('2025-04-01T23:59:59Z'),
  },
  {
    name: "Assignment 5",
    submitted: 10,
    accepted: 10,
    total: 10,
    deadline: new Date('2025-04-10T23:59:59Z'),
  },
  {
    name: "Assignment 6",
    submitted: 6,
    accepted: 8,
    total: 10,
    deadline: new Date('2025-06-10T23:59:59Z'),
  },
];

export default function AssignmentsPage() {
  const { orgName } = useParams<{ orgName: string }>();
  const [assignments, setAssignments] = useState<AssignmentInfo[]>([]);
  const github = useGitHub();
  const navigate = useNavigate();
  const [searchTerm, setSearchTerm] = useState("");
  const [loading, setLoading] = useState(true);
  const [sortOrder, setSortOrder] = useState<SortOption>("Newest");

  const filteredAssignments = useFilteredList(
    assignments,
    searchTerm,
    (a, term) => a.name.toLowerCase().includes(term.toLowerCase())
  );

  const handleAnalyticsClick = () => {
    if (orgName) {
      navigate(`/orgs/${orgName}/analytics`);
    }
  };

  const sortedAssignments = sortData(filteredAssignments, sortOrder);

  useEffect(() => {
    if (orgName) {
      github
        .getAssignments(orgName)
        .then(setAssignments)
        .catch(console.error)
        .finally(() => setLoading(false));
    }
  }, [orgName, github]);

  return (
    <div className="flex flex-row min-h-screen">
      <Sidebar assignments={allAssignments}/>
      <div className="flex-1 flex justify-center"> 
      <div className="flex flex-col space-y-10 pr-4 pt-4 md:pr-12 md:pt-12 pl-0">
        <div className="flex flex-col space-y-6">
          <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
            <div className="flex space-x-4">
              <BackButton to="/orgs" />
              <BasicHeading heading={`Assignments in ${orgName}`} />
            </div>
            <div className="flex space-x-4">
              <BasicSearchBar value={searchTerm} onChange={setSearchTerm} />
            </div>
          </div>
          <div className="flex flex-col md:flex-row md:items-center md:justify-end gap-4">
            <BasicButton text="Go To Analytics Page" onClick={handleAnalyticsClick}/>
            <GetCSVFileButton text={"Export CSV Report"} orgName={orgName}/>
          </div>
        </div>
        {loading ? (
          <Spinner />
        ) : (
          <BasicList
            type="assignment"
            items={sortedAssignments}
            orgName={orgName!}
            isLoading={loading}
            sortOrder={sortOrder}
            onSortChange={setSortOrder}
          />
        )}
      </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/assignmentPage/sidebar/ProgressBar.tsx">
interface ProgressBarProps {
  progress: number; // 0 to 100
}

export default function ProgressBar({ progress }: ProgressBarProps) {

  // commonted out for now, would normally give more colours
  /*let bgColor = "bg-red-500";
  if (progress >= 70) {
    bgColor = "bg-green-500";
  } else if (progress >= 40) {
    bgColor = "bg-yellow-400";
  }*/

  let bgColor = "bg-black"

  return (
     <div className="w-full bg-gray-200 rounded-full h-4 overflow-hidden">
      <div
        className={`${bgColor} h-full transition-all duration-300`}
        style={{ width: `${progress}%` }}
      />
    </div>
  )
}
</file>

<file path="client/src/pages/assignmentPage/sidebar/Sidebar.tsx">
import { useState } from 'react';
import { useParams } from 'react-router-dom';
import SidebarButton from './SidebarButton';
import SidebarCard from './SidebarCard';
import SidebarPagination from './SidebarPagination';

type RosterAndOrgDataAssignmentInfo = {
  name: string;
  submitted: number;
  accepted: number;
  total: number;
  deadline: Date;
};

interface SidebarProps {
  assignments: RosterAndOrgDataAssignmentInfo[];
} 

export default function Sidebar({ assignments } : SidebarProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  const { orgName } = useParams<{ orgName: string }>();

  const sortedAssignments = [...assignments].sort((a, b) => {
    const now = new Date();
    const getRank = (assignment: RosterAndOrgDataAssignmentInfo) => {
      const isOverdue = assignment.deadline <= now;
      const isComplete = assignment.submitted >= assignment.total;
      if (isOverdue && !isComplete) return 0; // Highest priority 
      if (!isOverdue && !isComplete) return 1; // Second priority
      return 2; // Lowest priority (Completed)
    };
    const rankA = getRank(a);
    const rankB = getRank(b);
    if (rankA !== rankB) return rankA - rankB; 
    return a.deadline.getTime() - b.deadline.getTime();
  });

  const totalPages = Math.ceil(assignments.length / 3);
  const startIndex = (currentPage - 1) * 3;
  const currentAssignments = sortedAssignments.slice(startIndex, startIndex + 3);

  return (
    <>
      <SidebarButton isOpen={isOpen} toggle={() => setIsOpen(!isOpen)}/>
      <div 
        className={`fixed top-0 left-0 h-full w-64 bg-white p-4 md:pt-12 md:pl-12 transform transition-transform duration-300 z-40
        ${isOpen ? 'translate-x-0' : '-translate-x-full'} md:translate-x-0 md:static md:block`}
      >
        <h2 className="text-xl font-bold mb-4">Classroom Info</h2>
        {currentAssignments.map((assignment) => (
          <SidebarCard 
            key={assignment.name}
            name={assignment.name}
            acceptedAssignments={assignment.accepted}
            submittedAssignments={assignment.submitted}
            totalAssignments={assignment.total}
            assignmentDeadline={assignment.deadline}
            linkTo={`/orgs/${orgName}/analytics?tab=missing-submissions&assignment=${encodeURIComponent(assignment.name)}`}
          />
        ))}
        <SidebarPagination 
          totalPages={totalPages}
          currentPage={currentPage}
          onPageChange={setCurrentPage}
        />
      </div>

      {isOpen && (
        <div
          className="fixed inset-0 bg-black opacity-50 z-30 md:hidden"
          onClick={() => setIsOpen(false)}
        ></div>
      )}
    </>
  );
}
</file>

<file path="client/src/pages/assignmentPage/sidebar/SidebarButton.tsx">
import { BiMenu, BiX } from 'react-icons/bi';

interface SidebarButtonProps {
  isOpen: boolean; 
  toggle: () => void;
}

export default function SidebarButton({ isOpen, toggle }: SidebarButtonProps) {
  return (
    <button
        className="md:hidden p-4"
        onClick={toggle}
        aria-label="Toggle Sidebar"
        >
        {isOpen ? <BiX size={24} /> : <BiMenu size={24} />}
    </button>
  )
}
</file>

<file path="client/src/pages/assignmentPage/sidebar/SidebarCard.tsx">
import { useNavigate } from "react-router-dom";
import ProgressBar from './ProgressBar';

interface SidebarCardProps {
  name: string;
  acceptedAssignments: number
  submittedAssignments: number;
  totalAssignments: number;
  assignmentDeadline: Date;
  linkTo: string;
}

export default function SidebarCard({name, acceptedAssignments, submittedAssignments, totalAssignments, assignmentDeadline, linkTo }: SidebarCardProps) {
  const navigate = useNavigate();
  const now = new Date();
  const hasDeadlinePassed = assignmentDeadline.getTime() < now.getTime();

  const deadlineInfo = () => {
    const diff = assignmentDeadline.getTime() - now.getTime();
    if (diff > 0) {
      return `Deadline: ${assignmentDeadline.toLocaleDateString('en-GB', {day: '2-digit', month: '2-digit', year: 'numeric'})}`;
    } else {
      const msAgo = now.getTime() - assignmentDeadline.getTime();
      const daysAgo = Math.floor(msAgo / (1000 * 60 * 60 * 24));
      if (daysAgo < 1) {
        const hoursAgo = Math.floor(msAgo / (1000 * 60 * 60));
        if (hoursAgo < 1) {
          const minutesAgo = Math.floor(msAgo / (1000 * 60));
          return `Deadline passed ${minutesAgo} minute${minutesAgo !== 1 ? 's' : ''} ago`;
        }
        return `Deadline passed ${hoursAgo} hour${hoursAgo !== 1 ? 's' : ''} ago`;
      }
      return `Deadline passed ${daysAgo} day${daysAgo !== 1 ? 's' : ''} ago`;
    }
  };

  const progressOfAcceptedAssignments = totalAssignments > 0
    ? Math.round((acceptedAssignments / totalAssignments) * 100)
    : 0;
  
  const progressOfSubmittedAssignments = totalAssignments > 0
    ? Math.round((submittedAssignments / totalAssignments) * 100)
    : 0;

  return (
    <div onClick={() => navigate(linkTo)} className="border border-[#D9D9D9] rounded p-3 mb-2 space-y-2 cursor-pointer hover:bg-gray-100 active:bg-gray-200 transition-colors">
      <div>
        <h3 className="font-semibold text-gray-700">{name}</h3>
        <text className={`text-sm ${hasDeadlinePassed && progressOfSubmittedAssignments < 100? 'text-red-600 font-medium' : 'text-gray-600'}`}>{deadlineInfo()}</text>
      </div>           
      <div className="flex flex-col gap-1">
        <span className="text-sm">Assignments Accepted</span>
        <ProgressBar progress={progressOfAcceptedAssignments} />
      </div>
      <div className="flex flex-col gap-1">
        <span className="text-sm">Assignments Submitted</span>
        <ProgressBar progress={progressOfSubmittedAssignments} />
      </div>
    </div>
  )
}
</file>

<file path="client/src/pages/assignmentPage/sidebar/SidebarPagination.tsx">
interface SidebarPaginationProps {
  totalPages: number;
  currentPage: number;
  onPageChange: (page: number) => void;
}

export default function SidebarPagination({ totalPages, currentPage, onPageChange }: SidebarPaginationProps) {
  return (
    <div className="mt-4 flex justify-center gap-2">
      {Array.from({ length: totalPages }, (_, index) => (
        <button
          key={index}
          onClick={() => onPageChange(index + 1)}
          className={`px-3 py-1 rounded text-sm font-medium border ${
            currentPage === index + 1
              ? 'bg-black text-white'
              : 'bg-white text-black border-gray-300'
            }`}
            >
          {index + 1}
        </button>
      ))}
    </div>
  )
}
</file>

<file path="client/src/pages/loginPage/LoginButton.tsx">
import { FaGithub } from 'react-icons/fa';

interface LoginButtonProps {
  onClick: () => void;
}

export default function LoginButton({ onClick }: LoginButtonProps) {
  return (
    <button onClick={onClick} className="flex items-center bg-[#1D1B20] gap-3 px-16 py-5 hover:opacity-90 text-white text-lg rounded-full">
      <FaGithub className="w-6 h-6" />
      <span>Sign In With GitHub</span>
    </button> 
  )
}
</file>

<file path="client/src/pages/loginPage/LoginPage.tsx">
import BasicHeading from "../../components/BasicHeading";
import { useEffect } from "react";
import LoginButton from "./LoginButton";
import { useNavigate } from "react-router-dom";
import { useUser } from "../../context/useUser";

export default function LoginPage() {
  const { isLogin, login } = useUser();
  const navigate = useNavigate();

  useEffect(() => {
    if (isLogin) navigate("/orgs");
  }, [isLogin, navigate]);

  const handleLogin = () => {
    const loginUrl = login?.();
    if (loginUrl) {
      window.location.href = loginUrl;
    }
  };

  return (
    <div className="flex flex-col gap-20">
      <div className="flex flex-col items-center gap-2 px-4">
        <BasicHeading
          styling="text-center"
          heading="Login to GitHub Classroom Analyzer"
        />
        <p className="text-[20px] text-center">
          Sign in with GitHub to access your classroom repositories and analyze
          student submissions.
        </p>
      </div>
      <div className="flex flex-col items-center gap-10 px-4">
        <LoginButton onClick={handleLogin} />
        <p className="text-[16px] text-center">
          Only GitHub Classroom instructors can access this tool.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/orgPage/OrgsPage.tsx">
import { useEffect, useState } from "react";
import { useGitHub } from "../../context/useGitHub";
import type { OrgInfo } from "@shared/githubInterfaces";
import BasicHeading from "../../components/BasicHeading";
import BasicList from "../../components/basicList/BasicList";
import BasicSearchBar from "../../components/BasicSearchBar";
import { useFilteredList } from "../../hooks/useFilteredList";
import type { SortOption } from "../../utils/sortingUtils";
import { sortData } from "../../utils/sortingUtils";
import Spinner from "../../components/Spinner";

export default function OrgsPage() {
  const [orgs, setOrgs] = useState<OrgInfo[]>([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [loading, setLoading] = useState(true);
  const github = useGitHub();
  const [sortOrder, setSortOrder] = useState<SortOption>("Aâ€“Z");

  useEffect(() => {
    github
      .getOrganizations()
      .then(setOrgs)
      .catch(console.error)
      .finally(() => setLoading(false));
  }, [github]);

  const filteredOrgs = useFilteredList(orgs, searchTerm, (org, term) =>
    org.name.toLowerCase().includes(term.toLowerCase())
  );
  const sortedOrgs = sortData(filteredOrgs, sortOrder);
  console.log("orgs:", orgs);

  return (
    <div className="flex flex-col space-y-10 p-4 md:p-12">
      <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        <BasicHeading heading="Your Organizations" />
        <BasicSearchBar value={searchTerm} onChange={setSearchTerm} />
      </div>

      {loading ? (
        <Spinner />
      ) : (
        <BasicList
          type="org"
          items={sortedOrgs}
          isLoading={false}
          sortOrder={sortOrder}
          onSortChange={setSortOrder}
        />
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/CodeTab.tsx">
import Spinner from "../../components/Spinner";
import FileTree from "./FileTree";
import type { FileNode } from "./FileTree";
import { parseFileTree } from "../../utils/parseFileTree";

interface CodeTabProps {
  files: string[];
  selectedFile: string | null;
  content: string | null;
  loading?: boolean;
  onSelectFile: (file: string) => void;
}

export default function CodeTab({
  files,
  selectedFile,
  content,
  loading = false,
  onSelectFile,
}: CodeTabProps) {
  if (!files.length) return <Spinner />;
  const fileTree: FileNode[] = parseFileTree(files);

  return (
    <div className="flex">
      <div className="w-1/3 border-r p-4">
        <h3 className="font-semibold mb-2">Files</h3>
        <div className="bg-gray-100 rounded overflow-auto max-h-96">
          <FileTree
            nodes={fileTree}
            selectedPath={selectedFile}
            onSelect={onSelectFile}
          />
        </div>
      </div>
      <div className="w-2/3 p-4">
        <h3 className="font-semibold mb-2">Code</h3>
        {selectedFile ? (
          loading ? (
            <Spinner />
          ) : content ? (
            <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96">
              <code>{content}</code>
            </pre>
          ) : (
            <div className="text-red-500">Failed to load file content</div>
          )
        ) : (
          <div className="text-gray-500">Select a file to view</div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/CommitsTab.tsx">
import type { CommitInfo } from "@shared/githubInterfaces";
import Spinner from "../../components/Spinner";

interface CommitsTabProps {
  commits: CommitInfo[];
}

export default function CommitsTab({ commits }: CommitsTabProps) {
  if (!commits.length) return <Spinner />;

  return (
    <div className="space-y-2 overflow-auto max-h-96">
      {commits.map((commit) => (
        <div key={commit.sha} className="p-4 border rounded">
          <div className="flex items-center justify-between">
            <div className="w-11/12 font-medium">{commit.commit.message}</div>
            <div className="w-1/12 text-sm text-gray-500">
              {new Date(commit.commit.author.date).toLocaleString()}
            </div>
          </div>
          <div className="text-sm text-gray-600 pt-2">
            {commit.commit.author.name}
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/DiffTab.tsx">
import { useEffect, useState } from "react";
import { useGitHub } from "../../context/useGitHub";
import type {
  RepoInfo,
  CompareCommitsInfo,
  CommitInfo,
} from "@shared/githubInterfaces";
import Spinner from "../../components/Spinner";

interface DiffTabProps {
  repo: RepoInfo;
}

interface FileDiff {
  filename: string;
  status: string;
  patch?: string;
}

export default function DiffTab({ repo }: DiffTabProps) {
  const github = useGitHub();
  const [diff, setDiff] = useState<FileDiff[] | null>(null);

  useEffect(() => {
    if (repo) {
      // Compare last two commits
      github
        ?.getCommits(repo.owner, repo.name)
        .then((commits: CommitInfo[]) => {
          if (commits.length > 1) {
            return github?.compareCommits(
              repo.owner,
              repo.name,
              commits[1].sha,
              commits[0].sha
            );
          }
          return null;
        })
        .then((comparison: CompareCommitsInfo | null) => {
          setDiff(comparison?.files || null);
        });
    }
  }, [repo, github]);

  return (
    <div className="p-4">
      {diff ? (
        <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96">
          {diff.map((file: FileDiff) => (
            <div key={file.filename} className="mb-4">
              <div className="font-mono text-sm">
                {file.filename} ({file.status})
              </div>
              {file.patch && (
                <div className="bg-white p-2 rounded">
                  <code>{file.patch}</code>
                </div>
              )}
            </div>
          ))}
        </pre>
      ) : (
        <Spinner />
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FeedbackActions.tsx">
import BasicButton from "../../components/BasicButton";

interface Props {
  isEditing: boolean;
  onEditToggle: () => void;
  onDownload: () => void;
}

export default function FeedbackActions({
  isEditing,
  onEditToggle,
  onDownload,
}: Props) {
  return (
    <div className="flex justify-end space-x-2">
      <BasicButton onClick={onDownload} text="Download Feedback PDF" />
      <BasicButton
        onClick={onEditToggle}
        text={isEditing ? "Save Changes" : "Edit Feedback & Grade"}
      />
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FeedbackCard.tsx">
import { useState } from "react";
import type { AssignmentFeedback } from "@shared/aiInterfaces";
import FileFeedbackSection from "./FileFeedbackSection";
import { TbTriangleFilled } from "react-icons/tb";

interface FeedbackCardProps {
  isEditing: boolean;
  feedbackData: AssignmentFeedback;
  onFeedbackChange: (newText: string) => void;
  onGradeChange: (newGrade: string) => void;
}

export default function FeedbackCard({
  isEditing,
  feedbackData,
  onFeedbackChange,
  onGradeChange,
}: FeedbackCardProps) {
  const [expanded, setExpanded] = useState(true);
  const [fileExpanded, setFileExpanded] = useState<Record<string, boolean>>({});

  const toggleFile = (fileName: string) => {
    setFileExpanded((prev) => ({
      ...prev,
      [fileName]: !prev[fileName],
    }));
  };

  const totalIssues = feedbackData.feedbackByFile.reduce(
    (acc, file) => acc + file.issues.length,
    0
  );

  return (
    <div className="flex flex-col space-y-2 p-4 border rounded-md">
      <h2 className="text-lg font-semibold text-center">AI Feedback</h2>

      {/* Grade */}
      <div className="flex items-center space-x-4">
        <label className="font-semibold">Grade:</label>
        {isEditing ? (
          <select
            className="border rounded px-2 py-1"
            value={feedbackData.grade}
            onChange={(e) => onGradeChange(e.target.value)}
          >
            {["5", "4", "3", "2", "1"].map((val) => (
              <option key={val} value={val}>
                {val}
              </option>
            ))}
          </select>
        ) : (
          <span>{feedbackData.grade}</span>
        )}
      </div>

      {/* Overall Feedback */}
      <div>
        <label className="font-semibold">Overall Feedback:</label>
        {isEditing ? (
          <textarea
            className="w-full p-2 border rounded mt-1 resize-y min-h-[100px]"
            value={feedbackData.feedback}
            onChange={(e) => onFeedbackChange(e.target.value)}
          />
        ) : (
          <p className="text-sm whitespace-pre-wrap mt-1">
            {feedbackData.feedback}
          </p>
        )}
      </div>

      {/* Collapsible Issues Section */}
      <div className="mt-2 space-y-4">
        <button
          onClick={() => setExpanded((prev) => !prev)}
          className="flex items-center space-x-2 font-semibold focus:outline-none"
        >
          <span
            className={`transform transition-transform duration-200 ${
              expanded ? "rotate-180" : "rotate-90"
            }`}
          >
            <TbTriangleFilled />
          </span>
          <span>Issues ({totalIssues})</span>
        </button>

        {expanded && (
          <div className="max-h-[300px] overflow-y-auto space-y-2 pr-1">
            {feedbackData.feedbackByFile.map((file) => (
              <FileFeedbackSection
                key={file.fileName}
                fileName={file.fileName}
                issues={file.issues}
                expanded={!!fileExpanded[file.fileName]}
                onToggle={() => toggleFile(file.fileName)}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FeedbackTab.tsx">
import Spinner from "../../components/Spinner";
import FeedbackCard from "./FeedbackCard";
import FeedbackActions from "./FeedbackActions";
import type { AssignmentFeedback } from "@shared/aiInterfaces";

interface FeedbackTabProps {
  isEditing: boolean;
  feedbackData: AssignmentFeedback;
  onFeedbackChange: (newText: string) => void;
  onGradeChange: (newGrade: string) => void;
  onToggleEdit: () => void;
  onDownload: () => void;
}

export default function FeedbackTab({
  isEditing,
  feedbackData,
  onFeedbackChange,
  onGradeChange,
  onToggleEdit,
  onDownload,
}: FeedbackTabProps) {
  if (!feedbackData) return <Spinner />;

  return (
    <div className="flex flex-col space-y-6">
      <div className="flex-col space-y-4">
        <FeedbackActions
          isEditing={isEditing}
          onEditToggle={onToggleEdit}
          onDownload={onDownload}
        />
      </div>
      <FeedbackCard
        isEditing={isEditing}
        feedbackData={feedbackData}
        onFeedbackChange={onFeedbackChange}
        onGradeChange={onGradeChange}
      />
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FileFeedbackSection.tsx">
interface Props {
  fileName: string;
  issues: { id: number; line?: number; text: string }[];
  expanded: boolean;
  onToggle: () => void;
}

export default function FileFeedbackSection({
  fileName,
  issues,
  expanded,
  onToggle,
}: Props) {
  return (
    <div className="border p-2 rounded">
      <button
        onClick={onToggle}
        className="flex items-center space-x-2 font-medium w-full text-left"
      >
        <span
          className={`transform transition-transform ${
            expanded ? "rotate-90" : ""
          }`}
        >
          â–¶
        </span>
        <span>
          {fileName} ({issues.length} issues)
        </span>
      </button>
      {expanded && (
        <ul className="list-disc list-inside mt-2">
          {issues.map((issue) => (
            <li key={issue.id} className="text-sm">
              {issue.line ? `Line ${issue.line}: ` : ""}
              {issue.text}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/FileTree.tsx">
import { useState } from "react";
import { TbTriangleFilled } from "react-icons/tb";

export interface FileNode {
  name: string;
  path: string;
  isDirectory: boolean;
  children?: FileNode[];
}

interface FileTreeProps {
  nodes: FileNode[];
  selectedPath: string | null;
  onSelect: (path: string) => void;
}

export default function FileTree({
  nodes,
  selectedPath,
  onSelect,
}: FileTreeProps) {
  return (
    <div>
      {nodes.map((node) => (
        <TreeNode
          key={node.path}
          node={node}
          selectedPath={selectedPath}
          onSelect={onSelect}
        />
      ))}
    </div>
  );
}

function TreeNode({
  node,
  selectedPath,
  onSelect,
}: {
  node: FileNode;
  selectedPath: string | null;
  onSelect: (path: string) => void;
}) {
  const [open, setOpen] = useState(false);
  const isSelected = selectedPath === node.path;

  const handleClick = () => {
    if (node.isDirectory) setOpen((prev) => !prev);
    else onSelect(node.path);
  };

  return (
    <div className="ml-2">
      <div
        className={`flex items-center cursor-pointer p-1 rounded hover:bg-gray-100 ${
          isSelected ? "bg-blue-50" : ""
        }`}
        onClick={handleClick}
      >
        {node.isDirectory ? (
          <TbTriangleFilled
            size={16}
            className={`transform transition-transform duration-200 ${
              open ? "rotate-180" : "rotate-90"
            }`}
          />
        ) : (
          <span className="w-4" />
        )}
        <span className="ml-1">{node.name}</span>
      </div>
      {open && node.children && (
        <div className="ml-4">
          {node.children.map((child) => (
            <TreeNode
              key={child.path}
              node={child}
              selectedPath={selectedPath}
              onSelect={onSelect}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/MetadataTab.tsx">
import type { RepoInfo } from "@shared/githubInterfaces";
import Spinner from "../../components/Spinner";

interface MetadataTabProps {
  repo: RepoInfo;
}

export default function MetadataTab({ repo }: MetadataTabProps) {
  if (!repo) return <Spinner />;
  return (
    <div className="grid grid-cols-2 gap-4 p-4">
      <div className="bg-gray-100 rounded p-2">
        <h3 className="font-semibold mb-2">Repository Info</h3>
        <dl className="space-y-2">
          <div>
            <dt className="text-gray-600">Created</dt>
            <dd>{new Date(repo.createdAt).toLocaleString()}</dd>
          </div>
          <div>
            <dt className="text-gray-600">Last Updated</dt>
            <dd>{new Date(repo.updatedAt).toLocaleString()}</dd>
          </div>
        </dl>
      </div>
      <div className="bg-gray-100 rounded p-2">
        <h3 className="font-semibold mb-2">Collaborators</h3>
        <div className="space-y-2">
          {repo.collaborators.map((collaborator) => (
            <div key={collaborator.id} className="flex items-center space-x-2">
              <img
                src={collaborator.avatarUrl}
                className="w-6 h-6 rounded-full"
                alt={collaborator.name}
              />
              <span>{collaborator.name}</span>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/RepoDetailPage.tsx">
import { useParams, useLocation } from "react-router-dom";
import { useEffect, useState, useMemo } from "react";
import type { RepoInfo, CommitInfo } from "@shared/githubInterfaces";
import BackButton from "../../components/BackButton";
import BasicHeading from "../../components/BasicHeading";
import { useGitHub } from "../../context/useGitHub";
import Tabs from "../../components/Tabs";
import CodeTab from "./CodeTab";
import CommitsTab from "./CommitsTab";
import MetadataTab from "./MetadataTab";
import DiffTab from "./DiffTab";
import FeedbackTab from "./FeedbackTab";
import Spinner from "../../components/Spinner";

import { getInitialFeedback } from "../../utils/feedbackUtils";

import type { AssignmentFeedback } from "@shared/aiInterfaces";

export default function RepoDetailPage() {
  const location = useLocation();
  const repoFromState = location.state as RepoInfo | undefined;
  const { orgName, assignmentName, repoName } = useParams();
  const github = useGitHub();

  const [repo, setRepo] = useState<RepoInfo | null>(repoFromState ?? null);
  const [loading, setLoading] = useState(true);
  const [isEditing, setIsEditing] = useState(false);

  const [files, setFiles] = useState<string[]>([]);
  const [selectedFile, setSelectedFile] = useState<string | null>(null);
  const [fileContent, setFileContent] = useState<string | null>(null);
  const [fileLoading, setFileLoading] = useState(false);
  const [commits, setCommits] = useState<CommitInfo[]>([]);

  const [feedbackData, setFeedbackData] =
    useState<AssignmentFeedback>(getInitialFeedback);

  const handleClick = (action: string) => {
    if (action === "Edit Feedback") {
      setIsEditing((prev) => !prev);
    } else {
      console.log(`Clicked ${action}`);
    }
  };

  const handleFeedbackTextChange = (newText: string) => {
    setFeedbackData((prev) => ({ ...prev, feedback: newText }));
  };

  useEffect(() => {
    if (!repoFromState && github && orgName && assignmentName && repoName) {
      setLoading(true);
      github
        .getRepos(orgName, assignmentName)
        .then((repos) => {
          const found = repos.find((r) => r.name === repoName);
          setRepo(found || null);
        })
        .finally(() => setLoading(false));
    } else {
      setLoading(false);
    }
  }, [orgName, assignmentName, repoName, github, repoFromState]);

  // Fetch initial data
  useEffect(() => {
    if (repo) {
      // Load commits
      github?.getCommits(repo.owner, repo.name).then(setCommits);

      // Load file tree
      github?.getRepoTree(repo.owner, repo.name).then(setFiles);
    }
  }, [repo, github]);

  useEffect(() => {
    if (!selectedFile || !repo || !github) return;

    setFileLoading(true);
    setFileContent(null);

    github
      .getFileContents(repo.owner, repo.name, selectedFile)
      .then((content) => {
        setFileContent(content);
      })
      .catch((error) => {
        console.error("Error fetching file content:", error);
        setFileContent("Error loading file content");
      })
      .finally(() => {
        setFileLoading(false);
      });
  }, [selectedFile, repo, github]);

  useEffect(() => {
    console.log("repo:", repo);
  }, [repo]);

  const tabs = useMemo(
    () => [
      {
        id: "code",
        label: "Code",
        content: (
          <CodeTab
            files={files}
            selectedFile={selectedFile}
            content={fileContent}
            loading={fileLoading}
            onSelectFile={setSelectedFile}
          />
        ),
      },
      {
        id: "commits",
        label: "Commits",
        content: <CommitsTab commits={commits} />,
      },
      {
        id: "diff",
        label: "Diff",
        content: repo ? <DiffTab repo={repo} /> : <div>No repo found</div>,
      },
      {
        id: "metadata",
        label: "Metadata",
        content: repo ? <MetadataTab repo={repo} /> : <div>No repo found</div>,
      },
      {
        id: "feedback",
        label: "Feedback",
        content: (
          <FeedbackTab
            isEditing={isEditing}
            feedbackData={feedbackData}
            onFeedbackChange={handleFeedbackTextChange}
            onGradeChange={(newGrade) =>
              setFeedbackData((prev) => ({ ...prev, grade: newGrade }))
            }
            onToggleEdit={() => setIsEditing((prev) => !prev)}
            onDownload={() => handleClick("Download Feedback PDF")}
          />
        ),
      },
    ],
    [
      files,
      selectedFile,
      fileContent,
      fileLoading,
      commits,
      repo,
      isEditing,
      feedbackData,
    ]
  );

  if (loading) return <Spinner />;

  if (!repo)
    return <div className="p-4 text-red-600">Repository not found.</div>;

  return (
    <div className="flex flex-col space-y-10 p-4 md:p-12">
      <div className="flex flex-col space-y-6">
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          <div className="flex space-x-4">
            <BackButton
              to={`/orgs/${orgName}/assignments/${assignmentName}/repos`}
            />
            <BasicHeading heading={repo.name} />
          </div>
        </div>
        <Tabs tabs={tabs} />
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoDetailPage/RepoInfoCard.tsx">
import type { RepoInfo } from "@shared/githubInterfaces";

interface RepoInfoCardProps {
  title?: string;
  repo: RepoInfo;
}

export default function RepoInfoCard({ title, repo }: RepoInfoCardProps) {
  return (
    <div className={`rounded shadow p-4 bg-white border`}>
      {title && (
        <h2 className="text-lg font-semibold text-gray-800 mb-3">{title}</h2>
      )}
      <div className="text-gray-700 text-sm">
        <ul className="space-y-1 text-sm">
          <li>
            <div className="flex items-center space-x-3">
              <img
                src={repo.collaborators[0].avatarUrl}
                alt={repo.avatarUrl}
                className="w-6 h-6 rounded-full"
              />
              <strong>{repo.collaborators[0].name}</strong>
            </div>
          </li>
          <li>
            <strong>Created:</strong>{" "}
            {new Date(repo.createdAt).toLocaleString()}
          </li>
          <li>
            <strong>Updated:</strong>{" "}
            {new Date(repo.updatedAt).toLocaleString()}
          </li>
          <li>
            <strong>URL:</strong>{" "}
            <a
              href={repo.url}
              target="_blank"
              rel="noopener noreferrer"
              className="text-blue-600 underline"
            >
              {repo?.url}
            </a>
          </li>
        </ul>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/repoPage/ReposPage.tsx">
import BasicHeading from "../../components/BasicHeading";
import BasicList from "../../components/basicList/BasicList";
import BasicSearchBar from "../../components/BasicSearchBar";
import type { RepoInfo } from "@shared/githubInterfaces";
import { useEffect, useState } from "react";
import { useGitHub } from "../../context/useGitHub";
import { useParams } from "react-router-dom";
import { useFilteredList } from "../../hooks/useFilteredList";
import BackButton from "../../components/BackButton";
import BasicButton from "../../components/BasicButton";
import { sortData } from "../../utils/sortingUtils";
import type { SortOption } from "../../utils/sortingUtils";
import Spinner from "../../components/Spinner";

export default function ReposPage() {
  const { orgName } = useParams<{ orgName: string }>();
  const { assignmentName } = useParams<{ assignmentName: string }>();
  const github = useGitHub();
  const [repos, setRepos] = useState<RepoInfo[]>([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [loading, setLoading] = useState(true);
  const [sortOrder, setSortOrder] = useState<SortOption>("Newest");

  const filteredRepos = useFilteredList(repos ?? [], searchTerm, (repo, term) =>
    repo.name.toLowerCase().includes(term.toLowerCase())
  );

  const sortedRepos = sortData(filteredRepos, sortOrder);

  useEffect(() => {
    if (orgName) {
      github
        .getRepos(orgName, assignmentName)
        .then(setRepos)
        .catch(console.error)
        .finally(() => setLoading(false));
    }
  }, [orgName, assignmentName, github]);

  const handleClick = (action: string) => {
    console.log(`Clicked ${action}`);
  };

  console.log("repos", repos);
  return (
    <div className="flex flex-col space-y-10 p-4 md:p-12">
      <div className="flex flex-col space-y-6">
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
          <div className="flex space-x-4">
            <BackButton to={`/orgs/${orgName}/assignments`} />
            <BasicHeading heading={`Repositories in ${assignmentName}`} />
          </div>
          <div className="flex space-x-4">
            <BasicSearchBar value={searchTerm} onChange={setSearchTerm} />
          </div>
        </div>
        <div className="flex flex-col md:flex-row md:items-center md:justify-end gap-4">
          <BasicButton
            onClick={() => handleClick("Run Analysis")}
            text="Run Analysis"
          />
          <BasicButton
            onClick={() => handleClick("View Summary")}
            text="View Summary"
          />
        </div>
      </div>

      {loading ? (
        <Spinner />
      ) : (
        <BasicList
          type="repo"
          items={sortedRepos}
          orgName={orgName!}
          assignmentName={assignmentName!}
          isLoading={loading}
          sortOrder={sortOrder}
          onSortChange={setSortOrder}
        />
      )}
    </div>
  );
}
</file>

<file path="client/src/pages/SpecificUserSubmissionScreen.tsx">
import { useEffect, useState } from "react";
import { useParams, useNavigate } from "react-router-dom";

interface SubmissionData {
  name: string;
  feedback: string;
  date: string;
  fileName: string;
  grade: string;
}

export default function SpecificUserSubmissionScreen() {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const [data, setData] = useState<SubmissionData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Edit-tilat
  const [isEditing, setIsEditing] = useState(false);
  const [editedFeedback, setEditedFeedback] = useState("");

  useEffect(() => {
    setLoading(true);
    setError(null);
    setTimeout(() => {
      if (!id) {
        setError("ID puuttuu");
        setLoading(false);
        return;
      }
      setData({
        name: `Matti MeikÃ¤lÃ¤inen`,
        feedback: "",
        date:
          new Date().toLocaleDateString("fi-FI") +
          " " +
          new Date().toLocaleTimeString("fi-FI", {
            hour: "2-digit",
            minute: "2-digit",
          }),
        fileName: `tehtava${id}.zip`,
        grade: "3/5",
      });
      setLoading(false);
    }, 800);
  }, [id]);

  if (loading) {
    return <div className="text-center mt-10">Ladataan...</div>;
  }
  if (error) {
    return <div className="text-center mt-10 text-red-600">{error}</div>;
  }
  if (!data) {
    return null;
  }

  // Edit-painikkeen toiminta
  const handleEditClick = () => {
    setIsEditing(true);
    setEditedFeedback(data.feedback);
  };

  const handleSave = () => {
    setData({ ...data, feedback: editedFeedback });
    setIsEditing(false);
  };

  const handleCancel = () => {
    setIsEditing(false);
    setEditedFeedback("");
  };

  // Download-painikkeen toiminta (simuloitu PDF)
  const handleDownload = () => {
    const element = document.createElement("a");
    const file = new Blob([data.feedback], { type: "application/pdf" });
    element.href = URL.createObjectURL(file);
    element.download = data.fileName.replace(/\.zip$/, ".pdf");
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  };

  // Edit Grade -painikkeen toiminta
  const handleEditGrade = () => {
    const uusiArvosana = window.prompt(
      "SyÃ¶tÃ¤ uusi arvosana (esim. 4/5):",
      data.grade
    );
    if (uusiArvosana && uusiArvosana.trim() !== "") {
      setData({ ...data, grade: uusiArvosana });
    }
  };

  // Delete-painikkeen toiminta
  const handleDelete = () => {
    if (
      window.confirm(
        "Haluatko varmasti poistaa koko palautuksen? TÃ¤tÃ¤ toimintoa ei voi perua."
      )
    ) {
      navigate(-1);
    }
  };

  return (
    <div className="min-h-screen bg-[#F5F5F5] flex justify-center items-center">
      <div className="max-w-[820px] w-full bg-white rounded-[16px] shadow-lg p-0 sm:p-[60px] py-[48px] border border-[#E0E0E0]">
        <div className="relative w-full h-full flex flex-col items-start">
          <div
            className="w-full h-full bg-white rounded-none shadow-none px-0 py-0 relative border-none"
            style={{ boxShadow: "none" }}
          >
            {/* YlÃ¤rivi: tekstit vasemmalle, painikkeet oikealle */}
            <div className="flex flex-row justify-between items-start w-full gap-4 mt-2 mb-2">
              <div className="flex flex-row items-start gap-4">
                <button
                  onClick={() => navigate(-1)}
                  className="p-0 rounded-full text-[32px] font-extrabold text-[#1E1E1E] leading-none border-none bg-transparent hover:bg-gray-100 mt-1"
                  aria-label="Takaisin"
                  style={{ fontFamily: "inherit", border: "none" }}
                >
                  &#8592;
                </button>
                <div>
                  <h1
                    className="text-[20px] font-extrabold text-[#1E1E1E] mb-1"
                    style={{ fontFamily: "inherit" }}
                  >
                    Matti MeikÃ¤lÃ¤inen
                  </h1>
                  <div className="text-[#1E1E1E] text-[13px] flex flex-col gap-0.5">
                    <span>Submission time: {data.date}</span>
                    <span>Grade: {data.grade}</span>
                  </div>
                </div>
              </div>
              <div className="flex flex-col gap-4 items-end pr-8">
                <button
                  className="bg-[#1E1E1E] text-white px-6 py-1.5 rounded-full font-medium text-[13px] w-[180px] text-right"
                  style={{ boxShadow: "none", letterSpacing: 0 }}
                  onClick={handleDownload}
                >
                  Download Feedback PDF
                </button>
                <button
                  className="bg-[#1E1E1E] text-white px-6 py-1.5 rounded-full font-medium text-[13px] w-[180px] text-right"
                  style={{ boxShadow: "none", letterSpacing: 0 }}
                  onClick={handleEditGrade}
                >
                  Edit Grade
                </button>
                <button
                  className="bg-[#1E1E1E] text-white px-6 py-1.5 rounded-full font-medium text-[13px] w-[180px] text-right"
                  style={{ boxShadow: "none", letterSpacing: 0 }}
                  onClick={handleEditClick}
                  disabled={isEditing}
                >
                  Edit Feedback
                </button>
              </div>
            </div>
            {/* AI Feedback -laatikko */}
            <div className="pt-6 pb-4">
              <div className="text-[15px] font-semibold text-[#1E1E1E] mb-2">
                AI Feedback:
              </div>
              <div
                className="w-full bg-[#C7C7C7] rounded-[8px] min-h-[120px] flex items-center justify-center text-[#1E1E1E] text-[15px] p-6 border-none"
                style={{ height: 120 }}
              >
                {isEditing ? (
                  <div className="w-full">
                    <textarea
                      className="w-full border rounded p-4 min-h-[80px] bg-white text-[#1E1E1E] text-[15px]"
                      value={editedFeedback}
                      onChange={(e) => setEditedFeedback(e.target.value)}
                    />
                    <div className="mt-2 flex gap-2">
                      <button
                        className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 text-[13px]"
                        onClick={handleSave}
                      >
                        Tallenna
                      </button>
                      <button
                        className="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 text-[13px]"
                        onClick={handleCancel}
                      >
                        Peruuta
                      </button>
                    </div>
                  </div>
                ) : data.feedback ? (
                  data.feedback
                ) : (
                  <span className="text-[#757575]">
                    Highlighted issues, what went well etc etc
                  </span>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/services/feedbackService.ts">
import { supabase } from "../../../server/utils/supabase";

export async function saveFeedback(submissionId: string, aiComment: string, score: number) {
  const { data, error } = await supabase.from("feedback").insert([
    {
      submission_id: submissionId,
      ai_comment: aiComment,
      score,
    },
  ]);

  if (error) throw error;
  return data?.[0];
}
</file>

<file path="client/src/services/submissionService.ts">
import { supabase } from "../../../server/utils/supabase";

export async function saveSubmission(
  assignmentId: string,
  studentGithub: string,
  repoUrl: string
) {
  const { data, error } = await supabase.from("submissions").insert([
    {
      assignment_id: assignmentId,
      student_github: studentGithub,
      repo_url: repoUrl,
    },
  ]);

  if (error) throw error;
  return data?.[0];
}
</file>

<file path="client/src/types/AssignmentFeedback.ts">
export type SingleAssignmentFeedback = {
  assignmentName: string;
  issues: string[];
};

export type AssignmentFeedbacks = SingleAssignmentFeedback[];
</file>

<file path="client/src/types/OrgReport.ts">
// this is the output of the handleGetAllOrganizationData() call to the backend (using GutHub API)
export type OrgReport = {
  org: string;
  assignments: string[];
  submissions: {
    student: string; // student github username
    grades: Record<string, number | string | null>; 
  }[];
};
</file>

<file path="client/src/types/StudentInfo.ts">
import type { StudentInStudentRoster } from "./StudentInStudentRoster";

// a lenghtier version of the studentInStudentRoster
export type StudentInfo = StudentInStudentRoster & {
  grades: (number | string)[];
  totalPoints: number | string;
  submissionCount: number;
};
</file>

<file path="client/src/types/StudentInStudentRoster.ts">
// this is what we get from each student when a roster from GitHub classroom is created
export type StudentInStudentRoster = {
  identifier: string;
  github_username: string;
  github_id: string;
  name: string;
};
</file>

<file path="client/src/types/StudentSubmissionInfo.ts">
export interface StudentSubmissionInfo {
  id: string;
  studentProfilePicture: string;
  studentName: string;
  submissionStatus: string;
  currentGrade: string;
  submissionTime: string;
}
</file>

<file path="client/src/utils/feedbackUtils.ts">
import type { AssignmentFeedback } from "@shared/aiInterfaces";

function generateSummaryFeedback(
  feedbackByFile: AssignmentFeedback["feedbackByFile"]
): string {
  const summary =
    "Overall, good structure and code readability. Minor issues found.";
  const issues: string[] = [];

  let count = 1;
  for (const file of feedbackByFile) {
    for (const issue of file.issues) {
      issues.push(
        `Issue ${count}: ${issue.text}${
          issue.line ? ` (line ${issue.line}, in ${file.fileName})` : ""
        }`
      );
      count++;
    }
  }

  return [summary, ...issues].join("\n");
}

const feedbackByFile: AssignmentFeedback["feedbackByFile"] = [
  {
    fileName: "App.tsx",
    issues: [
      { id: 1, line: 5, text: "It would be better to use justify-end." },
      { id: 2, line: 34, text: "I couldn't find the import component." },
    ],
  },
  {
    fileName: "Home.tsx",
    issues: [
      {
        id: 1,
        line: 5,
        text: "I couldn't find any useContent component in the App.tsx - compulsory requirement.",
      },
    ],
  },
];

const defaultFeedback: AssignmentFeedback = {
  repoName: "week-2-assignment-tangerinekey380",
  assignmentTitle: "React Todo App",
  grade: "4",
  date: "2025-05-20T15:23:00Z",
  feedbackByFile,
  feedback: generateSummaryFeedback(feedbackByFile),
};

export function getInitialFeedback(): AssignmentFeedback {
  return defaultFeedback;
}
</file>

<file path="client/src/utils/generateCSVFromOrg.ts">
/* 
FORMAT OF CSV DOCUMENT:

Overview of Student Points and Submissions

Name            GitHub Username     Roster Identifier     Assignment 1      Assignment 2     Assignment 3     Total Points
Alice Park          alice                al3park              5                 N/A               2               7
Micheal Devon       michael               19029               4                 3                 5               12
Willie Wonka        willie                23234             Error               N/A               5               5

*/

import type { OrgReport } from "src/types/OrgReport";
import type { StudentInStudentRoster } from "src/types/StudentInStudentRoster";

function downloadCSV(csvContent: string, filename: string = "report.csv") {
  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.setAttribute("href", url);
  link.setAttribute("download", filename);
  link.style.visibility = "hidden";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

export function generateCSVFromOrg(orgData: OrgReport, roster: StudentInStudentRoster[]) {
  const assignmentNames = orgData.assignments;
  const headerRow = ["Name", "GitHub Username", "Roster Identifier", ...assignmentNames, "Total Points"]; 
  const submissionMap = new Map(
    orgData.submissions.map((s) => [s.student, s.grades])
  );
  const csvLines: string[][] = [
    ["Overview of Student Points and Submissions"], // title row
    headerRow, // header row
  ];
  for (const student of roster) {
    if (!student.identifier) continue;
    const scores = submissionMap.get(student.github_username) || {};
    const row: (string | number)[] = [
      student.name || "N/A",
      student.github_username || "N/A",
      student.identifier || "N/A",
    ];
    let total = 0;
    let count = 0;
    for (const assignment of assignmentNames) {
      const points = scores[assignment];
      if (typeof points === "number") {
        row.push(points);
        total += points;
        count++;
      } else if (points === "Error") {
        row.push("Error");
      } else {
        row.push("N/A");
      }
    }
    row.push(count > 0 ? total : "N/A");
    csvLines.push(row.map(String));
  }

  const csvContent = csvLines.map((row) => row.join(";")).join("\n");
  downloadCSV(csvContent, `${orgData.org}_assignments_overview.csv`);
}
</file>

<file path="client/src/utils/parseFileTree.ts">
import type { FileNode } from "../pages/repoDetailPage/FileTree";

// Internal type for building tree using object map
interface InternalNode extends Omit<FileNode, "children"> {
  children?: Record<string, InternalNode>;
}

export function parseFileTree(paths: string[]): FileNode[] {
  const root: Record<string, InternalNode> = {};

  paths.forEach((path) => {
    const parts = path.split("/");
    let current = root;
    let currentPath = "";

    parts.forEach((part, index) => {
      currentPath = currentPath ? `${currentPath}/${part}` : part;

      if (!current[part]) {
        current[part] = {
          name: part,
          path: currentPath,
          isDirectory: index < parts.length - 1,
          children: index < parts.length - 1 ? {} : undefined,
        };
      }

      if (index < parts.length - 1) {
        current = current[part].children!;
      }
    });
  });

  // Convert InternalNode -> FileNode (with children as array)
  const convert = (nodes: Record<string, InternalNode>): FileNode[] =>
    Object.values(nodes).map((node) => ({
      name: node.name,
      path: node.path,
      isDirectory: node.isDirectory,
      children: node.children ? convert(node.children) : undefined,
    }));

  return convert(root);
}
</file>

<file path="client/src/utils/sortingUtils.ts">
export type SortOption =
  | "Newest"
  | "Oldest"
  | "Aâ€“Z"
  | "Zâ€“A"
  | "Amount of Students"
  | "Amount of Students (desc)";

interface WithUpdatedAt {
  updatedAt: string;
}

interface WithAmountOfStudents {
  amountOfStudents: number;
}

function hasUpdatedAt(obj: unknown): obj is WithUpdatedAt {
  return typeof obj === "object" && obj !== null && "updatedAt" in obj;
}

function hasAmountOfStudents(obj: unknown): obj is WithAmountOfStudents {
  return typeof obj === "object" && obj !== null && "amountOfStudents" in obj;
}

export function sortData<T extends { name: string }>(
  data: T[],
  sortOrder: SortOption
): T[] {
  const sorted = [...data];

  switch (sortOrder) {
    case "Aâ€“Z":
      return sorted.sort((a, b) => a.name.localeCompare(b.name));

    case "Zâ€“A":
      return sorted.sort((a, b) => b.name.localeCompare(a.name));

    case "Newest":
      return sorted.sort((a, b) =>
        hasUpdatedAt(a) && hasUpdatedAt(b)
          ? new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
          : 0
      );

    case "Oldest":
      return sorted.sort((a, b) =>
        hasUpdatedAt(a) && hasUpdatedAt(b)
          ? new Date(a.updatedAt).getTime() - new Date(b.updatedAt).getTime()
          : 0
      );

    case "Amount of Students":
      return sorted.sort((a, b) =>
        hasAmountOfStudents(a) && hasAmountOfStudents(b)
          ? a.amountOfStudents - b.amountOfStudents
          : 0
      );

    case "Amount of Students (desc)":
      return sorted.sort((a, b) =>
        hasAmountOfStudents(a) && hasAmountOfStudents(b)
          ? b.amountOfStudents - a.amountOfStudents
          : 0
      );

    default:
      return sorted;
  }
}
</file>

<file path="client/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="client/tailwind.config.js">
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}", // adjust this if your files are in different folders
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
</file>

<file path="client/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@shared/*": ["../shared/*"]
    },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "types": ["react", "react-dom"],

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src", "../server/routes/testroutes.ts", "../server/AssignmentsService.ts", "../server/services/UserService.ts"]
}
</file>

<file path="client/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="client/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,
    "types": ["node"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="client/vite.config.ts">
import { defineConfig } from "vite";
import tailwindcss from "@tailwindcss/vite";
import react from "@vitejs/plugin-react";
import path from "path";

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      "@shared": path.resolve(__dirname, "../shared"),
    },
  },
  server: {
    proxy: {
      "/api": {
        target: "http://localhost:5000", // backend server
        changeOrigin: true,
        secure: false,
      },
    },
  },
});
</file>

<file path="docs/ARCHITECTURE.md">
# System Architecture

## Overview

This system is designed as a full-stack web application that automates feedback for programming assignments submitted via GitHub Classroom. It consists of three core layersâ€”Frontend, Backend, and External Integrationsâ€”each playing a distinct role in delivering real-time, AI-assisted insights to both students and teachers.

The Frontend, built with React, provides a user-friendly interface for authentication, repository selection, and feedback visualization. It communicates with the Backend via RESTful APIs.

The Backend, powered by Node.js and Express, handles user authentication through GitHub OAuth, fetches repository data via the GitHub API, and manages prompt generation and communication with AI services like OpenAI or DeepSeek. It also formats and returns feedback, summaries, and CSV exports to the frontend.

The system leverages external APIsâ€”GitHub API for accessing student submissions and AI APIs for analyzing code and generating feedbackâ€”without requiring a dedicated database for the MVP.

Components are containerized using Docker to ensure portability and consistent development environments.

## Components

- **Frontend (React):**
  Built with React and Vite, the frontend provides the user interface for teachers. It includes components for login, repository selection, feedback display, and summary reports. Styled with Tailwind CSS, it communicates with the backend via a structured API service layer using axios.

- **Backend (Node.js/Express):** Handles authentication, repository reading, AI communication.
  Acts as the main server layer. It handles GitHub OAuth authentication, fetches repositories, processes requests, and orchestrates interactions between GitHub and AI services. Follows a modular structure with routes, controllers, and services.

- **AI Integration (OpenAI):** Generates feedback from student code.
  Uses AI APIs to analyze student code, generate insightful feedback, and suggest improvements. Prompts are crafted dynamically based on submission context and user roles (teacher).

- **GitHub API:** Used to access student repositories and commit history.
  Integrates GitHub REST APIs to authenticate users, list repositories, and fetch student assignment code and metadata (e.g., commits, diffs). It serves as the bridge between GitHub Classroom and the feedback system.

<!-- - **(Optional) Database:** If used, describe its purpose. -->

## Data Flow

1. Teacher logs in via GitHub OAuth.
2. Repositories are listed via GitHub API.
3. Code is fetched and passed to the AI with a prompt.
4. AI response is returned and shown in UI.
5. Feedback summary and CSV report are generated.

## Architecture Diagram

[![System Architecture](https://mermaid.ink/img/pako:eNp1VE1vm0AQ_SurPeRSPgw2YHOoZGMntdRKkZ320NLDGsaAArtoWdo4lv97Z4FEwXI5oBnevLdvZoAzTUQKNKSmacY8EfxYZGHMCSnZSbQqJCnLJMS8g4-l-JvkTCrytMaapj1kktU5uZeCK-Dpr5i-hTH9rVX6a-kg8n1LIlHVggNXzRh2EX5kGTT2Ds-EK3SK6PJxS_Yg_xQJkK_sBHIo0Sd9MLJiyXPvY4hGSittY_NSS2gacuOklfYRoX8pyhLkFahtPBTqS3sgy1bl5BPZQS3wxtJ3O0PpTPcjsVlFHoCDZEpcVXi6py25B0gP6JRseFZwGNf42s3-B0HHQqr_taz9MuTKwXsXj4Qi3fZa4DzksSiBmOTmkiL3uuzWDCM9hrSrMhO9zgasU1WOvHVLI6ZJdpv9E9GrM83POP0eWjl96g6p26dTcoeD0zd_AGY94PVp1NOWg0rkjkSjaZdi0R1C_bOkLHCyKBzTXKm6CW0bjTdWVqi8PVjo3gZu48ugYjpieB8YdcnUUcjKEjVwVnQsrWJrDjVoJouUhkq2YNAKZMV0Ss9aL6YqhwqXGmKYMvmsKRfk1Iz_FKJ6o0nRZjkNj6xsMGvrlClYF_jZser9qcTJgoxEyxUNF50EDc_0hYZOEFj-wvGnwcRZOO5kMTfoiYb-xPLnwSxw557rLDDyLgZ97U6dWPPAMyikBb6W3_qvv_sJXP4Bq800Cg?type=png)](https://mermaid.live/edit#pako:eNp1VE1vm0AQ_SurPeRSPgw2YHOoZGMntdRKkZ320NLDGsaAArtoWdo4lv97Z4FEwXI5oBnevLdvZoAzTUQKNKSmacY8EfxYZGHMCSnZSbQqJCnLJMS8g4-l-JvkTCrytMaapj1kktU5uZeCK-Dpr5i-hTH9rVX6a-kg8n1LIlHVggNXzRh2EX5kGTT2Ds-EK3SK6PJxS_Yg_xQJkK_sBHIo0Sd9MLJiyXPvY4hGSittY_NSS2gacuOklfYRoX8pyhLkFahtPBTqS3sgy1bl5BPZQS3wxtJ3O0PpTPcjsVlFHoCDZEpcVXi6py25B0gP6JRseFZwGNf42s3-B0HHQqr_taz9MuTKwXsXj4Qi3fZa4DzksSiBmOTmkiL3uuzWDCM9hrSrMhO9zgasU1WOvHVLI6ZJdpv9E9GrM83POP0eWjl96g6p26dTcoeD0zd_AGY94PVp1NOWg0rkjkSjaZdi0R1C_bOkLHCyKBzTXKm6CW0bjTdWVqi8PVjo3gZu48ugYjpieB8YdcnUUcjKEjVwVnQsrWJrDjVoJouUhkq2YNAKZMV0Ss9aL6YqhwqXGmKYMvmsKRfk1Iz_FKJ6o0nRZjkNj6xsMGvrlClYF_jZser9qcTJgoxEyxUNF50EDc_0hYZOEFj-wvGnwcRZOO5kMTfoiYb-xPLnwSxw557rLDDyLgZ97U6dWPPAMyikBb6W3_qvv_sJXP4Bq800Cg)
</file>

<file path="docs/EPICS.md">
# Epic Stories

Organize your features and user stories into broader epics.

## Epics and Related Stories

### 1. GitHub Integration

#### Goal: Enable secure and seamless access to student repositories using GitHub's API.

##### User stories:

- As a teacher, I want to authenticate with GitHub using OAuth so I can securely access student repositories.
- As a teacher, I want to view a list of student repositories so I can select which ones to analyze.
- As a teacher, I want to fetch code and metadata (e.g., last commit, repo owner) for each repository.

##### Suggestions:

- Support GitHub Classroom filtering/tagging to improve repo discovery.
- Cache repository metadata to reduce API usage and improve performance.

### 2. AI Feedback Engine

#### Goal: Provide automated, context-aware feedback on student code using LLMs.

##### User stories:

- As a teacher, I want to automatically generate prompts from student code so I can get feedback from the AI without manual formatting.
- As a system, I need to send these prompts to an AI engine (OpenAI or DeepSeek) and receive relevant, structured feedback.
- As a user, I want error handling and retry mechanisms in case of AI API failures.

##### Suggestions:

- Store past AI responses temporarily (in memory or local cache) to reduce duplicate requests during session.
- Define prompt templates that adapt to different code types or assignment goals.
- Consider feedback format standardization (e.g., issue type, severity, suggestion) for easier UI rendering and reporting.

### 3. Feedback UI

#### Goal: Display AI feedback clearly and helpfully for each studentâ€™s submission.

##### User stories:

- As a teacher, I want to view AI-generated feedback per student with syntax-highlighted code.
- As a teacher, I want common issues or coding patterns visually highlighted.
- As a user, I want the ability to toggle views between individual feedback and group insights.

##### Suggestions:

- Add collapsible sections and tags (e.g., logic, naming, performance) for better navigation.
- Consider future read-only student access UI for feedback transparency and self-learning.

### 4. Reporting Tools

#### Goal: Aggregate and export meaningful summaries of student feedback and performance.

##### User stories:

- As a teacher, I want to generate group-level summaries to identify widespread challenges.
- As a teacher, I want to export all feedback and points as a CSV file for grading or archival purposes.
- As a teacher, I want to see submission trends over time to evaluate class progress.

##### Suggestions:

- Include analytics like â€œtop 5 common issuesâ€ or â€œaverage feedback scoreâ€ per assignment.
- Allow optional filters (by student, assignment, or issue type) when generating reports.

### 5. Project Infrastructure

#### Goal: Support scalable development and deployment through reliable tooling.

##### User stories:

- As a developer, I want Docker containers for both frontend and backend to ensure consistency across environments.
- As a team, I want a basic CI/CD pipeline to run tests and deploy the app automatically (optional in MVP).
- As a developer, I want a documented deployment plan (e.g., Vercel for frontend, Render/Fly.io/Heroku for backend, optional in MVP).

##### Suggestions:

- Add environment variable management and secrets handling early on (e.g., .env, GitHub secrets).
- Plan for rate limits and retries when integrating with GitHub or AI APIs.
</file>

<file path="docs/PROJECT_PLAN.md">
# Project Plan

## Team Members and Roles

- [Helmi Griffiths](https://github.com/HelmiGr) - Full Stack developer
- [Sam Chou](https://github.com/FuzzyKala) - Full Stack developer
- [Ville Matilainen](https://github.com/vima20) - Full Stack developer

## Working Methods

- Daily check-ins on working day[11 AM]
- GitHub [Project board](https://github.com/orgs/Summer-project-25-AI-Feedback-system/projects/1) to manage tasks
- Time tracking in [Time Sheet](https://unioulu-my.sharepoint.com/:x:/r/personal/t3chsa01_students_oamk_fi/_layouts/15/Doc.aspx?sourcedoc=%7B7D663633-A44C-426A-B63D-24642BF47BFC%7D&file=worked_hours.xlsx&action=default&mobileredirect=true)

## Sprint Goals

### Sprint 1 (Setup & Planning)

- Set up development environment
- Create architecture and wireframes
- Agree on tech stack and workflow

### Sprint 2 (GitHub API & Prompting)

- Implement OAuth login
- Read student repositories
- Design and test initial AI prompts

### Sprint 3 (AI Feedback & UI Integration)

- Send code to AI and receive response
- Display feedback in frontend
- Refine prompt structure

### Sprint 4 (Reporting & Finalization)

- Generate summary reports
- Implement CSV export
- Final documentation and testing

## Risks and Mitigation

- AI API cost â†’ Limit test requests
- Prompt quality â†’ Peer review
- Time management â†’ Weekly deadlines
</file>

<file path="docs/REQUIREMENTS.md">
# Functional Requirements

## User Roles

- **Teacher**: Authenticates via GitHub, views student submissions, reviews AI-generated feedback, generates summary reports, and exports data as CSV.
- **Student** (optional): May access personal feedback in future versions.

## MVP Requirements

- GitHub OAuth login for authentication
- List and fetch student repositories from GitHub Classroom
- Analyze code submissions using AI (OpenAI/DeepSeek)
- Display per-student feedback in the web UI
- Generate aggregated summary reports (e.g., most common issues, success rates)
- Export detailed feedback and grading data as a CSV file

## User Stories

- As a teacher, I want to authenticate via GitHub so I can access my studentsâ€™ repositories.
- As a teacher, I want to view AI-generated feedback for each student submission to save review time.
- As a teacher, I want to download a CSV file with feedback and points to simplify grading.
- As a teacher, I want to see common errors and patterns across submissions to guide class instruction.

## Non-Functional Requirements

- The system must work reliably on modern browsers (Chrome, Firefox, Edge).
- API keys and secrets must be securely stored on the server and never exposed to the frontend.
- The response time from the AI feedback engine should be under 5 seconds to ensure a smooth user experience.
- The system should be containerized (via Docker) to support easy deployment and consistent development environments.
</file>

<file path="server/.dockerignore">
# Ignore node_modules (since we install dependencies in Docker)
node_modules/

# Ignore logs and temp files
*.log
*.tmp
*.swp

# Ignore environment files (make sure not to include .env files in your image)
.env
.env.* 

# Ignore Git-related files and directories
.git/
.gitignore

# Ignore Docker files (you don't want to copy the Dockerfile itself)
Dockerfile
.dockerignore

# Ignore package manager logs (npm-debug.log, yarn-error.log)
npm-debug.log*
yarn-error.log*

# Ignore build and dist directories (as the image should be built within Docker)
dist/
build/

# Ignore any IDE specific files (like VS Code, JetBrains, etc.)
.vscode/
.idea/

# Ignore other temporary files
*.bak
*.orig

.env*
.flaskenv*
!.env.project
!.env.vault
</file>

<file path="server/Aievolution.ts">
import * as fs from "fs/promises";
import axios from "axios";
import * as dotenv from "dotenv";
import * as nodemailer from "nodemailer";
import path from "path";
import { simpleGit, SimpleGit } from "simple-git";
import { existsSync } from "fs";
import { resolve } from "path";

// Load environment variables from .env file
dotenv.config();

// OpenAI API response types
interface OpenAIResponse {
  choices: Array<{
    message: {
      content: string;
    };
  }>;
}

// Create email transporter
const createTransporter = () => {
  if (!process.env.GMAIL_USER || !process.env.GMAIL_APP_PASSWORD) {
    throw new Error("Gmail credentials missing from .env file");
  }

  return nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: process.env.GMAIL_USER,
      pass: process.env.GMAIL_APP_PASSWORD,
    },
  });
};

// Wait for specified time
const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

// Get all XML files from output directory
async function getXmlFiles(dir: string): Promise<string[]> {
  try {
    const files = await fs.readdir(dir);
    return files.filter((f) => f.endsWith(".xml")).map((f) => `${dir}/${f}`);
  } catch (error) {
    console.error("Error reading directory:", error);
    return [];
  }
}

// Split large XML file into smaller chunks
function splitXmlIntoChunks(
  xmlContent: string,
  maxChunkSize: number = 15000
): string[] {
  const chunks: string[] = [];
  let currentChunk = "";

  // Split XML line by line
  const lines = xmlContent.split("\n");

  for (const line of lines) {
    // If current chunk + new line is too large, save chunk and start new one
    if ((currentChunk + line).length > maxChunkSize) {
      if (currentChunk) {
        chunks.push(currentChunk);
        currentChunk = "";
      }
      // If single line is too long, split it into smaller parts
      if (line.length > maxChunkSize) {
        const subChunks =
          line.match(new RegExp(`.{1,${maxChunkSize}}`, "g")) || [];
        chunks.push(...subChunks);
      } else {
        currentChunk = line;
      }
    } else {
      currentChunk += (currentChunk ? "\n" : "") + line;
    }
  }

  if (currentChunk) {
    chunks.push(currentChunk);
  }

  return chunks;
}

// Get value from .env file
const DAILY_CALL_LIMIT = parseInt(process.env.DAILY_CALL_LIMIT || "10");
const WEEKLY_CALL_LIMIT = parseInt(process.env.WEEKLY_CALL_LIMIT || "50");

// Counters
let dailyCallCount = 0;
let weeklyCallCount = 0;
let lastDailyReset = new Date();
let lastWeeklyReset = new Date();

async function checkRateLimits(repoPath: string): Promise<boolean> {
  try {
    const git: SimpleGit = simpleGit(repoPath);

    // Get latest commit
    const lastCommit = await git.revparse(["HEAD"]);

    const dailyCommits = await git.log(['--since="24 hours ago"']);
    const weeklyCommits = await git.log(['--since="7 days ago"']);

    // Check daily limit
    if (dailyCommits.total >= DAILY_CALL_LIMIT) {
      console.log(`Daily AI call limit reached (${DAILY_CALL_LIMIT})`);
      return false;
    }

    if (weeklyCommits.total >= WEEKLY_CALL_LIMIT) {
      console.log(`Weekly AI call limit reached (${WEEKLY_CALL_LIMIT})`);
      return false;
    }

    return true;
  } catch (error) {
    console.error("Error checking rate limits:", error);
    return false;
  }
}

// Add these interfaces
interface TokenUsage {
  organizationId: string;
  tokens: number;
  timestamp: number;
}

interface RepoSize {
  organizationId: string;
  size: number;
  lastChecked: number;
}

// Add these variables
const tokenUsageMap = new Map<string, TokenUsage[]>();
const repoSizeMap = new Map<string, RepoSize>();
const MAX_TOKENS_PER_DAY = 1000000; // 1M tokens per day
const MAX_REPO_SIZE = 100000000; // 100MB

// Add this function for token usage tracking
async function trackTokenUsage(organizationId: string, tokens: number) {
  const now = Date.now();
  const dayAgo = now - 24 * 60 * 60 * 1000;

  // Get organization's token usage
  let usage = tokenUsageMap.get(organizationId) || [];

  // Remove old entries (older than 24h)
  usage = usage.filter((u) => u.timestamp > dayAgo);

  // Add new entry
  usage.push({
    organizationId,
    tokens,
    timestamp: now,
  });

  // Update usage
  tokenUsageMap.set(organizationId, usage);

  // Calculate total daily usage
  const dailyUsage = usage.reduce((sum, u) => sum + u.tokens, 0);

  // Check if limit is exceeded
  if (dailyUsage > MAX_TOKENS_PER_DAY) {
    throw new Error(
      `Organization ${organizationId} token usage limit exceeded. Used: ${dailyUsage}, Limit: ${MAX_TOKENS_PER_DAY}`
    );
  }
}

// Add this function to check repository size
async function checkRepoSize(organizationId: string, repoPath: string) {
  const now = Date.now();
  const lastChecked = repoSizeMap.get(organizationId)?.lastChecked || 0;

  // Check size only once per hour
  if (now - lastChecked < 60 * 60 * 1000) {
    return;
  }

  try {
    // Calculate repository size
    const size = await calculateRepoSize(repoPath);

    // Update size
    repoSizeMap.set(organizationId, {
      organizationId,
      size,
      lastChecked: now,
    });

    // Check if limit is exceeded
    if (size > MAX_REPO_SIZE) {
      console.warn(
        `Warning: Repository size exceeds recommended limit. Size: ${size}, Limit: ${MAX_REPO_SIZE}`
      );
      // Don't throw error, continue processing
      return;
    }
  } catch (error) {
    console.error("Error checking repo size:", error);
    // Don't throw error, continue processing
  }
}

// Add this function to calculate repository size
async function calculateRepoSize(repoPath: string): Promise<number> {
  let totalSize = 0;

  async function calculateDirSize(dir: string) {
    const files = await fs.readdir(dir);

    for (const file of files) {
      const filePath = path.join(dir, file);
      const stats = await fs.stat(filePath);

      if (stats.isDirectory()) {
        await calculateDirSize(filePath);
      } else {
        totalSize += stats.size;
      }
    }
  }

  await calculateDirSize(repoPath);
  return totalSize;
}

// Update interface for GitHub stats to match terminal output
interface GitHubStats {
  organizationId: string;
  repoPath: string;
  analysis: {
    timestamp: string;
    lastCommit: {
      hash: string;
      time: string;
    };
    repository: {
      totalCommits: number;
      sizeInMB: number;
      changes24h: number;
    };
    warnings: {
      highCommitCount: boolean;
      largeRepoSize: boolean;
    };
  };
}

// Update function to save GitHub stats to JSON
async function saveGitHubStats(stats: GitHubStats) {
  const outputDir = "output";
  const statsFile = path.join(outputDir, "github_stats.json");

  try {
    // Create output directory if it doesn't exist
    await fs.mkdir(outputDir, { recursive: true });

    // Read existing stats if file exists
    let allStats: GitHubStats[] = [];
    try {
      const existingData = await fs.readFile(statsFile, "utf-8");
      allStats = JSON.parse(existingData);
    } catch (error) {
      // File doesn't exist or is invalid, start with empty array
      allStats = [];
    }

    // Add new stats
    allStats.push(stats);

    // Save updated stats
    await fs.writeFile(statsFile, JSON.stringify(allStats, null, 2), "utf-8");
    console.log(`GitHub stats saved to ${statsFile}`);
  } catch (error) {
    console.error("Error saving GitHub stats:", error);
  }
}

// Add interface for Git info
interface GitInfo {
  organizationId: string;
  repoPath: string;
  lastCommit: string;
  lastCommitTime: number;
  lastChecked: number;
  size: number;
  commitCount: number;
}

// Add variable for storing Git info
const gitInfoMap = new Map<string, GitInfo>();

// Update checkGitRepo function
async function checkGitRepo(organizationId: string, repoPath: string) {
  const now = Date.now();
  const lastChecked = gitInfoMap.get(organizationId)?.lastChecked || 0;

  // Check only once per hour
  if (now - lastChecked < 60 * 60 * 1000) {
    console.log(`Git info was checked recently, using cached value`);
    return;
  }

  const absoluteRepoPath = resolve(repoPath); // âœ… Resolve to absolute path

  if (!existsSync(absoluteRepoPath)) {
    throw new Error(`Git repo path does not exist: ${absoluteRepoPath}`);
  }

  console.log(`[checkGitRepo] Using repoPath: ${absoluteRepoPath}`);

  try {
    console.log(`Analyzing Git repository for ${organizationId}...`);
    const git: SimpleGit = simpleGit(repoPath);

    // Get latest commit and its time
    const lastCommit = await git.revparse(["HEAD"]);
    const lastCommitInfo = await git.show(["--format=%at", "-s", lastCommit]);
    const lastCommitTime = parseInt(lastCommitInfo) * 1000; // Convert to milliseconds

    console.log(`Last commit: ${lastCommit}`);
    console.log(
      `Last commit time: ${new Date(lastCommitTime).toLocaleString()}`
    );

    // Get commit count
    const commitCount = (await git.log()).total;
    console.log(`Total commits: ${commitCount}`);

    // Get repository size
    const size = await calculateRepoSize(repoPath);
    const sizeInMB = size / (1024 * 1024);
    console.log(`Repository size: ${sizeInMB.toFixed(2)} MB`);

    // Get changes in last 24h
    const changes = await git.log(['--since="24 hours ago"']);
    console.log(`Changes in last 24h: ${changes.total} commits`);

    // Check for warnings
    const highCommitCount = changes.total > 50;
    const largeRepoSize = size > MAX_REPO_SIZE;

    if (highCommitCount) {
      console.warn(
        `Warning: High number of commits in last 24h (${changes.total})`
      );
    }

    if (largeRepoSize) {
      console.warn(`Warning: Repository size exceeds limit`);
    }

    // Create stats object matching terminal output
    const stats: GitHubStats = {
      organizationId,
      repoPath,
      analysis: {
        timestamp: new Date(now).toLocaleString(),
        lastCommit: {
          hash: lastCommit,
          time: new Date(lastCommitTime).toLocaleString(),
        },
        repository: {
          totalCommits: commitCount,
          sizeInMB: parseFloat(sizeInMB.toFixed(2)),
          changes24h: changes.total,
        },
        warnings: {
          highCommitCount,
          largeRepoSize,
        },
      },
    };

    // Save stats to JSON
    await saveGitHubStats(stats);

    // Update Git info map
    gitInfoMap.set(organizationId, {
      organizationId,
      repoPath,
      lastCommit,
      lastCommitTime,
      lastChecked: now,
      size,
      commitCount,
    });
  } catch (error) {
    console.error("Error checking Git repository:", error);
  }
}

// Add new interface for evaluation tracking
interface EvaluationRecord {
  submissionId: string;
  timestamp: number;
  evaluatedBy: "AI" | "TEACHER";
  teacherId?: string;
}

// Add new Map for evaluation tracking
const evaluationHistory = new Map<string, EvaluationRecord[]>();

// Modify hasBeenEvaluated function
async function hasBeenEvaluated(file: string): Promise<{
  evaluated: boolean;
  needsUpdate: boolean;
  lastEvaluation: EvaluationRecord | null;
}> {
  const submissionId = path.basename(file, ".xml");
  const markdownFile = path.join("output", "ASSIGNMENT_EVALUATION.md");

  try {
    const xmlLastModified = await getLastModifiedTime(file);
    const markdownLastModified = await getLastModifiedTime(markdownFile);

    const gitInfo = gitInfoMap.get("org123");
    const lastCommitTime = gitInfo?.lastCommitTime || 0;

    const needsUpdate =
      xmlLastModified > markdownLastModified ||
      lastCommitTime > markdownLastModified;

    const evaluations = evaluationHistory.get(submissionId) || [];
    const lastEvaluation = evaluations[evaluations.length - 1] || null;

    if (lastEvaluation?.evaluatedBy === "AI") {
      return {
        evaluated: true,
        needsUpdate: false,
        lastEvaluation,
      };
    }

    return {
      evaluated: true,
      needsUpdate: needsUpdate,
      lastEvaluation,
    };
  } catch {
    return {
      evaluated: false,
      needsUpdate: true,
      lastEvaluation: null,
    };
  }
}

// Add new function to record evaluations
async function recordEvaluation(
  submissionId: string,
  evaluatedBy: "AI" | "TEACHER",
  teacherId?: string
) {
  const evaluations = evaluationHistory.get(submissionId) || [];
  evaluations.push({
    submissionId,
    timestamp: Date.now(),
    evaluatedBy,
    teacherId,
  });
  evaluationHistory.set(submissionId, evaluations);
}

// Modify evaluateWithOpenAI function
export async function evaluateWithOpenAI(
  xmlContent: string,
  organizationId: string,
  repoPath: string
): Promise<string> {
  const submissionId = path.basename(repoPath, ".xml");

  // Check evaluation history
  const evaluations = evaluationHistory.get(submissionId) || [];
  const lastEvaluation = evaluations[evaluations.length - 1];

  if (lastEvaluation?.evaluatedBy === "AI") {
    throw new Error(
      "This submission has already been evaluated by AI. Please contact your teacher for re-evaluation."
    );
  }

  // Check Git repository
  await checkGitRepo(organizationId, repoPath);

  // Calculate token count
  const estimatedTokens = Math.ceil(xmlContent.length / 4);
  console.log(`Estimated token count: ${estimatedTokens}`);

  // Track token usage
  await trackTokenUsage(organizationId, estimatedTokens);

  // Check limits
  if (!(await checkRateLimits(repoPath))) {
    throw new Error("AI call limit reached. Try again later.");
  }

  // Increment counters
  dailyCallCount++;
  weeklyCallCount++;
  console.log(
    `Daily calls: ${dailyCallCount}, Weekly calls: ${weeklyCallCount}`
  );

  const apiKey = process.env.OPENAI_API_KEY?.trim();
  if (!apiKey) {
    throw new Error("OpenAI API key not found in .env file");
  }

  const endpoint = "https://api.openai.com/v1/chat/completions";

  // Leave room for prompt and response (about 1000 tokens)
  const maxContentTokens = 3000;

  // Truncate content if it's too long
  const truncatedContent =
    estimatedTokens > maxContentTokens
      ? xmlContent.substring(0, maxContentTokens * 4) +
        "\n... (content truncated)"
      : xmlContent;

  const prompt = `
You are a information technlogy teacher evaluating a student's project or code. Your goal is to provide constructive, concise, and actionable feedback that helps the student learn and improve. Analyze the following and rate it according to the following criteria:

1. Syntax and Validity (0-10): Is the code syntactically correct and does it run/compile without errors?

2. Structure and Organization (0-20): Is the code logically organized and are functions, classes, modules, and other language features used appropriately?

3. Clarity and Readability (0-20): Are the names of variables, functions, and classes descriptive? Is the code well-formed and easy to read?

4. Language-specific features (0-20): Does the code use features and best practices of the programming language in question (e.g., idiomatic constructs, error handling, etc.)?

5. Best practices (0-30): Does the code follow general and language-specific best practices (e.g., modularity, avoiding code duplication, proper error handling)?

Instructions:
- Analyze the code based on the criteria above.
- Provide a brief summary of the overall quality of the code, including strengths and areas for improvement.
- Give rates for each criteria and a total rating (0-5, where 0 is incomplete and 5 is excellent) based on the criteria.
- Keep the feedback clear, supportive, and instructive, student-friendly, and respectful.
- If the code seems unfinished or the context is unclear, note this and suggest possible improvements.
- If the code breaks in the middle of a function, note possible problems, but avoid speculative assumptions.

Student Code:
${truncatedContent}
`;

  let retries = 3;
  while (retries > 0) {
    try {
      console.log("Sending request to OpenAI API...");
      const response = await axios.post(
        endpoint,
        {
          model: "gpt-3.5-turbo",
          messages: [{ role: "user", content: prompt }],
          max_tokens: 1000,
          temperature: 0.3,
        },
        {
          headers: {
            Authorization: `Bearer ${apiKey}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (response.data?.choices?.[0]?.message?.content) {
        console.log("Response received from OpenAI API");
        // Record evaluation
        await recordEvaluation(submissionId, "AI");
        return response.data.choices[0].message.content;
      }
      throw new Error("Invalid response from OpenAI API");
    } catch (error: unknown) {
      if (error instanceof Error) {
        console.log(`Error calling OpenAI API: ${error.message}`);
      } else {
        console.log(`Unknown error calling OpenAI API: ${error}`);
      }
      if (axios.isAxiosError(error)) {
        if (error.response?.status === 401) {
          throw new Error("Invalid OpenAI API key. Check .env file.");
        }
        if (error.response?.status === 429) {
          console.log("Rate limit reached, waiting 20 seconds...");
          await sleep(20000);
          retries--;
          continue;
        }
      }
      if (retries === 1) throw error;
      retries--;
      await sleep(20000);
    }
  }

  throw new Error("Failed to get response from OpenAI API after all retries");
}

// Modify email sending function for Gmail
async function sendEmailFeedback(feedbackPath: string, studentEmail: string) {
  try {
    console.log("Attempting to send email...");

    if (!process.env.GMAIL_USER || !process.env.GMAIL_APP_PASSWORD) {
      throw new Error("Gmail credentials missing from .env file");
    }

    const transporter = nodemailer.createTransport({
      service: "gmail",
      auth: {
        user: process.env.GMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD,
      },
      tls: {
        rejectUnauthorized: false,
      },
    });

    // Check connection
    await transporter.verify();
    console.log("Email connection verified");

    const mailOptions = {
      from: process.env.GMAIL_USER,
      to: studentEmail,
      subject: "Assignment Evaluation",
      text: "Your assignment evaluation is attached to this email.",
      attachments: [
        {
          filename: "ASSIGNMENT_EVALUATION.md",
          path: feedbackPath,
        },
      ],
    };

    const info = await transporter.sendMail(mailOptions);
    console.log("Email sent successfully");
    return info;
  } catch (error: unknown) {
    if (error instanceof Error) {
      console.log(`Error sending email: ${error.message}`);
    } else {
      console.log("Unknown error sending email:", error);
    }
    throw error;
  }
}

interface EvaluationInfo {
  timestamp: number;
  lastModified: number;
}

async function getLastModifiedTime(file: string): Promise<number> {
  try {
    const stats = await fs.stat(file);
    return stats.mtime.getTime();
  } catch (error) {
    console.error(`Error getting file stats for ${file}:`, error);
    return 0;
  }
}

// Add this function to check token usage
async function getTokenUsage(organizationId: string): Promise<{
  dailyUsage: number;
  weeklyUsage: number;
  last24Hours: TokenUsage[];
}> {
  const now = Date.now();
  const dayAgo = now - 24 * 60 * 60 * 1000;
  const weekAgo = now - 7 * 24 * 60 * 60 * 1000;

  const usage = tokenUsageMap.get(organizationId) || [];

  return {
    dailyUsage: usage
      .filter((u) => u.timestamp > dayAgo)
      .reduce((sum, u) => sum + u.tokens, 0),
    weeklyUsage: usage
      .filter((u) => u.timestamp > weekAgo)
      .reduce((sum, u) => sum + u.tokens, 0),
    last24Hours: usage.filter((u) => u.timestamp > dayAgo),
  };
}

// Add function to get Git info
async function getGitInfo(
  organizationId: string
): Promise<GitInfo | undefined> {
  return gitInfoMap.get(organizationId);
}

// Fix error handling
async function handleError(error: unknown): Promise<never> {
  if (error instanceof Error) {
    console.log(`Error: ${error.message}`);
    throw error;
  }
  console.log("Unknown error occurred");
  throw new Error("Unknown error occurred");
}

// Modify main function
async function main() {
  try {
    // Check output directory
    await fs.access("output").catch(async () => {
      console.log("Creating output directory...");
      await fs.mkdir("output", { recursive: true });
    });

    const xmlFiles = await getXmlFiles("output");

    if (xmlFiles.length === 0) {
      console.log("No XML files found in output directory");
      return;
    }

    console.log(`Found ${xmlFiles.length} XML files to evaluate`);

    for (const file of xmlFiles) {
      try {
        // Check if file has been evaluated
        const evaluationStatus = await hasBeenEvaluated(file);

        if (evaluationStatus.evaluated && !evaluationStatus.needsUpdate) {
          console.log(
            `File ${file} has already been evaluated and is up to date. Skipping...`
          );
          continue;
        }

        if (evaluationStatus.evaluated && evaluationStatus.needsUpdate) {
          console.log(
            `File ${file} has been modified since last evaluation. Re-evaluating...`
          );
        }

        const xml = await fs.readFile(file, "utf-8");
        console.log(`Evaluating file ${file}...`);

        const feedback = await evaluateWithOpenAI(xml, "org123", path.dirname(file));

        // JÃ¤sennÃ¤ AI:n palaute
        const parsedFeedback = await parseAIFeedback(feedback);

        // Lasketaan kokonaisarvosana
        const overallRating = await calculateOverallRating(parsedFeedback.criteria);

        // Luo arviointitulokset
        const evaluationResult: EvaluationResult = {
          overallRating,
          criteria: parsedFeedback.criteria,
          summary: parsedFeedback.summary,
          metadata: {
            evaluationDate: new Date().toISOString(),
            submissionId: path.basename(file, ".xml"),
            repoName: path.basename(path.dirname(file)),
            assignmentName: "Assignment",
          },
        };

        // Tallenna markdown-tiedosto
        await saveEvaluationToMarkdown(evaluationResult, path.dirname(file));

        // LÃ¤hetÃ¤ sÃ¤hkÃ¶posti
        const studentEmail = "student@example.com";
        await sendEmailFeedback(
          path.join(path.dirname(file), "ASSIGNMENT_EVALUATION.md"),
          studentEmail
        );
        console.log(`Feedback sent via email to ${studentEmail}`);
      } catch (e: unknown) {
        if (e instanceof Error) {
          console.log(`Error evaluating file ${file}: ${e.message}`);
        } else {
          console.log("Unknown error evaluating file:", e);
        }
      }
    }
  } catch (error: unknown) {
    await handleError(error);
  }
}

// Kutsu main-funktiota
main().catch(console.error);

interface EvaluationCriteria {
  name: string;
  score: number;
  maxScore: number;
  comments: string[];
}

interface EvaluationResult {
  overallRating: number;
  criteria: EvaluationCriteria[];
  summary: string;
  metadata: {
    evaluationDate: string;
    submissionId: string;
    repoName: string;
    assignmentName: string;
  };
}

async function calculateOverallRating(
  criteria: EvaluationCriteria[]
): Promise<number> {
  const totalScore = criteria.reduce(
    (sum, criteria) => sum + criteria.score,
    0
  );
  const maxScore = criteria.reduce(
    (sum, criteria) => sum + criteria.maxScore,
    0
  );
  // Muunnetaan 100-pistejÃ¤rjestelmÃ¤stÃ¤ 5-pistejÃ¤rjestelmÃ¤Ã¤n
  return (totalScore / maxScore) * 5;
}

async function saveEvaluationToMarkdown(
  evaluationResult: EvaluationResult,
  repoPath: string
): Promise<void> {
  const evaluationPath = path.join("output", "ASSIGNMENT_EVALUATION.md");

  const evaluationDate = new Date(evaluationResult.metadata.evaluationDate);
  const formattedDate = evaluationDate.toLocaleDateString("fi-FI", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });

  // Lasketaan kokonaispisteet
  const totalScore = evaluationResult.criteria.reduce(
    (sum, criteria) => sum + criteria.score,
    0
  );
  const maxScore = evaluationResult.criteria.reduce(
    (sum, criteria) => sum + criteria.maxScore,
    0
  );
  const overallRating = (totalScore / maxScore) * 5;

  const markdownContent = `# Assignment Evaluation

## Summary

${evaluationResult.summary}

Total Score: ${overallRating.toFixed(1)}/5

## Metadata
- **Evaluation Date:** ${formattedDate}
- **Evaluation ID:** ${evaluationResult.metadata.submissionId}
- **Repository:** ${evaluationResult.metadata.repoName}
- **Assignment:** ${evaluationResult.metadata.assignmentName}
`;

  try {
    await fs.mkdir("output", { recursive: true });
    await fs.writeFile(evaluationPath, markdownContent, "utf-8");
    console.log(`Evaluation saved to ${evaluationPath}`);
  } catch (error) {
    console.error("Error saving evaluation to markdown:", error);
    throw error;
  }
}

interface ParsedFeedback {
  criteria: EvaluationCriteria[];
  summary: string;
}

async function parseAIFeedback(feedback: string): Promise<ParsedFeedback> {
  const criteria: EvaluationCriteria[] = [];

  // Syntax and Validity (0-10)
  const syntaxMatch = feedback.match(/Syntax and Validity\s*\((\d+)\/(\d+)\)/);
  if (syntaxMatch) {
    criteria.push({
      name: "Syntax and Validity",
      score: parseInt(syntaxMatch[1]),
      maxScore: parseInt(syntaxMatch[2]),
      comments: extractComments(feedback, "Syntax and Validity"),
    });
  }

  // Structure and Organization (0-20)
  const structureMatch = feedback.match(
    /Structure and Organization\s*\((\d+)\/(\d+)\)/
  );
  if (structureMatch) {
    criteria.push({
      name: "Structure and Organization",
      score: parseInt(structureMatch[1]),
      maxScore: parseInt(structureMatch[2]),
      comments: extractComments(feedback, "Structure and Organization"),
    });
  }

  // Clarity and Readability (0-20)
  const clarityMatch = feedback.match(
    /Clarity and Readability\s*\((\d+)\/(\d+)\)/
  );
  if (clarityMatch) {
    criteria.push({
      name: "Clarity and Readability",
      score: parseInt(clarityMatch[1]),
      maxScore: parseInt(clarityMatch[2]),
      comments: extractComments(feedback, "Clarity and Readability"),
    });
  }

  // Language-specific features (0-20)
  const languageMatch = feedback.match(
    /Language-specific features\s*\((\d+)\/(\d+)\)/
  );
  if (languageMatch) {
    criteria.push({
      name: "Language-specific Features",
      score: parseInt(languageMatch[1]),
      maxScore: parseInt(languageMatch[2]),
      comments: extractComments(feedback, "Language-specific features"),
    });
  }

  // Best practices (0-30)
  const practicesMatch = feedback.match(/Best practices\s*\((\d+)\/(\d+)\)/);
  if (practicesMatch) {
    criteria.push({
      name: "Best Practices",
      score: parseInt(practicesMatch[1]),
      maxScore: parseInt(practicesMatch[2]),
      comments: extractComments(feedback, "Best practices"),
    });
  }

  // Poistetaan kaikki Overall Rating -rivit yhteenvedosta
  const summary = feedback
    .replace(/Overall Rating: \d+\/5\n/g, "")
    .replace(/Overall Rating: \d+\/5/g, "")
    .trim();

  return {
    criteria,
    summary,
  };
}

function extractComments(feedback: string, criteriaName: string): string[] {
  const comments: string[] = [];
  const lines = feedback.split("\n");
  let isInCriteria = false;

  for (const line of lines) {
    if (line.includes(criteriaName)) {
      isInCriteria = true;
      continue;
    }
    if (isInCriteria && line.trim().startsWith("-")) {
      comments.push(line.trim().substring(1).trim());
    }
    if (isInCriteria && line.trim() === "") {
      isInCriteria = false;
    }
  }

  return comments;
}
</file>

<file path="server/AssignmentsService.ts">
import { supabase } from "./utils/supabase";

export async function saveAssignment(name: string, githubUrl: string) {
  const { data, error } = await supabase
    .from("assignments")
    .insert([{ name, github_url: githubUrl }]);

  if (error) {
    console.error("Supabase error:", error);
    throw error;
  }
}
</file>

<file path="server/controllers/aiController.ts">
import { Request, Response } from "express";
import { runRepomix, runAIEvolution } from "../services/ai/aiService";

export async function handleRunRepomix(
  req: Request,
  res: Response
): Promise<void> {
  const { repoUrl } = req.body;

  if (!repoUrl) {
    res.status(400).json({ error: "Missing repoUrl" });
    return;
  }

  try {
    const xmlOutput = await runRepomix(repoUrl);
    const encoded = Buffer.from(xmlOutput, "utf-8").toString("base64");
    res.json({ xml: encoded });
  } catch (error) {
    console.error("Repomix error:", error);
    res.status(500).json({ error: "Failed to run repomix" });
  }
}

export async function handleRunAIEvolution(
  req: Request,
  res: Response
): Promise<void> {
  const { xml: base64Xml, organizationId, repoPath } = req.body;

  console.log("[Controller] Submitting repoPath to AIEvolution:", repoPath);

  if (!base64Xml || !organizationId || !repoPath) {
    res.status(400).json({ error: "Missing xml, organizationId, or repoPath" });
    return;
  }

  try {
    const xml = Buffer.from(base64Xml, "base64").toString("utf-8");
    const feedback = await runAIEvolution(xml, organizationId, repoPath);
    res.json({ feedback });
  } catch (error) {
    console.error("AIEvolution error:", error);
    res.status(500).json({ error: "Failed to run AIEvolution" });
  }
}
</file>

<file path="server/controllers/authController.ts">
import { Request, Response } from "express";
import dotenv from "dotenv";
dotenv.config();

export const githubCallback = (req: Request, res: Response) => {
  // console.log("Authenticated user:", req.user);
  res.redirect(`${process.env.FRONTEND_ORIGIN}/orgs`);
};

export const getCurrentUser = (req: Request, res: Response) => {
  res.json({ user: req.user });
};

export const logout = (req: Request, res: Response) => {
  req.logout((err) => {
    if (err) {
      return res.status(500).json({ error: "Logout failed" });
    }
    req.session.destroy(() => {
      res.clearCookie("connect.sid");
      res.status(200).json({ message: "Logged out successfully" });
    });
  });
};
</file>

<file path="server/controllers/githubController.ts">
import { Request, Response } from "express";
import { extractAssignmentName } from "../utils/githubUtils";
import {
  getOrganizations,
  getAssignments,
  getStudentReposForAssignment,
  getCommits,
  getRepoTree,
  getFileContents,
  compareCommits,
} from "../services/github/githubService";

export async function handleGetOrganizations(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const orgs = await getOrganizations();
    res.json(orgs);
  } catch (error) {
    console.error("Failed to fetch organizations:", error);
    res.status(500).json({ error: "Failed to fetch organizations" });
  }
}

export async function handleGetAssignments(
  req: Request,
  res: Response
): Promise<void> {
  const orgName = req.params.orgName;

  if (!orgName) {
    res.status(400).json({ error: "Organization login not provided" });
    return;
  }

  try {
    const assignments = await getAssignments(orgName);
    res.json(assignments);
  } catch (error: any) {
    console.error("Failed to fetch assignments:", error);
    res.status(500).json({ error: "Failed to fetch assignments" });
  }
}

export async function handleGetStudentReposForAssignment(
  req: Request,
  res: Response
): Promise<void> {
  const orgName = req.params.orgName;
  const assignmentName = req.params.assignmentName;

  if (!orgName) {
    res.status(400).json({ error: "Missing organization or assignment name" });
    return;
  }

  try {
    const repos = await getStudentReposForAssignment(orgName, assignmentName);
    res.json(repos);
  } catch (error) {
    console.error("Failed to fetch student repos:", error);
    res.status(500).json({ error: "Failed to fetch student repos" });
  }
}

export async function handleGetCommits(
  req: Request,
  res: Response
): Promise<void> {
  const { orgName, repoName } = req.params;

  try {
    const commits = await getCommits(orgName, repoName);
    res.json(commits);
  } catch (error) {
    console.error("Failed to fetch commits:", error);
    res.status(500).json({ error: "Failed to fetch commits" });
  }
}

export async function handleGetRepoTree(
  req: Request,
  res: Response
): Promise<void> {
  const { orgName, repoName } = req.params;

  if (!orgName || !repoName) {
    res
      .status(400)
      .json({ error: "Organization and repository names are required" });
    return;
  }

  try {
    const tree = await getRepoTree(orgName as string, repoName as string);
    res.json(tree);
  } catch (error) {
    console.error("Failed to fetch repository tree:", error);
    res.status(500).json({ error: "Failed to fetch repository tree" });
  }
}

export async function handleGetFileContents(
  req: Request,
  res: Response
): Promise<void> {
  const { orgName, repoName } = req.params;
  const path = req.query.path as string;

  if (!orgName || !repoName || !path) {
    res.status(400).json({
      error: "Organization, repository and path are required",
    });
    return;
  }

  try {
    const contents = await getFileContents(orgName, repoName, path);
    if (contents === null) {
      res.status(404).json({ error: "File not found" });
      return;
    }
    res.json(contents);
  } catch (error) {
    console.error("Failed to fetch file contents:", error);
    res.status(500).json({ error: "Failed to fetch file contents" });
  }
}

export async function handleCompareCommits(
  req: Request,
  res: Response
): Promise<void> {
  const orgName = req.params.orgName;
  const repoName = req.params.repoName;
  const base = req.params.base;
  const head = req.params.head;

  if (!orgName || !repoName || !base || !head) {
    res.status(400).json({
      error: "Organization, repository, base and head commits are required",
    });
    return;
  }

  try {
    const comparison = await compareCommits(orgName, repoName, base, head);
    res.json(comparison);
  } catch (error) {
    console.error("Failed to compare commits:", error);
    res.status(500).json({ error: "Failed to compare commits" });
  }
}

export async function handleGetAllOrganizationData(
  req: Request,
  res: Response
): Promise<void> {
  const org = req.query.org as string;
  if (!org) {
    res.status(400).json({ error: "Missing organization parameter" });
    return;
  }
  try {
    const repos = await getStudentReposForAssignment(org);
    const assignmentSet = new Set<string>();
    const studentMap = new Map<string, Record<string, null>>();
    for (const repo of repos) {
      const assignment = extractAssignmentName(repo.name);
      assignmentSet.add(assignment);
      const student = repo.collaborators?.[0]?.name || "Unknown Student";
      // TODO: get grade here later from the db (as given by the AI)
      if (!studentMap.has(student)) {
        studentMap.set(student, {});
      }
      studentMap.get(student)![assignment] = null;
    }
    const responseData = {
      org,
      assignments: Array.from(assignmentSet),
      submissions: Array.from(studentMap.entries()).map(
        ([student, grades]) => ({
          student,
          grades, // all values null for now
        })
      ),
    };
    res.json(responseData);
  } catch (error) {
    console.error("Failed to get all data:", error);
    res.status(500).json({ error: "Failed to generate all data" });
  }
}
</file>

<file path="server/Dockerfile">
# 1. Base image
FROM node:22-alpine
LABEL org.opencontainers.image.source="https://github.com/Summer-project-25-AI-Feedback-system/AFS"

# 2. Set working directory
WORKDIR /app

# 3. Copy package files and install deps
COPY server/package*.json ./server/
RUN cd server && npm install

# 4. Copy server code and shared interfaces
COPY . .

# 5. Build TypeScript
WORKDIR /app/server
RUN npm run build

# 6. Expose port
EXPOSE 5000

# 7. Start app
CMD ["node", "dist/server/index.js"]
</file>

<file path="server/index.ts">
import express from "express";
import session from "express-session";
import passport from "./utils/passport";
import cors from "cors";
import dotenv from "dotenv";
import authRoutes from "./routes/authRoutes";
import githubRoutes from "./routes/githubRoutes";
import submitRoute from "./routes/submitRoute";
import uploadCsvRoute from "./routes/uploadCsvRoute";
import aiRoutes from "./routes/aiRoutes";

dotenv.config();

const app = express();
const PORT = process.env.PORT || 5000;

app.use(
  cors({
    origin: process.env.FRONTEND_ORIGIN,
    credentials: true,
  })
);

app.use(express.json());
app.use(express.urlencoded({ extended: false }));

// Set up session
app.use(
  session({
    secret: process.env.SESSION_SECRET || "secret",
    resave: false,
    saveUninitialized: true,
    cookie: {
      httpOnly: true,
      secure: false, // Set to true only in production (HTTPS)
      sameSite: "lax", // or "none" if secure: true for cross-origin
    },
  })
);

// Initialize passport
app.use(passport.initialize());
app.use(passport.session());

// test message
app.get("/api/message", (req, res) => {
  res.json({ message: "Test message from backend!" });
});

// Routes
app.use("/api/auth", authRoutes);
app.use("/api/github", githubRoutes);
app.use("/api/evaluation", aiRoutes);
app.use("/submit", submitRoute);
app.use("/api", uploadCsvRoute);

// Error handling
app.use(
  (
    err: any,
    req: express.Request,
    res: express.Response,
    next: express.NextFunction
  ) => {
    console.error(err.stack);
    res.status(500).json({ error: "Something went wrong!" });
  }
);

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
</file>

<file path="server/middlewares/isAuthenticated.ts">
import { Request, Response, NextFunction } from "express";

export const isAuthenticated = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  if (req.isAuthenticated && req.isAuthenticated()) {
    return next();
  }
  res.status(401).json({ error: "Unauthorized" });
};
</file>

<file path="server/output/ASSIGNMENT_EVALUATION.md">
# Assignment Evaluation

## Summary

Overall, the codebase appears to be well-structured and organized, with clear file separation and logical grouping of components. The naming conventions for variables, functions, and files are descriptive, enhancing readability. The code follows best practices for modularity and avoids code duplication.

Here is the evaluation based on the criteria:

1. Syntax and Validity (8/10):
   - The code appears to be syntactically correct, but without running the code, it's challenging to confirm if it compiles without errors.

2. Structure and Organization (18/20):
   - The directory structure is well-organized, with components, pages, context, and services logically separated.
   - Proper separation of concerns is maintained with components and services in their respective directories.

3. Clarity and Readability (18/20):
   - Variable and function names are descriptive, making the code easy to read and understand.
   - The file structure and naming conventions are consistent, contributing to overall clarity.

4. Language-specific features (18/20):
   - The code utilizes language-specific features like React Router, context API, and TypeScript effectively.
   - TypeScript is used for type safety, enhancing code quality.

5. Best practices (28/30):
   - The code follows best practices by separating concerns, using context for state management, and employing TypeScript for type checking.
   - Error handling and code duplication seem to be appropriately addressed.

Total Rating: 4.2/5

Overall, the codebase demonstrates a strong understanding of best practices and language features. To further improve, consider adding comments for complex logic, ensuring consistent coding style across files, and implementing error handling where necessary. Keep up the good work!

Total Score: 4.5/5

## Metadata
- **Evaluation Date:** 09.06.2025 13.49
- **Evaluation ID:** AI-Feedback-System
- **Repository:** output
- **Assignment:** Assignment
</file>

<file path="server/package.json">
{
  "name": "ai-feedback-backend",
  "version": "1.0.0",
  "main": "dist/index.ts",
  "scripts": {
    "build": "tsc",
    "start": "node dist/server/index.js",
    "dev": "dotenv -e .env -- ts-node-dev --respawn index.ts"
  },
  "dependencies": {
    "@octokit/rest": "^21.1.1",
    "@supabase/supabase-js": "^2.49.8",
    "@types/react": "^19.1.4",
    "axios": "^1.6.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^5.1.0",
    "express-session": "^1.18.1",
    "json2csv": "^6.0.0-alpha.2",
    "nodemailer": "^6.10.1",
    "passport": "^0.7.0",
    "passport-github2": "^0.1.12",
    "react": "^19.1.0",
    "simple-git": "^3.28.0"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/json2csv": "^5.0.7",
    "@types/node": "^22.15.12",
    "@types/nodemailer": "^6.4.14",
    "@types/passport": "^1.0.17",
    "@types/passport-github2": "^1.2.9",
    "dotenv-cli": "^8.0.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.8.3",
    "vite-tsconfig-paths": "^5.1.4"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}
</file>

<file path="server/repomix.js">
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var child_process_1 = require("child_process");
var util_1 = require("util");
var fs = require("fs/promises");
var path = require("path");
// Muunna exec-funktio Promise-pohjaiseksi
var execPromise = (0, util_1.promisify)(child_process_1.exec);
// Kovakoodattu GitHub-osoite
var GITHUB_URL = 'https://github.com/Summer-project-25-AI-Feedback-system/AI-Feedback-System.git';
/**
 * Poistaa GitHub-repositorion nimen URL:sta
 * @param url GitHub-repositorion URL
 * @returns Repositorion nimi
 */
function getRepoNameFromUrl(url) {
    // Poista mahdollinen .git-pÃ¤Ã¤te
    var cleanUrl = url.replace(/\.git$/, '');
    // Hae viimeinen osa URL:sta (repositorion nimi)
    var repoName = cleanUrl.split('/').pop() || 'unknown-repo';
    return repoName;
}
var RepomixFetcher = /** @class */ (function () {
    function RepomixFetcher(outputDir) {
        if (outputDir === void 0) { outputDir = 'output'; }
        this.outputDir = path.resolve(outputDir);
        this.tempDir = path.join(process.cwd(), "repomix-temp-".concat(Date.now()));
    }
    RepomixFetcher.prototype.ensureDirectories = function () {
        return __awaiter(this, void 0, void 0, function () {
            var error_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 5, , 6]);
                        return [4 /*yield*/, fs.access(this.outputDir, fs.constants.W_OK).catch(function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, fs.mkdir(this.outputDir, { recursive: true })];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); })];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, fs.rm(this.tempDir, { recursive: true, force: true }).catch(function () { })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, fs.mkdir(this.tempDir, { recursive: true })];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, fs.access(this.tempDir, fs.constants.W_OK)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        error_1 = _a.sent();
                        throw new Error("Failed to set up directories: ".concat(error_1 instanceof Error ? error_1.message : error_1));
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    RepomixFetcher.prototype.fetchRepositoryAsXml = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var outputFileName, actualOutputFile, tempOutputFile, command, execOptions, _a, stdout, stderr, error_2, _b;
            var _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, this.ensureDirectories()];
                    case 1:
                        _e.sent();
                        outputFileName = (_c = options.outputFile) !== null && _c !== void 0 ? _c : 'repomix-output.xml';
                        actualOutputFile = path.join(this.outputDir, outputFileName).replace(/\\/g, '/');
                        tempOutputFile = path.join(this.tempDir, outputFileName).replace(/\\/g, '/');
                        command = "repomix --remote ".concat(options.remoteUrl, " --style ").concat((_d = options.style) !== null && _d !== void 0 ? _d : 'xml', " --output \"").concat(outputFileName, "\"");
                        if (options.ignore)
                            command += " --ignore \"".concat(options.ignore, "\"");
                        if (options.include)
                            command += " --include \"".concat(options.include, "\"");
                        if (options.verbose)
                            command += " --verbose";
                        execOptions = {
                            env: __assign(__assign({}, process.env), { PYTHONIOENCODING: 'utf-8', TMPDIR: this.tempDir, TEMP: this.tempDir, TMP: this.tempDir }),
                            cwd: this.tempDir,
                        };
                        _e.label = 2;
                    case 2:
                        _e.trys.push([2, 7, 14, 16]);
                        return [4 /*yield*/, execPromise(command, execOptions)];
                    case 3:
                        _a = _e.sent(), stdout = _a.stdout, stderr = _a.stderr;
                        if (stderr)
                            console.warn("Repomix stderr: ".concat(stderr));
                        if (stdout)
                            console.log("Repomix stdout: ".concat(stdout));
                        return [4 /*yield*/, fs.access(tempOutputFile, fs.constants.R_OK)];
                    case 4:
                        _e.sent();
                        return [4 /*yield*/, fs.rename(tempOutputFile, actualOutputFile)];
                    case 5:
                        _e.sent();
                        return [4 /*yield*/, fs.readFile(actualOutputFile, 'utf-8')];
                    case 6: return [2 /*return*/, _e.sent()];
                    case 7:
                        error_2 = _e.sent();
                        _e.label = 8;
                    case 8:
                        _e.trys.push([8, 12, , 13]);
                        return [4 /*yield*/, fs.access(tempOutputFile, fs.constants.R_OK)];
                    case 9:
                        _e.sent();
                        return [4 /*yield*/, fs.rename(tempOutputFile, actualOutputFile)];
                    case 10:
                        _e.sent();
                        return [4 /*yield*/, fs.readFile(actualOutputFile, 'utf-8')];
                    case 11: return [2 /*return*/, _e.sent()];
                    case 12:
                        _b = _e.sent();
                        return [3 /*break*/, 13];
                    case 13: throw new Error("Failed to fetch repository with Repomix: ".concat(error_2.message));
                    case 14: return [4 /*yield*/, fs.rm(this.tempDir, { recursive: true, force: true }).catch(function () { })];
                    case 15:
                        _e.sent();
                        return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    return RepomixFetcher;
}());
exports.default = RepomixFetcher;
</file>

<file path="server/repomix.ts">
import { exec } from "child_process";
import { promisify } from "util";
import * as fs from "fs/promises";
import * as path from "path";

// Convert exec function to Promise-based
const execPromise = promisify(exec);

/**
 * Extracts repository name from GitHub URL
 * @param url GitHub repository URL
 * @returns Repository name
 */
function getRepoNameFromUrl(url: string): string {
  return (
    url
      .replace(/\.git$/, "")
      .split("/")
      .pop() || "unknown-repo"
  );
}

/**
 * Repomix command options
 */
interface RepomixOptions {
  remoteUrl: string; // GitHub repository URL
  outputFile?: string; // Output file name (default: repomix-output.xml)
  style?: "xml" | "markdown" | "plain"; // Output format
  ignore?: string; // Files/directories to ignore (comma-separated)
  include?: string; // Files/directories to include (comma-separated)
  verbose?: boolean; // Detailed output
}

/**
 * Repomix command line tool handling
 */
export default class RepomixFetcher {
  constructor(private outputDir: string = "output") {}

  private async ensureDir(dir: string) {
    await fs.mkdir(dir, { recursive: true }).catch(() => {});
  }

  /**
   * Fetches GitHub repository content in XML format
   */
  async fetchRepositoryAsXml(options: RepomixOptions): Promise<string> {
    await this.ensureDir(this.outputDir);

    const outputFileName = options.outputFile ?? "repomix-output.xml";
    const outputFile = path.join(this.outputDir, outputFileName);

    let command = `repomix --remote ${options.remoteUrl} --style ${
      options.style ?? "xml"
    } --output "${outputFileName}"`;
    if (options.ignore) command += ` --ignore "${options.ignore}"`;
    if (options.include) command += ` --include "${options.include}"`;
    if (options.verbose) command += ` --verbose`;

    await execPromise(command, {
      env: { ...process.env, PYTHONIOENCODING: "utf-8" },
      cwd: this.outputDir,
    });

    return await fs.readFile(outputFile, "utf-8");
  }
}

/**
 * Main program
 */
async function main() {
  const args = process.argv.slice(2);
  if (args.length === 0) {
    console.error("Usage: npm start <github-url>");
    process.exit(1);
  }

  const githubUrl = args[0];
  const repoName = getRepoNameFromUrl(githubUrl);
  const fetcher = new RepomixFetcher();

  const xml = await fetcher.fetchRepositoryAsXml({
    remoteUrl: githubUrl,
    style: "xml",
    outputFile: `${repoName}.xml`,
    ignore:
      "node_modules/*,dist/*,build/*,*.md,*.log,*.lock,*.json,*.yml,*.yaml,*.xml,*.txt,*.gitignore,*.editorconfig,*.prettierrc,*.eslintrc,*.env,*.env.*,*.config.js,*.config.ts,*.d.ts,*.map,*.min.js,*.min.css,*.ico,*.png,*.jpg,*.jpeg,*.gif,*.svg,*.woff,*.woff2,*.ttf,*.eot,*.otf,*.mp3,*.mp4,*.webm,*.webp,*.zip,*.tar,*.gz,*.rar,*.7z,*.pdf,*.doc,*.docx,*.xls,*.xlsx,*.ppt,*.pptx,*.csv,*.tsv,*.sql,*.bak,*.tmp,*.temp,*.swp,*.swo,*.swn,*.sublime-workspace,*.sublime-project,*.vscode/*,*.idea/*,*.DS_Store,Thumbs.db",
    verbose: true,
  });

  console.log("Repository fetched as XML.");
  console.log(`XML file saved to: output/${repoName}.xml`);
}

// Execute main program
main();
</file>

<file path="server/routes/aiRoutes.ts">
import express from "express";
import {
  handleRunRepomix,
  handleRunAIEvolution,
} from "../controllers/aiController";

const router = express.Router();

router.post("/run-repomix", handleRunRepomix);
router.post("/run-aievolution", handleRunAIEvolution);

export default router;
</file>

<file path="server/routes/authRoutes.ts">
import { Router } from "express";
import passport from "../utils/passport";
import dotenv from "dotenv";
import {
  githubCallback,
  getCurrentUser,
  logout,
} from "../controllers/authController";
import { upsertUser } from "../services/UserService"; 

import { isAuthenticated } from "../middlewares/isAuthenticated";

dotenv.config();
const router = Router();

router.get(
  "/login",
  passport.authenticate("github", { scope: ["user:email"] })
);

router.get(
  "/callback",
  passport.authenticate("github", { failureRedirect: "/login" }),
  async (req, res) => {
    try {
      const user = req.user as {
        id: string;
        username: string;
        emails?: { value: string }[];
        profileUrl?: string;
      };

      const githubId = user.id;
      const username = user.username;
      const email = user.emails?.[0]?.value || ""; // fallback jos ei ole emailia
      const githubUrl = user.profileUrl || "";

      await upsertUser(githubId, username, email, githubUrl);

      res.redirect("http://localhost:5173/"); // tai frontend URL
    } catch (error) {
      console.error("Tallennus epÃ¤onnistui:", error);
      res.status(500).json({ error: "KÃ¤yttÃ¤jÃ¤n tallennus epÃ¤onnistui" });
    }
  }
);
router.get("/getCurrentUser", isAuthenticated, getCurrentUser);
router.get("/logout", isAuthenticated, logout);

export default router;
</file>

<file path="server/routes/githubRoutes.ts">
import { Router } from "express";
import {
  handleGetOrganizations,
  handleGetAssignments,
  handleGetStudentReposForAssignment,
  handleGetFileContents,
  handleGetRepoTree,
  handleGetAllOrganizationData,
  handleGetCommits,
  handleCompareCommits,
} from "../controllers/githubController";
import { isAuthenticated } from "../middlewares/isAuthenticated";

const router = Router();

router.use(isAuthenticated);

router.get("/orgs", handleGetOrganizations);
router.get("/orgs/:orgName/assignments", handleGetAssignments);
router.get(
  "/orgs/:orgName/assignments/:assignmentName/repos",
  handleGetStudentReposForAssignment
);

// Repository routes
router.get("/repos/:orgName/:repoName/commits", handleGetCommits);
router.get("/repos/:orgName/:repoName/tree", handleGetRepoTree);
router.get("/repos/:orgName/:repoName/contents", handleGetFileContents);
router.get(
  "/repos/:orgName/:repoName/compare/:base/:head",
  handleCompareCommits
);

// Reporting route
router.get("/org-report", handleGetAllOrganizationData);

//

export default router;
</file>

<file path="server/routes/submitRoute.ts">
import { Router, Request, Response } from "express";
import { upsertUser } from "../services/UserService";

const router = Router();

router.post("/", async (req: Request, res: Response) => {
  const { id, username, email, github_url } = req.body;

  try {
    const user = await upsertUser(id, username, email, github_url); // korjattu jÃ¤rjestys
    res.status(200).json({ message: "User upserted", user });
  } catch (err) {
    console.error("Virhe kÃ¤yttÃ¤jÃ¤n tallennuksessa:", err);
    res.status(500).json({ error: err instanceof Error ? err.message : "KÃ¤yttÃ¤jÃ¤n tallennus epÃ¤onnistui" });
  }
}); 

export default router;
</file>

<file path="server/routes/uploadCsvRoute.ts">
import { Router, Request, Response } from "express";
import { createClient } from "@supabase/supabase-js";
import { Parser } from "json2csv";
import dotenv from "dotenv";

dotenv.config({ path: "../.env" }); 
const router = Router();

if (!process.env.SUPABASE_URL || !process.env.SUPABASE_KEY) {
  throw new Error("Supabase URL or Key is missing in environment variables.");
}

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_KEY
);
router.post("/csv-reports", async (req: Request, res: Response): Promise<void> => {
  console.log("ðŸ”„ /csv-reports POST received");
  console.log("Body:", req.body); 

  try {
    const { rows, username } = req.body;
    
    console.log("Backend sai username:", username);

    const actualUsername = username || "unknownuser";

    if (!rows || !Array.isArray(rows.submissions)) {
      res.status(400).json({ error: "Invalid input data" });
      return;
    }

    const parser = new Parser();
    const csv = parser.parse(rows.submissions);
    const orgName = rows.org || "unknownorg";
   
    const repoName =
    Array.isArray(rows.assignments) && rows.assignments.length > 0
    ? rows.assignments[0]
    : "unknownrepo";

      const fileName = `${actualUsername}_${orgName}_${repoName}.csv`;
      const csvBuffer = new Uint8Array(Buffer.from(csv)); 

    const { error } = await supabase.storage
      .from("csv-reports")
      .upload(fileName, csvBuffer, {
        contentType: "text/csv",
        upsert: false,
      });

    if (error) throw error;

    console.log(`âœ… CSV uploaded as ${fileName}`);
    res.status(200).json({ message: "CSV uploaded successfully", fileName });
  } catch (err: any) {
    console.error("âŒ Error uploading CSV:", err.message);
    res.status(500).json({ error: "CSV upload failed", details: err.message });
  }
});

export default router;
</file>

<file path="server/services/ai/aiService.ts">
import RepomixFetcher from "../../repomix";
import { evaluateWithOpenAI } from "../../Aievolution";

export async function runRepomix(repoUrl: string) {
  const fetcher = new RepomixFetcher("output");
  const result = await fetcher.fetchRepositoryAsXml({
    remoteUrl: repoUrl,
    style: "xml",
  });
  return result;
}

export async function runAIEvolution(
  xml: string,
  organizationId: string,
  repoPath: string
) {
  const feedback = await evaluateWithOpenAI(xml, organizationId, repoPath);
  return feedback;
}
</file>

<file path="server/services/github/githubService.ts">
import { promises } from "dns";
import { octokit } from "./octokitClient";
import {
  OrgInfo,
  AssignmentInfo,
  RepoInfo,
  CommitInfo,
  CompareCommitsInfo,
} from "@shared/githubInterfaces";

export async function getOrganizations(): Promise<OrgInfo[]> {
  const response = await octokit.rest.orgs.listForAuthenticatedUser();
  return response.data.map(
    (org): OrgInfo => ({
      name: org.login,
      description: org.description,
      avatarUrl: org.avatar_url,
    })
  );
}

export async function getAssignments(org: string): Promise<AssignmentInfo[]> {
  const repos = await octokit.rest.repos.listForOrg({
    org: org,
    type: "all",
    per_page: 100,
  });

  const assignmentMap = new Map<string, AssignmentInfo>();

  repos.data.forEach((repo) => {
    const baseName = repo.name.replace(/-[a-z0-9]+$/i, "");
    const updatedAt = repo.updated_at;

    const assignment = assignmentMap.get(baseName);

    if (!assignment) {
      assignmentMap.set(baseName, {
        name: baseName,
        amountOfStudents: 1,
        updatedAt: updatedAt ?? "",
      });
    } else {
      assignment.amountOfStudents++;
      if (
        updatedAt &&
        (!assignment.updatedAt ||
          new Date(updatedAt) > new Date(assignment.updatedAt))
      ) {
        assignment.updatedAt = updatedAt;
      }
    }
  });

  return Array.from(assignmentMap.values());
}

export async function getStudentReposForAssignment(
  org: string,
  assignmentPrefix?: string
): Promise<RepoInfo[]> {
  console.log(
    `Searching for repositories ${
      assignmentPrefix ? `with prefix '${assignmentPrefix}' ` : ""
    }under organization ${org}...`
  );
  const repositories: any[] = [];
  const iterator = await buildSearchQuery(org, assignmentPrefix);

  for await (const { data: reposPage } of iterator) {
    const relevantRepos = reposPage.filter(
      (repo) =>
        !assignmentPrefix ||
        repo.name.toLowerCase().includes(assignmentPrefix.toLowerCase())
    );

    const detailPromises = relevantRepos.map((repo) =>
      extractRepositoryDetails(org, repo)
    );

    const detailResults = await Promise.allSettled(detailPromises);

    detailResults.forEach((result) => {
      if (result.status === "fulfilled") {
        repositories.push(result.value);
      } else {
        console.warn("Repo detail fetch failed:", result.reason);
      }
    });
  }
  console.log(`Found ${repositories.length} matching repositories.`);
  return repositories;
}

async function buildSearchQuery(org: string, assignmentPrefix?: string) {
  const query =
    `fork:true org:${org}` +
    (assignmentPrefix ? ` ${assignmentPrefix} in:name` : "");

  return octokit.paginate.iterator(octokit.rest.search.repos, {
    q: query,
    per_page: 100,
  });
}

async function extractRepositoryDetails(org: string, repo: any) {
  const lastCommit = await octokit.rest.repos.getCommit({
    owner: org,
    repo: repo.name,
    ref: repo.default_branch,
  });

  return {
    id: repo.node_id,
    name: repo.name,
    owner: repo.owner?.login || "unknown",
    avatarUrl: repo.owner?.avatar_url ?? "",
    url: repo.html_url,
    description: repo.description ?? undefined,
    defaultBranch: repo.default_branch,
    createdAt: repo.created_at,
    updatedAt: repo.updated_at,
    lastPush: repo.pushed_at,
    lastCommitMessage: lastCommit.data.commit.message,
    lastCommitDate: lastCommit.data.commit.committer?.date,
    collaborators: await getRepoCollaborators(org, repo.name),
  };
}

async function getRepoCollaborators(org: string, repo: string) {
  try {
    const response = await octokit.rest.repos.listCollaborators({
      owner: org,
      repo,
      affiliation: "direct",
    });

    return response.data.map((user) => ({
      id: user.id,
      name: user.login,
      avatarUrl: user.avatar_url,
      htmlUrl: user.html_url,
      permissions: {
        admin: user.permissions?.admin ?? false,
        maintain: user.permissions?.maintain ?? false,
        push: user.permissions?.push ?? false,
        triage: user.permissions?.triage ?? false,
        pull: user.permissions?.pull ?? false,
      },
    }));
  } catch (error: any) {
    console.error(`Error fetching collaborators for ${repo}:`, error.message);
    return [];
  }
}

// export async function getFileContents(
//   owner: string,
//   repo: string,
//   filePaths: string[]
// ): Promise<Record<string, string | null>> {
//   const contents: Record<string, string | null> = {};
//   console.log(`\nFetching files from repository ${owner}/${repo}:`);

//   for (const filePath of filePaths) {
//     try {
//       const response = await octokit.rest.repos.getContent({
//         owner,
//         repo,
//         path: filePath,
//       });

//       if (
//         response.data &&
//         !Array.isArray(response.data) &&
//         response.data.type === "file" &&
//         response.data.content
//       ) {
//         const content = Buffer.from(response.data.content, "base64").toString(
//           "utf-8"
//         );
//         contents[filePath] = content;
//         console.log(` - ${filePath}: Downloaded (${content.length} bytes)`);
//       } else {
//         console.log(
//           ` - ${filePath}: Path found, but it's not a file or content is missing.`
//         );
//         contents[filePath] = null;
//       }
//     } catch (error: any) {
//       if (error.status === 404) {
//         console.log(` - ${filePath}: Not found.`);
//       } else {
//         console.error(
//           ` - Error fetching file ${filePath} from ${owner}/${repo}: ${error.status} ${error.message}`
//         );
//       }
//       contents[filePath] = null;
//     }
//   }

//   return contents;
// }

export async function getCommits(
  orgName: string,
  repoName: string
): Promise<CommitInfo[]> {
  const response = await octokit.rest.repos.listCommits({
    owner: orgName,
    repo: repoName,
    per_page: 100,
  });

  return response.data.map((commit) => ({
    sha: commit.sha,
    html_url: commit.html_url,
    commit: {
      message: commit.commit.message,
      author: {
        name: commit.commit.author?.name ?? "",
        email: commit.commit.author?.email ?? "",
        date: commit.commit.author?.date ?? "",
      },
    },
    author: commit.author
      ? {
          login: commit.author.login,
          avatar_url: commit.author.avatar_url,
          html_url: commit.author.html_url,
        }
      : null,
  }));
}
export async function getRepoTree(
  orgName: string,
  repoName: string
): Promise<string[]> {
  const { data: refData } = await octokit.rest.git.getRef({
    owner: orgName,
    repo: repoName,
    ref: "heads/main",
  });

  const { data: treeData } = await octokit.rest.git.getTree({
    owner: orgName,
    repo: repoName,
    tree_sha: refData.object.sha,
    recursive: "true",
  });

  return treeData.tree
    .filter((item) => item.type === "blob" && item.path)
    .map((item) => item.path!);
}

export async function getFileContents(
  orgName: string,
  repoName: string,
  path: string
): Promise<string | null> {
  try {
    const response = await octokit.rest.repos.getContent({
      owner: orgName,
      repo: repoName,
      path,
    });

    if ("content" in response.data) {
      return Buffer.from(response.data.content, "base64").toString("utf-8");
    }
    return null;
  } catch (error) {
    console.error(`Error fetching file ${path}:`, error);
    return null;
  }
}

export async function compareCommits(
  orgName: string,
  repoName: string,
  base: string,
  head: string
): Promise<CompareCommitsInfo> {
  const response = await octokit.rest.repos.compareCommits({
    owner: orgName,
    repo: repoName,
    base,
    head,
  });

  return {
    status: response.data.status ?? "",
    ahead_by: response.data.ahead_by ?? 0,
    behind_by: response.data.behind_by ?? 0,
    total_commits: response.data.total_commits ?? 0,
    commits: response.data.commits.map((commit) => ({
      sha: commit.sha,
      html_url: commit.html_url,
      commit: {
        message: commit.commit.message,
        author: {
          name: commit.commit.author?.name ?? "",
          email: commit.commit.author?.email ?? "",
          date: commit.commit.author?.date ?? "",
        },
      },
      author: commit.author
        ? {
            login: commit.author.login,
            avatar_url: commit.author.avatar_url,
            html_url: commit.author.html_url,
          }
        : null,
    })),
    files:
      response.data.files?.map((file) => ({
        filename: file.filename,
        status: file.status,
        additions: file.additions,
        deletions: file.deletions,
        changes: file.changes,
      })) ?? [],
  };
}
export async function getRepos(org: string): Promise<any[]> {
  const repos = await octokit.rest.repos.listForOrg({
    org,
    type: "all",
    per_page: 100,
  });

  return repos.data;
}
</file>

<file path="server/services/github/octokitClient.ts">
import { Octokit } from "@octokit/rest";
import dotenv from "dotenv";

dotenv.config();

export const octokit = new Octokit({
  auth: process.env.GITHUB_PAT,
});
</file>

<file path="server/services/UserService.ts">
import { supabase } from "../utils/supabase";

export async function upsertUser(
  githubId: string,
  username: string,
  email: string,
  githubUrl: string
) {
  try {
    const result = await supabase
      .from("users")
      .upsert(
        {
          github_id: githubId,
          username: username,
          github_url: githubUrl,
          email: email,
        },
        { onConflict: "github_id" }
      )
      .select()
      .single();

    // console.log("Supabase upsert result:", result);

    if (result.error) {
      console.error("Supabase error:", result.error);
      throw result.error;
    }

    return result.data;
  } catch (err) {
    console.error("Virhe kÃ¤yttÃ¤jÃ¤n tallennuksessa (catch):", err);
    throw err;
  }
}
</file>

<file path="server/tsconfig.json">
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "target": "ES2020", // Modern JS features
    "module": "CommonJS",
    "moduleResolution": "node", // Node-style resolution
    "rootDir": "..", // Source root
    "outDir": "./dist", // Output folder
    "esModuleInterop": true, // Support commonjs modules
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@shared/*": ["../shared/*"]
    }
  },
  "include": ["./", "Aievolution.ts"], // Include all files in this folder
  "exclude": ["node_modules", "dist"] // Avoid compiling node_modules and output
}
</file>

<file path="server/utils/githubUtils.ts">
export function extractAssignmentName(repoName: string): string {
  // Example: "assignment1-alice" => "assignment1"
  // TODO: modify or change this later if we need something different
  return repoName.replace(/-[a-zA-Z0-9]+$/, "");
}
</file>

<file path="server/utils/json2csv.ts">
declare module "json2csv" {
  export class Parser<T> {
    constructor(opts?: any);
    parse(input: T[]): string;
  }
}
</file>

<file path="server/utils/passport.ts">
import passport from "passport";
import { Strategy as GitHubStrategy, Profile } from "passport-github2";
import dotenv from "dotenv";

dotenv.config();

// GitHub OAuth configuration
passport.use(
  new GitHubStrategy(
    {
      clientID: process.env.GITHUB_CLIENT_ID as string,
      clientSecret: process.env.GITHUB_CLIENT_SECRET as string,
      callbackURL: process.env.GITHUB_CALLBACK_URL as string,
    },
    (
      accessToken: string,
      refreshToken: string,
      profile: Profile,
      done: (error: any, user?: Express.User | false | null) => void
    ) => {
      // console.log("Access Token:", accessToken);
      // console.log("GitHub Profile:", profile);
      return done(null, profile);
    }
  )
);

// Serialize user to store user in session
passport.serializeUser((user, done) => {
  done(null, user);
});

// Deserialize user from session
passport.deserializeUser((user, done) => {
  done(null, user as Express.User);
});

export default passport;
</file>

<file path="server/utils/supabase.ts">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.SUPABASE_URL!;
const supabaseKey = process.env.SUPABASE_KEY!;

export const supabase = createClient(supabaseUrl, supabaseKey);
</file>

<file path="shared/aiInterfaces.ts">
export interface AssignmentFeedback {
  // studentName: string;
  repoName: string;
  assignmentTitle: string;
  grade: string;
  date: string; // ISO format
  feedback: string;
  feedbackByFile: FileFeedback[];
}

interface FileFeedback {
  fileName: string;
  issues: FeedbackIssue[];
}

interface FeedbackIssue {
  id: number;
  line?: number;
  text: string;
}
</file>

<file path="shared/githubInterfaces.ts">
export interface OrgInfo {
  name: string;
  description: string | null;
  avatarUrl: string;
}

export interface AssignmentInfo {
  name: string;
  amountOfStudents: number;
  updatedAt: string;
}

export interface RepoInfo {
  id: string;
  name: string;
  owner: string;
  avatarUrl: string;
  url: string;
  description?: string;
  defaultBranch: string;
  createdAt: string;
  updatedAt: string;
  lastPush: string;
  lastCommitMessage: string;
  lastCommitDate: string;
  collaborators: Collaborator[];
}

export interface Collaborator {
  id: number;
  name: string;
  avatarUrl: string;
  htmlUrl: string;
  permissions: {
    admin: boolean;
    maintain: boolean;
    push: boolean;
    triage: boolean;
    pull: boolean;
  };
}

export interface User {
  id: string;
  username: string;
  displayName?: string;
  profileUrl?: string;
  photos?: { value: string }[];
}

export interface CommitAuthor {
  name: string;
  email: string;
  date: string;
}

export interface Commit {
  message: string;
  author: CommitAuthor;
}

export interface CommitInfo {
  sha: string;
  html_url: string;
  commit: Commit;
  author: {
    login: string;
    avatar_url: string;
    html_url: string;
  } | null;
}

export interface CompareCommitsInfo {
  status: string;
  ahead_by: number;
  behind_by: number;
  total_commits: number;
  commits: CommitInfo[];
  files: {
    filename: string;
    status: string;
    additions: number;
    deletions: number;
    changes: number;
  }[];
}
</file>

</files>
</file>

<file path="server/output/ASSIGNMENT_EVALUATION.md">
# Assignment Evaluation

## Summary

Overall, the student's code appears to be well-structured and organized, with clear naming conventions and good use of language-specific features. However, there are some areas for improvement in terms of syntax, clarity, and best practices.

1. Syntax and Validity (8/10):
The code appears to be syntactically correct and should run without errors. However, it would be beneficial to include error handling mechanisms to improve robustness.

2. Structure and Organization (18/20):
The code is logically organized into different components and files, making it easy to navigate. Functions, classes, and modules are used appropriately, contributing to good modularity.

3. Clarity and Readability (16/20):
Variable, function, and class names are descriptive, enhancing readability. However, some parts of the code could benefit from additional comments or documentation to explain complex logic or functionality.

4. Language-specific features (18/20):
The code effectively utilizes language-specific features such as TypeScript, React, and ESLint configurations. It follows best practices for these technologies, contributing to maintainability.

5. Best practices (25/30):
The code generally follows best practices, but there are opportunities for improvement in terms of code duplication and error handling. Encouraging the student to refactor repetitive code into reusable functions and implement comprehensive error handling would enhance the codebase.

The student has demonstrated a solid understanding of structuring and organizing code effectively. Encourage them to focus on improving error handling, adding documentation, and reducing code duplication to further enhance the quality of their work. Keep up the good work!

Total Score: 4.3/5

## Metadata
- **Evaluation Date:** 10.06.2025 11.41
- **Evaluation ID:** AI-Feedback-System
- **Repository:** output
- **Assignment:** Assignment
</file>

<file path="server/package.json">
{
  "name": "ai-feedback-backend",
  "version": "1.0.0",
  "main": "dist/index.ts",
  "scripts": {
    "build": "tsc",
    "start": "node dist/server/index.js",
    "dev": "dotenv -e .env -- ts-node-dev --respawn index.ts"
  },
  "dependencies": {
    "@octokit/rest": "^21.1.1",
    "@supabase/supabase-js": "^2.49.8",
    "@types/react": "^19.1.4",
    "axios": "^1.6.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^5.1.0",
    "express-session": "^1.18.1",
    "json2csv": "^6.0.0-alpha.2",
    "nodemailer": "^6.10.1",
    "passport": "^0.7.0",
    "passport-github2": "^0.1.12",
    "react": "^19.1.0",
    "simple-git": "^3.28.0"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/json2csv": "^5.0.7",
    "@types/node": "^22.15.12",
    "@types/nodemailer": "^6.4.14",
    "@types/passport": "^1.0.17",
    "@types/passport-github2": "^1.2.9",
    "dotenv-cli": "^8.0.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.8.3",
    "vite-tsconfig-paths": "^5.1.4"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}
</file>

<file path="server/repomix.js">
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var child_process_1 = require("child_process");
var util_1 = require("util");
var fs = require("fs/promises");
var path = require("path");
// Muunna exec-funktio Promise-pohjaiseksi
var execPromise = (0, util_1.promisify)(child_process_1.exec);
// Kovakoodattu GitHub-osoite
var GITHUB_URL = 'https://github.com/Summer-project-25-AI-Feedback-system/AI-Feedback-System.git';
/**
 * Poistaa GitHub-repositorion nimen URL:sta
 * @param url GitHub-repositorion URL
 * @returns Repositorion nimi
 */
function getRepoNameFromUrl(url) {
    // Poista mahdollinen .git-pÃ¤Ã¤te
    var cleanUrl = url.replace(/\.git$/, '');
    // Hae viimeinen osa URL:sta (repositorion nimi)
    var repoName = cleanUrl.split('/').pop() || 'unknown-repo';
    return repoName;
}
var RepomixFetcher = /** @class */ (function () {
    function RepomixFetcher(outputDir) {
        if (outputDir === void 0) { outputDir = 'output'; }
        this.outputDir = path.resolve(outputDir);
        this.tempDir = path.join(process.cwd(), "repomix-temp-".concat(Date.now()));
    }
    RepomixFetcher.prototype.ensureDirectories = function () {
        return __awaiter(this, void 0, void 0, function () {
            var error_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 5, , 6]);
                        return [4 /*yield*/, fs.access(this.outputDir, fs.constants.W_OK).catch(function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, fs.mkdir(this.outputDir, { recursive: true })];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); })];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, fs.rm(this.tempDir, { recursive: true, force: true }).catch(function () { })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, fs.mkdir(this.tempDir, { recursive: true })];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, fs.access(this.tempDir, fs.constants.W_OK)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        error_1 = _a.sent();
                        throw new Error("Failed to set up directories: ".concat(error_1 instanceof Error ? error_1.message : error_1));
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    RepomixFetcher.prototype.fetchRepositoryAsXml = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var outputFileName, actualOutputFile, tempOutputFile, command, execOptions, _a, stdout, stderr, error_2, _b;
            var _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, this.ensureDirectories()];
                    case 1:
                        _e.sent();
                        outputFileName = (_c = options.outputFile) !== null && _c !== void 0 ? _c : 'repomix-output.xml';
                        actualOutputFile = path.join(this.outputDir, outputFileName).replace(/\\/g, '/');
                        tempOutputFile = path.join(this.tempDir, outputFileName).replace(/\\/g, '/');
                        command = "repomix --remote ".concat(options.remoteUrl, " --style ").concat((_d = options.style) !== null && _d !== void 0 ? _d : 'xml', " --output \"").concat(outputFileName, "\"");
                        if (options.ignore)
                            command += " --ignore \"".concat(options.ignore, "\"");
                        if (options.include)
                            command += " --include \"".concat(options.include, "\"");
                        if (options.verbose)
                            command += " --verbose";
                        execOptions = {
                            env: __assign(__assign({}, process.env), { PYTHONIOENCODING: 'utf-8', TMPDIR: this.tempDir, TEMP: this.tempDir, TMP: this.tempDir }),
                            cwd: this.tempDir,
                        };
                        _e.label = 2;
                    case 2:
                        _e.trys.push([2, 7, 14, 16]);
                        return [4 /*yield*/, execPromise(command, execOptions)];
                    case 3:
                        _a = _e.sent(), stdout = _a.stdout, stderr = _a.stderr;
                        if (stderr)
                            console.warn("Repomix stderr: ".concat(stderr));
                        if (stdout)
                            console.log("Repomix stdout: ".concat(stdout));
                        return [4 /*yield*/, fs.access(tempOutputFile, fs.constants.R_OK)];
                    case 4:
                        _e.sent();
                        return [4 /*yield*/, fs.rename(tempOutputFile, actualOutputFile)];
                    case 5:
                        _e.sent();
                        return [4 /*yield*/, fs.readFile(actualOutputFile, 'utf-8')];
                    case 6: return [2 /*return*/, _e.sent()];
                    case 7:
                        error_2 = _e.sent();
                        _e.label = 8;
                    case 8:
                        _e.trys.push([8, 12, , 13]);
                        return [4 /*yield*/, fs.access(tempOutputFile, fs.constants.R_OK)];
                    case 9:
                        _e.sent();
                        return [4 /*yield*/, fs.rename(tempOutputFile, actualOutputFile)];
                    case 10:
                        _e.sent();
                        return [4 /*yield*/, fs.readFile(actualOutputFile, 'utf-8')];
                    case 11: return [2 /*return*/, _e.sent()];
                    case 12:
                        _b = _e.sent();
                        return [3 /*break*/, 13];
                    case 13: throw new Error("Failed to fetch repository with Repomix: ".concat(error_2.message));
                    case 14: return [4 /*yield*/, fs.rm(this.tempDir, { recursive: true, force: true }).catch(function () { })];
                    case 15:
                        _e.sent();
                        return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    return RepomixFetcher;
}());
exports.default = RepomixFetcher;
</file>

<file path="server/repomix.ts">
import { exec } from "child_process";
import { promisify } from "util";
import * as fs from "fs/promises";
import * as path from "path";

// Convert exec function to Promise-based
const execPromise = promisify(exec);

/**
 * Extracts repository name from GitHub URL
 * @param url GitHub repository URL
 * @returns Repository name
 */
function getRepoNameFromUrl(url: string): string {
  return (
    url
      .replace(/\.git$/, "")
      .split("/")
      .pop() || "unknown-repo"
  );
}

/**
 * Repomix command options
 */
interface RepomixOptions {
  remoteUrl: string; // GitHub repository URL
  outputFile?: string; // Output file name (default: repomix-output.xml)
  style?: "xml" | "markdown" | "plain"; // Output format
  ignore?: string; // Files/directories to ignore (comma-separated)
  include?: string; // Files/directories to include (comma-separated)
  verbose?: boolean; // Detailed output
}

/**
 * Repomix command line tool handling
 */
export default class RepomixFetcher {
  constructor(private outputDir: string = "output") {}

  private async ensureDir(dir: string) {
    await fs.mkdir(dir, { recursive: true }).catch(() => {});
  }

  /**
   * Fetches GitHub repository content in XML format
   */
  async fetchRepositoryAsXml(options: RepomixOptions): Promise<string> {
    await this.ensureDir(this.outputDir);

    const outputFileName = options.outputFile ?? "repomix-output.xml";
    const outputFile = path.join(this.outputDir, outputFileName);

    let command = `repomix --remote ${options.remoteUrl} --style ${
      options.style ?? "xml"
    } --output "${outputFileName}"`;
    if (options.ignore) command += ` --ignore "${options.ignore}"`;
    if (options.include) command += ` --include "${options.include}"`;
    if (options.verbose) command += ` --verbose`;

    await execPromise(command, {
      env: { ...process.env, PYTHONIOENCODING: "utf-8" },
      cwd: this.outputDir,
    });

    return await fs.readFile(outputFile, "utf-8");
  }
}

/**
 * Main program
 */
async function main() {
  const args = process.argv.slice(2);
  if (args.length === 0) {
    console.error("Usage: npm start <github-url>");
    process.exit(1);
  }

  const githubUrl = args[0];
  const repoName = getRepoNameFromUrl(githubUrl);
  const fetcher = new RepomixFetcher();

  const xml = await fetcher.fetchRepositoryAsXml({
    remoteUrl: githubUrl,
    style: "xml",
    outputFile: `${repoName}.xml`,
    ignore:
      "node_modules/*,dist/*,build/*,*.md,*.log,*.lock,*.json,*.yml,*.yaml,*.xml,*.txt,*.gitignore,*.editorconfig,*.prettierrc,*.eslintrc,*.env,*.env.*,*.config.js,*.config.ts,*.d.ts,*.map,*.min.js,*.min.css,*.ico,*.png,*.jpg,*.jpeg,*.gif,*.svg,*.woff,*.woff2,*.ttf,*.eot,*.otf,*.mp3,*.mp4,*.webm,*.webp,*.zip,*.tar,*.gz,*.rar,*.7z,*.pdf,*.doc,*.docx,*.xls,*.xlsx,*.ppt,*.pptx,*.csv,*.tsv,*.sql,*.bak,*.tmp,*.temp,*.swp,*.swo,*.swn,*.sublime-workspace,*.sublime-project,*.vscode/*,*.idea/*,*.DS_Store,Thumbs.db",
    verbose: true,
  });

  console.log("Repository fetched as XML.");
  console.log(`XML file saved to: output/${repoName}.xml`);
}

// Execute main program
main();
</file>

<file path="server/routes/aiRoutes.ts">
import express from "express";
import {
  handleRunRepomix,
  handleRunAIEvolution,
} from "../controllers/aiController";

const router = express.Router();

router.post("/run-repomix", handleRunRepomix);
router.post("/run-aievolution", handleRunAIEvolution);

export default router;
</file>

<file path="server/routes/authRoutes.ts">
import { Router } from "express";
import passport from "../utils/passport";
import dotenv from "dotenv";
import {
  githubCallback,
  getCurrentUser,
  logout,
} from "../controllers/authController";
import { upsertUser } from "../services/UserService"; 

import { isAuthenticated } from "../middlewares/isAuthenticated";

dotenv.config();
const router = Router();

router.get(
  "/login",
  passport.authenticate("github", { scope: ["user:email"] })
);

router.get(
  "/callback",
  passport.authenticate("github", { failureRedirect: "/login" }),
  async (req, res) => {
    try {
      const user = req.user as {
        id: string;
        username: string;
        emails?: { value: string }[];
        profileUrl?: string;
      };

      const githubId = user.id;
      const username = user.username;
      const email = user.emails?.[0]?.value || ""; // fallback jos ei ole emailia
      const githubUrl = user.profileUrl || "";

      await upsertUser(githubId, username, email, githubUrl);

      res.redirect("http://localhost:5173/"); // tai frontend URL
    } catch (error) {
      console.error("Tallennus epÃ¤onnistui:", error);
      res.status(500).json({ error: "KÃ¤yttÃ¤jÃ¤n tallennus epÃ¤onnistui" });
    }
  }
);
router.get("/getCurrentUser", isAuthenticated, getCurrentUser);
router.get("/logout", isAuthenticated, logout);

export default router;
</file>

<file path="server/routes/githubRoutes.ts">
import { Router } from "express";
import {
  handleGetOrganizations,
  handleGetAssignments,
  handleGetStudentReposForAssignment,
  handleGetFileContents,
  handleGetRepoTree,
  handleGetAllOrganizationData,
  handleGetCommits,
  handleCompareCommits,
} from "../controllers/githubController";
import { isAuthenticated } from "../middlewares/isAuthenticated";

const router = Router();

router.use(isAuthenticated);

router.get("/orgs", handleGetOrganizations);
router.get("/orgs/:orgName/assignments", handleGetAssignments);
router.get(
  "/orgs/:orgName/assignments/:assignmentName/repos",
  handleGetStudentReposForAssignment
);

// Repository routes
router.get("/repos/:orgName/:repoName/commits", handleGetCommits);
router.get("/repos/:orgName/:repoName/tree", handleGetRepoTree);
router.get("/repos/:orgName/:repoName/contents", handleGetFileContents);
router.get(
  "/repos/:orgName/:repoName/compare/:base/:head",
  handleCompareCommits
);

// Reporting route
router.get("/org-report", handleGetAllOrganizationData);

//

export default router;
</file>

<file path="server/routes/submitRoute.ts">
import { Router, Request, Response } from "express";
import { upsertUser } from "../services/UserService";

const router = Router();

router.post("/", async (req: Request, res: Response) => {
  const { id, username, email, github_url } = req.body;

  try {
    const user = await upsertUser(id, username, email, github_url); // korjattu jÃ¤rjestys
    res.status(200).json({ message: "User upserted", user });
  } catch (err) {
    console.error("Virhe kÃ¤yttÃ¤jÃ¤n tallennuksessa:", err);
    res.status(500).json({ error: err instanceof Error ? err.message : "KÃ¤yttÃ¤jÃ¤n tallennus epÃ¤onnistui" });
  }
}); 

export default router;
</file>

<file path="server/routes/uploadCsvRoute.ts">
import { Router, Request, Response } from "express";
import { createClient } from "@supabase/supabase-js";
import { Parser } from "json2csv";
import dotenv from "dotenv";

dotenv.config({ path: "../.env" }); 
const router = Router();

if (!process.env.SUPABASE_URL || !process.env.SUPABASE_KEY) {
  throw new Error("Supabase URL or Key is missing in environment variables.");
}

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_KEY
);
router.post("/csv-reports", async (req: Request, res: Response): Promise<void> => {
  console.log("ðŸ”„ /csv-reports POST received");
  console.log("Body:", req.body); 

  try {
    const { rows, username } = req.body;
    
    console.log("Backend sai username:", username);

    const actualUsername = username || "unknownuser";

    if (!rows || !Array.isArray(rows.submissions)) {
      res.status(400).json({ error: "Invalid input data" });
      return;
    }

    const parser = new Parser();
    const csv = parser.parse(rows.submissions);
    const orgName = rows.org || "unknownorg";
   
    const repoName =
    Array.isArray(rows.assignments) && rows.assignments.length > 0
    ? rows.assignments[0]
    : "unknownrepo";

      const fileName = `${actualUsername}_${orgName}_${repoName}.csv`;
      const csvBuffer = new Uint8Array(Buffer.from(csv)); 

    const { error } = await supabase.storage
      .from("csv-reports")
      .upload(fileName, csvBuffer, {
        contentType: "text/csv",
        upsert: false,
      });

    if (error) throw error;

    console.log(`âœ… CSV uploaded as ${fileName}`);
    res.status(200).json({ message: "CSV uploaded successfully", fileName });
  } catch (err: any) {
    console.error("âŒ Error uploading CSV:", err.message);
    res.status(500).json({ error: "CSV upload failed", details: err.message });
  }
});

export default router;
</file>

<file path="server/services/ai/aiService.ts">
import RepomixFetcher from "../../repomix";
import { evaluateWithOpenAI } from "../../Aievolution";

export async function runRepomix(repoUrl: string) {
  const fetcher = new RepomixFetcher("output");
  const result = await fetcher.fetchRepositoryAsXml({
    remoteUrl: repoUrl,
    style: "xml",
  });
  return result;
}

export async function runAIEvolution(
  xml: string,
  organizationId: string,
  repoPath: string
) {
  const feedback = await evaluateWithOpenAI(xml, organizationId, repoPath);
  return feedback;
}
</file>

<file path="server/services/github/githubService.ts">
import { promises } from "dns";
import { octokit } from "./octokitClient";
import {
  OrgInfo,
  AssignmentInfo,
  RepoInfo,
  CommitInfo,
  CompareCommitsInfo,
} from "@shared/githubInterfaces";

export async function getOrganizations(): Promise<OrgInfo[]> {
  const response = await octokit.rest.orgs.listForAuthenticatedUser();
  return response.data.map(
    (org): OrgInfo => ({
      name: org.login,
      description: org.description,
      avatarUrl: org.avatar_url,
    })
  );
}

export async function getAssignments(org: string): Promise<AssignmentInfo[]> {
  const repos = await octokit.rest.repos.listForOrg({
    org: org,
    type: "all",
    per_page: 100,
  });

  const assignmentMap = new Map<string, AssignmentInfo>();

  repos.data.forEach((repo) => {
    const baseName = repo.name.replace(/-[a-z0-9]+$/i, "");
    const updatedAt = repo.updated_at;

    const assignment = assignmentMap.get(baseName);

    if (!assignment) {
      assignmentMap.set(baseName, {
        name: baseName,
        amountOfStudents: 1,
        updatedAt: updatedAt ?? "",
      });
    } else {
      assignment.amountOfStudents++;
      if (
        updatedAt &&
        (!assignment.updatedAt ||
          new Date(updatedAt) > new Date(assignment.updatedAt))
      ) {
        assignment.updatedAt = updatedAt;
      }
    }
  });

  return Array.from(assignmentMap.values());
}

export async function getStudentReposForAssignment(
  org: string,
  assignmentPrefix?: string
): Promise<RepoInfo[]> {
  console.log(
    `Searching for repositories ${
      assignmentPrefix ? `with prefix '${assignmentPrefix}' ` : ""
    }under organization ${org}...`
  );
  const repositories: any[] = [];
  const iterator = await buildSearchQuery(org, assignmentPrefix);

  for await (const { data: reposPage } of iterator) {
    const relevantRepos = reposPage.filter(
      (repo) =>
        !assignmentPrefix ||
        repo.name.toLowerCase().includes(assignmentPrefix.toLowerCase())
    );

    const detailPromises = relevantRepos.map((repo) =>
      extractRepositoryDetails(org, repo)
    );

    const detailResults = await Promise.allSettled(detailPromises);

    detailResults.forEach((result) => {
      if (result.status === "fulfilled") {
        repositories.push(result.value);
      } else {
        console.warn("Repo detail fetch failed:", result.reason);
      }
    });
  }
  console.log(`Found ${repositories.length} matching repositories.`);
  return repositories;
}

async function buildSearchQuery(org: string, assignmentPrefix?: string) {
  const query =
    `fork:true org:${org}` +
    (assignmentPrefix ? ` ${assignmentPrefix} in:name` : "");

  return octokit.paginate.iterator(octokit.rest.search.repos, {
    q: query,
    per_page: 100,
  });
}

async function extractRepositoryDetails(org: string, repo: any) {
  const lastCommit = await octokit.rest.repos.getCommit({
    owner: org,
    repo: repo.name,
    ref: repo.default_branch,
  });

  return {
    id: repo.node_id,
    name: repo.name,
    owner: repo.owner?.login || "unknown",
    avatarUrl: repo.owner?.avatar_url ?? "",
    url: repo.html_url,
    description: repo.description ?? undefined,
    defaultBranch: repo.default_branch,
    createdAt: repo.created_at,
    updatedAt: repo.updated_at,
    lastPush: repo.pushed_at,
    lastCommitMessage: lastCommit.data.commit.message,
    lastCommitDate: lastCommit.data.commit.committer?.date,
    collaborators: await getRepoCollaborators(org, repo.name),
  };
}

async function getRepoCollaborators(org: string, repo: string) {
  try {
    const response = await octokit.rest.repos.listCollaborators({
      owner: org,
      repo,
      affiliation: "direct",
    });

    return response.data.map((user) => ({
      id: user.id,
      name: user.login,
      avatarUrl: user.avatar_url,
      htmlUrl: user.html_url,
      permissions: {
        admin: user.permissions?.admin ?? false,
        maintain: user.permissions?.maintain ?? false,
        push: user.permissions?.push ?? false,
        triage: user.permissions?.triage ?? false,
        pull: user.permissions?.pull ?? false,
      },
    }));
  } catch (error: any) {
    console.error(`Error fetching collaborators for ${repo}:`, error.message);
    return [];
  }
}

// export async function getFileContents(
//   owner: string,
//   repo: string,
//   filePaths: string[]
// ): Promise<Record<string, string | null>> {
//   const contents: Record<string, string | null> = {};
//   console.log(`\nFetching files from repository ${owner}/${repo}:`);

//   for (const filePath of filePaths) {
//     try {
//       const response = await octokit.rest.repos.getContent({
//         owner,
//         repo,
//         path: filePath,
//       });

//       if (
//         response.data &&
//         !Array.isArray(response.data) &&
//         response.data.type === "file" &&
//         response.data.content
//       ) {
//         const content = Buffer.from(response.data.content, "base64").toString(
//           "utf-8"
//         );
//         contents[filePath] = content;
//         console.log(` - ${filePath}: Downloaded (${content.length} bytes)`);
//       } else {
//         console.log(
//           ` - ${filePath}: Path found, but it's not a file or content is missing.`
//         );
//         contents[filePath] = null;
//       }
//     } catch (error: any) {
//       if (error.status === 404) {
//         console.log(` - ${filePath}: Not found.`);
//       } else {
//         console.error(
//           ` - Error fetching file ${filePath} from ${owner}/${repo}: ${error.status} ${error.message}`
//         );
//       }
//       contents[filePath] = null;
//     }
//   }

//   return contents;
// }

export async function getCommits(
  orgName: string,
  repoName: string
): Promise<CommitInfo[]> {
  const response = await octokit.rest.repos.listCommits({
    owner: orgName,
    repo: repoName,
    per_page: 100,
  });

  return response.data.map((commit) => ({
    sha: commit.sha,
    html_url: commit.html_url,
    commit: {
      message: commit.commit.message,
      author: {
        name: commit.commit.author?.name ?? "",
        email: commit.commit.author?.email ?? "",
        date: commit.commit.author?.date ?? "",
      },
    },
    author: commit.author
      ? {
          login: commit.author.login,
          avatar_url: commit.author.avatar_url,
          html_url: commit.author.html_url,
        }
      : null,
  }));
}
export async function getRepoTree(
  orgName: string,
  repoName: string
): Promise<string[]> {
  const { data: refData } = await octokit.rest.git.getRef({
    owner: orgName,
    repo: repoName,
    ref: "heads/main",
  });

  const { data: treeData } = await octokit.rest.git.getTree({
    owner: orgName,
    repo: repoName,
    tree_sha: refData.object.sha,
    recursive: "true",
  });

  return treeData.tree
    .filter((item) => item.type === "blob" && item.path)
    .map((item) => item.path!);
}

export async function getFileContents(
  orgName: string,
  repoName: string,
  path: string
): Promise<string | null> {
  try {
    const response = await octokit.rest.repos.getContent({
      owner: orgName,
      repo: repoName,
      path,
    });

    if ("content" in response.data) {
      return Buffer.from(response.data.content, "base64").toString("utf-8");
    }
    return null;
  } catch (error) {
    console.error(`Error fetching file ${path}:`, error);
    return null;
  }
}

export async function compareCommits(
  orgName: string,
  repoName: string,
  base: string,
  head: string
): Promise<CompareCommitsInfo> {
  const response = await octokit.rest.repos.compareCommits({
    owner: orgName,
    repo: repoName,
    base,
    head,
  });

  return {
    status: response.data.status ?? "",
    ahead_by: response.data.ahead_by ?? 0,
    behind_by: response.data.behind_by ?? 0,
    total_commits: response.data.total_commits ?? 0,
    commits: response.data.commits.map((commit) => ({
      sha: commit.sha,
      html_url: commit.html_url,
      commit: {
        message: commit.commit.message,
        author: {
          name: commit.commit.author?.name ?? "",
          email: commit.commit.author?.email ?? "",
          date: commit.commit.author?.date ?? "",
        },
      },
      author: commit.author
        ? {
            login: commit.author.login,
            avatar_url: commit.author.avatar_url,
            html_url: commit.author.html_url,
          }
        : null,
    })),
    files:
      response.data.files?.map((file) => ({
        filename: file.filename,
        status: file.status,
        additions: file.additions,
        deletions: file.deletions,
        changes: file.changes,
      })) ?? [],
  };
}
export async function getRepos(org: string): Promise<any[]> {
  const repos = await octokit.rest.repos.listForOrg({
    org,
    type: "all",
    per_page: 100,
  });

  return repos.data;
}
</file>

<file path="server/services/github/octokitClient.ts">
import { Octokit } from "@octokit/rest";
import dotenv from "dotenv";

dotenv.config();

export const octokit = new Octokit({
  auth: process.env.GITHUB_PAT,
});
</file>

<file path="server/services/UserService.ts">
import { supabase } from "../utils/supabase";

export async function upsertUser(
  githubId: string,
  username: string,
  email: string,
  githubUrl: string
) {
  try {
    const result = await supabase
      .from("users")
      .upsert(
        {
          github_id: githubId,
          username: username,
          github_url: githubUrl,
          email: email,
        },
        { onConflict: "github_id" }
      )
      .select()
      .single();

    // console.log("Supabase upsert result:", result);

    if (result.error) {
      console.error("Supabase error:", result.error);
      throw result.error;
    }

    return result.data;
  } catch (err) {
    console.error("Virhe kÃ¤yttÃ¤jÃ¤n tallennuksessa (catch):", err);
    throw err;
  }
}
</file>

<file path="server/tsconfig.json">
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "target": "ES2020", // Modern JS features
    "module": "CommonJS",
    "moduleResolution": "node", // Node-style resolution
    "rootDir": "..", // Source root
    "outDir": "./dist", // Output folder
    "esModuleInterop": true, // Support commonjs modules
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@shared/*": ["../shared/*"]
    }
  },
  "include": ["./", "Aievolution.ts"], // Include all files in this folder
  "exclude": ["node_modules", "dist"] // Avoid compiling node_modules and output
}
</file>

<file path="server/utils/githubUtils.ts">
export function extractAssignmentName(repoName: string): string {
  // Example: "assignment1-alice" => "assignment1"
  // TODO: modify or change this later if we need something different
  return repoName.replace(/-[a-zA-Z0-9]+$/, "");
}
</file>

<file path="server/utils/json2csv.ts">
declare module "json2csv" {
  export class Parser<T> {
    constructor(opts?: any);
    parse(input: T[]): string;
  }
}
</file>

<file path="server/utils/passport.ts">
import passport from "passport";
import { Strategy as GitHubStrategy, Profile } from "passport-github2";
import dotenv from "dotenv";

dotenv.config();

// GitHub OAuth configuration
passport.use(
  new GitHubStrategy(
    {
      clientID: process.env.GITHUB_CLIENT_ID as string,
      clientSecret: process.env.GITHUB_CLIENT_SECRET as string,
      callbackURL: process.env.GITHUB_CALLBACK_URL as string,
    },
    (
      accessToken: string,
      refreshToken: string,
      profile: Profile,
      done: (error: any, user?: Express.User | false | null) => void
    ) => {
      // console.log("Access Token:", accessToken);
      // console.log("GitHub Profile:", profile);
      return done(null, profile);
    }
  )
);

// Serialize user to store user in session
passport.serializeUser((user, done) => {
  done(null, user);
});

// Deserialize user from session
passport.deserializeUser((user, done) => {
  done(null, user as Express.User);
});

export default passport;
</file>

<file path="server/utils/supabase.ts">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.SUPABASE_URL!;
const supabaseKey = process.env.SUPABASE_KEY!;

export const supabase = createClient(supabaseUrl, supabaseKey);
</file>

<file path="shared/aiInterfaces.ts">
export interface AssignmentFeedback {
  // studentName: string;
  repoName: string;
  assignmentTitle: string;
  grade: string;
  date: string; // ISO format
  feedback: string;
  feedbackByFile: FileFeedback[];
}

interface FileFeedback {
  fileName: string;
  issues: FeedbackIssue[];
}

interface FeedbackIssue {
  id: number;
  line?: number;
  text: string;
}
</file>

<file path="shared/githubInterfaces.ts">
export interface OrgInfo {
  name: string;
  description: string | null;
  avatarUrl: string;
}

export interface AssignmentInfo {
  name: string;
  amountOfStudents: number;
  updatedAt: string;
}

export interface RepoInfo {
  id: string;
  name: string;
  owner: string;
  avatarUrl: string;
  url: string;
  description?: string;
  defaultBranch: string;
  createdAt: string;
  updatedAt: string;
  lastPush: string;
  lastCommitMessage: string;
  lastCommitDate: string;
  collaborators: Collaborator[];
}

export interface Collaborator {
  id: number;
  name: string;
  avatarUrl: string;
  htmlUrl: string;
  permissions: {
    admin: boolean;
    maintain: boolean;
    push: boolean;
    triage: boolean;
    pull: boolean;
  };
}

export interface User {
  id: string;
  username: string;
  displayName?: string;
  profileUrl?: string;
  photos?: { value: string }[];
}

export interface CommitAuthor {
  name: string;
  email: string;
  date: string;
}

export interface Commit {
  message: string;
  author: CommitAuthor;
}

export interface CommitInfo {
  sha: string;
  html_url: string;
  commit: Commit;
  author: {
    login: string;
    avatar_url: string;
    html_url: string;
  } | null;
}

export interface CompareCommitsInfo {
  status: string;
  ahead_by: number;
  behind_by: number;
  total_commits: number;
  commits: CommitInfo[];
  files: {
    filename: string;
    status: string;
    additions: number;
    deletions: number;
    changes: number;
  }[];
}
</file>

</files>
